<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[poj3709]]></title>
    <url>%2Fpoj3709%2F</url>
    <content type="text"><![CDATA[链接:poj3709 题解 容易得到O(N^2)的dp方程dp[i]=min(dp[j]+sum[i]-sum[j]-a[j+1]*(i-j)) 显然是个斜率dp 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=x;--i)#define ll long longusing namespace std;const int N=1e6+7;ll dp[N],a[N],sum[N];int n,m,q[N];inline void init()&#123; rep(i,1,n)&#123; scanf("%lld",&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125;&#125;inline ll Y(int x,int y)&#123;return dp[x]+a[x+1]*x-sum[x]-(dp[y]+a[y+1]*y-sum[y]);&#125;inline ll X(int x,int y)&#123;return a[x+1]-a[y+1];&#125;int main()&#123; scanf("%d",&amp;n); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); int head=1,tail=1; rep(i,1,2*m-1)dp[i]=sum[i]-a[1]*i; rep(i,2*m,n)&#123; //确保第一段一定是1开始的且长度为m while(head&lt;tail&amp;&amp;Y(q[tail],i-m)*X(q[tail-1],q[tail])&lt;=Y(q[tail-1],q[tail])*X(q[tail],i-m))--tail; q[++tail]=i-m; while(head&lt;tail&amp;&amp;Y(q[head+1],q[head])&lt;=X(q[head+1],q[head])*i)++head; dp[i]=dp[q[head]]+sum[i]-sum[q[head]]-a[q[head]+1]*(i-q[head]); &#125; printf("%lld\n",dp[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1160]]></title>
    <url>%2Fpoj1160%2F</url>
    <content type="text"><![CDATA[链接:poj1160 题解 首先预处理出i~j放一个邮局的最短距离dis[i][j],dp[j][i]表示前i个村庄放了j个邮局的最短距离 dp[j][i]=min(dp[j-1][k]+dis[k+1][i])123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=307;int dp[N][N],dis[N][N],x[N],n,m;inline void init()&#123; memset(dp,0x3f,sizeof dp); rep(i,1,n)scanf("%d",&amp;x[i]); sort(x+1,x+n+1); rep(i,1,n)rep(j,i+1,n)dis[i][j]=dis[i][j-1]+x[j]-x[i+j&gt;&gt;1];&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); rep(i,1,n)dp[1][i]=dis[1][i]; rep(j,2,m)rep(i,1,n)rep(k,1,i-1)dp[j][i]=min(dp[j][i],dp[j-1][k]+dis[k+1][i]); printf("%d\n",dp[m][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3045]]></title>
    <url>%2Fhdu3045%2F</url>
    <content type="text"><![CDATA[链接:hdu3045 题解 显然根据题意排序后,所有集合都是连续的,a[i]表示每只cow的Moo~,sum前缀和,dp[i]表示前i只牛组成的集合的最小减少 即dp[i]=min(dp[j]+sum[i]-sum[j]-(i-j)*a[j+1]) j+1~i划为一个集合 显然是个斜率dp 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=4e5+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;ll dp[N],sum[N],a[N];int n,m,q[N];inline void init()&#123; rep(i,1,n)read(a[i]); sort(a+1,a+n+1); rep(i,1,n)sum[i]=a[i]+sum[i-1]; rep(i,m,2*m-1)dp[i]=sum[i]-i*a[1];&#125;inline ll Y(int x,int y)&#123;return dp[x]-sum[x]+a[x+1]*x-(dp[y]-sum[y]+a[y+1]*y);&#125;inline ll X(int x,int y)&#123;return a[x+1]-a[y+1];&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); int head=1,tail=1; rep(i,2*m,n)&#123; while(head&lt;tail&amp;&amp;Y(q[tail],i-m)*X(q[tail-1],q[tail])&lt;=Y(q[tail-1],q[tail])*X(q[tail],i-m))--tail; q[++tail]=i-m; while(head&lt;tail&amp;&amp;Y(q[head+1],q[head])&lt;=X(q[head+1],q[head])*i)++head; dp[i]=dp[q[head]]+sum[i]-sum[q[head]]-a[q[head]+1]*(i-q[head]); &#125; printf("%I64d\n",dp[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3669]]></title>
    <url>%2Fhdu3669%2F</url>
    <content type="text"><![CDATA[链接:hdu3669 题解 把给的矩形以长为第一关键词宽为第二关键词降序排列,去掉包含的矩形,定义dp[j][i]表示前i个矩形挖了j个洞的最小花费 则dp[j][i]=min(dp[j-1][k-1]+x[k]*y[i]) 依然考虑p&lt;k,且k比p优则dp[j-1][k-1]+x[k]*y[i]]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1300]]></title>
    <url>%2Fhdu1300%2F</url>
    <content type="text"><![CDATA[链接:hdu1300 题解 其实这个数据量根本不需要优化2333 dp[i]表示前i个数得到的最大价值 然后很容易就可以得到转移方程,每次选j~i这个级别的放在一起 dp[i]=min(dp[j-1]+(sum[i]-sum[j-1])*p[i]) 虽然到这里就可以AC了,还是考虑下斜率优化 考虑k&lt;j,j比k更优 dp[j-1]+(sum[i]-sum[j-1])*p[i]]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2829]]></title>
    <url>%2Fhdu2829%2F</url>
    <content type="text"><![CDATA[链接:hdu2829 题解 先介绍斜率优化做法 我们用res[i]表示1~i的区间权值,sum[i]表示1~i的前缀和,那么区间a+1~b的权值为res[b]-res[a]-sum[a]*(sum[b]-sum[a]) dp[j][i]表示前i个数断了j次的最小权值 则dp[j][i]=min(dp[j-1][k]+res[i]-res[k]-sum[k]*(sum[i]-sum[k])) 剩下的和hdu3507一样的1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+7;int n,m,q[N];ll dp[N][N],sum[N],res[N];inline ll Y(int a,int b,int c)&#123;return dp[c][a]-res[a]+sum[a]*sum[a]-dp[c][b]+res[b]-sum[b]*sum[b];&#125;inline ll X(int a,int b)&#123;return sum[a]-sum[b];&#125;inline void init()&#123; rep(i,1,n)&#123; scanf("%d",&amp;sum[i]); res[i]=res[i-1]+sum[i]*sum[i-1]; sum[i]+=sum[i-1]; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n||m))&#123; init(); rep(i,1,n)dp[0][i]=res[i]; rep(j,1,m)&#123; int head=1,tail=1;q[1]=0; rep(i,1,n)&#123; while(head&lt;tail&amp;&amp;Y(q[head+1],q[head],j-1)&lt;sum[i]*X(q[head+1],q[head]))++head; dp[j][i]=dp[j-1][q[head]]+res[i]-res[q[head]]-sum[q[head]]*(sum[i]-sum[q[head]]); while(head&lt;tail&amp;&amp;Y(i,q[tail],j-1)*X(q[tail],q[tail-1])&lt;=Y(q[tail],q[tail-1],j-1)*X(i,q[tail]))tail--; q[++tail]=i; &#125; &#125; printf("%lld\n",dp[m][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4528]]></title>
    <url>%2Fhdu4528%2F</url>
    <content type="text"><![CDATA[链接:hdu4528 题解 bfs好题,简单但是有点烦,注意E,D要当成墙2333.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e2+7;typedef pair&lt;int,int&gt; s;struct node&#123; int x,y,dis,cnt; inline void init(int a,int b,int c,int d)&#123;x=a;y=b;dis=c;cnt=d;&#125;&#125;a;s A,B,S;queue&lt;node&gt; q;char str[N];int map[N][N],vis[4][N][N],n,m,t,T;int dx[]=&#123;0,-1,1,0,0&#125;;int dy[]=&#123;0,0,0,-1,1&#125;;inline int judge(int x,int y)&#123;return x&lt;1||x&gt;n||y&lt;1||y&gt;m||map[x][y]==4;&#125;inline void init()&#123; memset(vis,0,sizeof vis); while(!q.empty())q.pop(); rep(i,1,n)&#123; scanf("%s",str+1); rep(j,1,m)&#123; map[i][j]=(str[j]!='.'&amp;&amp;str[j]!='S')?4:0; if(str[j]=='S')S=s(i,j); else if(str[j]=='E')A=s(i,j); else if(str[j]=='D')B=s(i,j); &#125; &#125; rep(k,1,2)&#123; int x,y; if(k==1)x=A.first,y=A.second; else x=B.first,y=B.second; rep(j,1,4)rep(l,1,j&lt;3?n:m)&#123; int nx=x+dx[j]*l,ny=y+dy[j]*l; if(judge(nx,ny))break; map[nx][ny]+=k; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;T); rep(cse,1,T)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;t); init(); int res=0,ans=-1; a.init(S.first,S.second,0,map[S.first][S.second]); if(a.cnt==4)a.cnt=0; q.push(a);vis[a.cnt][S.first][S.second]; while(!q.empty())&#123; int x=q.front().x,y=q.front().y,dis=q.front().dis,cnt=q.front().cnt; q.pop(); if(cnt==3)&#123;ans=dis;break;&#125; rep(i,1,4)&#123; int nx=x+dx[i],ny=y+dy[i]; if(judge(nx,ny)||dis+1&gt;t)continue; int ncnt=cnt+((map[nx][ny]!=cnt)?map[nx][ny]:0); if(ncnt&gt;3)ncnt=3; if(vis[ncnt][nx][ny])continue; a.init(nx,ny,dis+1,ncnt); vis[ncnt][nx][ny]=1; q.push(a); &#125; &#125; printf("Case %d:\n%d\n",cse,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2993]]></title>
    <url>%2Fhdu2993%2F</url>
    <content type="text"><![CDATA[链接:hdu2993 题解 论文题2333,某中学大佬写的论文,建议搞懂思路没必要去AC,卡IO,快速读入输出都会T… 题意是求max(\frac{a[i]+a[i+1]+...+a[j]}{j-i+1}) (j-i>k) 分子显然可以用前缀和优化,转换为求max(\frac{sum[i]-sum[j]}{j-i}) (j-i>k) 这其实就是在N+1个点(i,sum[i])中求横坐标距离大于k的点对斜率的最值.显然是斜率dp1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;const int BUF = 25000000;int q[N],sum[N],n,k;char Buf[BUF],*buf=Buf;template &lt;typename T&gt;inline void read(T &amp;x)&#123; for(x=0;*buf&lt;'0';buf++); while(*buf&gt;='0')x=x*10+*buf++-'0';&#125;inline int useless2(int a,int b,int c)&#123;return (1LL*sum[c]-sum[b])*(b-a)&lt;=(1LL*sum[b]-sum[a])*(c-b);&#125;inline int useless1(int a,int b,int c)&#123;return (1LL*sum[c]-sum[b])*(c-a)&lt;=(1LL*sum[c]-sum[a])*(c-b);&#125;int main()&#123; int tot=fread(Buf,1,BUF,stdin); while(1)&#123; if(buf-Buf+1&gt;=tot)break; read(n);read(k); rep(i,1,n)&#123; read(sum[i]); sum[i]+=sum[i-1]; &#125; int head=1,tail=0;double ans=-0x3f3f3f3f; rep(i,k,n)&#123; while(head&lt;tail&amp;&amp;useless2(q[tail-1],q[tail],i-k))tail--; q[++tail]=i-k; while(head&lt;tail&amp;&amp;useless1(q[head+1],q[head],i))head++; ans=max(1.0*(sum[i]-sum[q[head]])/(i-q[head]),ans); &#125; printf("%.2lf\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2411]]></title>
    <url>%2Fpoj2411%2F</url>
    <content type="text"><![CDATA[链接:poj2411 题解 dp[i][j]表示前i行都合法放置的情况下第i行方法为j的方案数 这里我们规定当前这位如果不放,那么该位为0, 当前这位如果右放,对应两位为1 如果下放,当前位为0,下一行的对应位为1 由于要求完美覆盖,我们可以预处理出所有合法放置及关系,然后一个简单状压dp就解决了(不预处理也能AC)12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=15;const int M=1&lt;&lt;11;int n,m,path[M*M+7][2],cnt;ll dp[N][M];inline void get(int a,int pre,int now)&#123; if(a&gt;m)return ; if(a==m)&#123; path[++cnt][0]=pre; path[cnt][1]=now; &#125; get(a+1,pre&lt;&lt;1|1,now&lt;&lt;1); //不放 get(a+1,pre&lt;&lt;1,now&lt;&lt;1|1); //上方 get(a+2,pre&lt;&lt;2|3,now&lt;&lt;2|3); //右放&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n||m))&#123; cnt=0; get(0,0,0); memset(dp,0,sizeof dp); dp[0][(1&lt;&lt;m)-1]=1; rep(i,1,n)rep(j,1,cnt)dp[i][path[j][1]]+=dp[i-1][path[j][0]]; printf("%lld\n",dp[n][(1&lt;&lt;m)-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3507]]></title>
    <url>%2Fhdu3507%2F</url>
    <content type="text"><![CDATA[链接:hdu3507 题解 dp方程很容易得到dp[i]表示输出到i的最小花费,dp[i]=min(dp[j]+(s[i]-s[j-1])^2),后面那坨有i有j，显然不能直接单调队列优化 考虑某个状态k(kdp[j]+(s[i]-s[j])^2整理一下，把与i无关的放一边得到s[i]>\frac{dp[j]+s[j-1]^2-(dp[k]+s[k-1]^2)}{s[j-1]-s[k-1]} 到这里斜率就出来了,剩下的就是一个简单的斜率优化dp 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int n,m,q[N],tail,head;int dp[N],sum[N];inline int X(int a,int b)&#123;return (sum[a]-sum[b])*2;&#125;inline int Y(int a,int b)&#123;return dp[a]-dp[b]+sum[a]*sum[a]-sum[b]*sum[b];&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; head=tail=1; q[1]=0; rep(i,1,n)&#123; scanf("%d",&amp;sum[i]); sum[i]+=sum[i-1]; while(head&lt;tail&amp;&amp;Y(q[head+1],q[head])&lt;=X(q[head+1],q[head])*sum[i])++head; dp[i]=(sum[i]-sum[q[head]])*(sum[i]-sum[q[head]])+m+dp[q[head]]; while(head&lt;tail&amp;&amp;Y(i,q[tail])*X(q[tail],q[tail-1])&lt;=Y(q[tail],q[tail-1])*X(i,q[tail]))--tail; q[++tail]=i; &#125; printf("%d\n",dp[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ICPC-沈阳赛区网络赛D]]></title>
    <url>%2F2018ICPC-%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E8%B5%9BD%2F</url>
    <content type="text"><![CDATA[链接:2018ICPC-沈阳赛区网络赛D 题解 求k短路，根据spfa的性质，某个点第k次出队即是源点到这个点的第k短路。 显然根据性质直接做是不可行的，简单的做法是建反向边spfa之后求出所有点到t的最短路 然后用当前距离加上该点到t的最短距离作为优先级A*搜索一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+7;const int M=1e5+7;const int inf=0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;struct node&#123; int v,to,nxt;&#125;e[M][2];struct A&#123; int to,g,f; bool operator&lt;(const A &amp;a)const &#123; return a.f==f?a.g&lt;g:a.f&lt;f; &#125;&#125;;priority_queue&lt;A&gt; Q;int n,m,S,E,K,T,vis[N],dis[N],head[N][2],cnt[2],inq[N];inline void adde(int a,int b,int c,int op)&#123; e[++cnt[op]][op].to=b; e[cnt[op]][op].v=c; e[cnt[op]][op].nxt=head[a][op]; head[a][op]=cnt[op];&#125;void spfa()&#123; queue&lt;int&gt; q; memset(inq,0,sizeof inq); memset(dis,0x3f,sizeof dis); inq[E]=1; dis[E]=0; q.push(E); while(!q.empty())&#123; int k=q.front(); q.pop(); inq[k]--; if(inq[k]&gt;n)return ; for(int i=head[k][1];i;i=e[i][1].nxt)&#123; int v=e[i][1].to,c=e[i][1].v; if(dis[v]&gt;dis[k]+c)&#123; dis[v]=dis[k]+c; if(!inq[v])&#123; q.push(v); inq[v]++; &#125; &#125; &#125; &#125;&#125;int A_star()&#123; A a,b; int ct=0; if(dis[S]==inf)return -1; a.to=S; a.g=0; a.f=dis[a.to]; Q.push(a); while(!Q.empty())&#123; a=Q.top(); Q.pop(); if(a.to==E)ct++; if(a.to==E&amp;&amp;a.g&gt;T)return -1; if(ct==K)return a.g; for(int i=head[a.to][0];i;i=e[i][0].nxt)&#123; b.to=e[i][0].to; b.g=a.g+e[i][0].v; b.f=b.g+dis[b.to]; Q.push(b); &#125; &#125; return -1;&#125;inline void init()&#123; memset(head,0,sizeof(head)); memset(cnt,0,sizeof(cnt)); read(S);read(E);read(K);read(T); rep(i,1,m)&#123; int a,b,c; read(a);read(b);read(c); adde(a,b,c,0); adde(b,a,c,1); &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); spfa(); int ans=A_star(); if(ans==-1||ans&gt;T)puts("Whitesnake!"); else puts("yareyaredawa"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ICPC-徐州赛区网络赛F]]></title>
    <url>%2F2018ICPC-%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E8%B5%9BF%2F</url>
    <content type="text"><![CDATA[链接:2018ICPC-徐州赛区网络赛F 题解12]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lg1439]]></title>
    <url>%2Flg1439%2F</url>
    <content type="text"><![CDATA[链接:lg1439 题解 注意是n的全排列，所以用a串作为字典串将b串更改一下,例如a串3 2 1 4 5 b串1 2 3 4 5 更改之后b串变为3 2 1 4 5 ，求最长公共子序列变为求新b串的最长上升子序列1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;const int inf=0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int id[N],a[N],n,dp[N],ans;int main()&#123; read(n); int x; memset(dp,0x3f,sizeof dp);dp[0]=0; rep(i,1,n)&#123;read(x);id[x]=i;&#125; rep(i,1,n)&#123;read(x);a[i]=id[x];&#125; rep(i,1,n)&#123; if(a[i]&gt;dp[ans])dp[++ans]=a[i]; else &#123; int k=lower_bound(dp+1,dp+ans+1,a[i])-dp; dp[k]=min(dp[k],a[i]); &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ICPC-徐州网络赛]]></title>
    <url>%2F2018ICPC-%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E8%B5%9BB%2F</url>
    <content type="text"><![CDATA[链接:2018ICPC-徐州网络赛 题解 据说博弈也可以A，赛场上题读错了。。。 其实很简单，A会尽量使答案变大，B会尽量使答案变小。这样就是一个简单的DP。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+7;const int st=101;template&lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int dp[2][300],op[N][3],n,m,k,l;int main()&#123; read(n);read(m);read(k);read(l); int cur=0; rep(i,1,n)rep(j,0,2)read(op[i][j]); rep(i,-100,100)dp[cur][i+st]=i; repd(i,n,1)&#123; cur^=1; if(i&amp;1)rep(j,-100,100)&#123; dp[cur][j+st]=-100; int k; if(op[i][0])&#123; k=min(100,j+op[i][0]); dp[cur][j+st]=max(dp[cur][j+st],dp[cur^1][k+st]); &#125; if(op[i][1])&#123; k=max(-100,j-op[i][1]); dp[cur][j+st]=max(dp[cur][j+st],dp[cur^1][k+st]); &#125; if(op[i][2])&#123; k=-j; dp[cur][j+st]=max(dp[cur][j+st],dp[cur^1][k+st]); &#125; &#125; else rep(j,-100,100)&#123; dp[cur][j+st]=100; int k; if(op[i][0])&#123; k=min(100,j+op[i][0]); dp[cur][j+st]=min(dp[cur][j+st],dp[cur^1][k+st]); &#125; if(op[i][1])&#123; k=max(-100,j-op[i][1]); dp[cur][j+st]=min(dp[cur][j+st],dp[cur^1][k+st]); &#125; if(op[i][2])&#123; k=-j; dp[cur][j+st]=min(dp[cur][j+st],dp[cur^1][k+st]); &#125; &#125; &#125; if(dp[cur][m+st]&gt;=k)puts("Good Ending"); else if(dp[cur][m+st]&gt;l)puts("Normal Ending"); else puts("Bad Ending"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2763[分层图]]]></title>
    <url>%2Fbzoj2763-%E5%88%86%E5%B1%82%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[链接:bzoj2763[分层图] 题解 分层图最短路，dis[i][j]表示到节点i用了j次免费的最小花费，更新的时候j&lt;k的话尝试更新j+1次免费的最小花费，具体看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int nxt[N],head[N],w[N],v[N],dis[N][13],vis[N][13];int n,m,h,cnt,s,t;inline void adde(int a,int b,int c)&#123; v[++cnt]=b; w[cnt]=c; nxt[cnt]=head[a]; head[a]=cnt;&#125;struct node&#123; int d,u,id; node(int a=0,int b=0,int c=0):d(a),u(b),id(c)&#123;&#125; bool operator&lt;(const node &amp;a)const &#123;return d&gt;a.d;&#125;&#125;;priority_queue&lt;node&gt; q;void dijkstra()&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); q.push(node(0,s,0)); while(!q.empty())&#123; node a=q.top(); q.pop(); int ds=a.d,u=a.u,id=a.id; if(vis[u][id])continue; vis[u][id]=1; for(int i=head[u];i;i=nxt[i])&#123; int k=v[i],c=w[i]; if(id&lt;h&amp;&amp;!vis[k][id+1]&amp;&amp;dis[k][id+1]&gt;ds)&#123; dis[k][id+1]=ds; q.push(node(ds,k,id+1)); &#125; if(!vis[k][id]&amp;&amp;dis[k][id]&gt;ds+c)&#123; dis[k][id]=ds+c; q.push(node(dis[k][id],k,id)); &#125; &#125; &#125;&#125;int main()&#123; read(n);read(m);read(h); read(s);read(t); rep(i,1,m)&#123; int a,b,c; read(a);read(b);read(c); adde(a,b,c); adde(b,a,c); &#125; dijkstra(); int ans=0x3f3f3f3f; rep(i,0,h)ans=min(ans,dis[t][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1903]]></title>
    <url>%2Flg1903%2F</url>
    <content type="text"><![CDATA[链接:lg1903 题解 带修改莫队,记录一下当前询问的上一个版本（看起来好像跟可持续化没什么区别） 其他的跟普通莫队没什么区别，具体看代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e4+7;const int M=1e6+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;struct node&#123; int l,r,pre,id;&#125;q[N];struct node1&#123; int val,id;&#125;change[N];int A[N],pos[N],a[N],col[M],n,m,cntc,cntq;char s[2];inline int cmp_pos(node x,node y)&#123; if(pos[x.l]!=pos[y.l])return x.l&lt;y.l; if(pos[x.r]!=pos[y.r])return x.r&lt;y.r; return x.pre&lt;y.pre;&#125;inline void init()&#123; read(n);read(m); int len=sqrt(n); rep(i,1,n)read(a[i]),pos[i]=(i-1)/len+1; rep(i,1,m)&#123; scanf("%s",s); if(s[0]=='Q')&#123; read(q[++cntq].l); read(q[cntq].r); q[cntq].pre=cntc; q[cntq].id=cntq; &#125; else &#123; read(change[++cntc].id); read(change[cntc].val); &#125; &#125; sort(q+1,q+cntq+1,cmp_pos);&#125;inline void del(ll &amp;ans,int id)&#123; if(--col[id]==0)ans--;&#125;inline void add(ll &amp;ans,int id)&#123; if(++col[id]==1)ans++;&#125;inline void work(ll &amp;ans,int id,int now)&#123; if(change[id].id&gt;=q[now].l&amp;&amp;change[id].id&lt;=q[now].r)&#123; if(--col[a[change[id].id]]==0)ans--; if(++col[change[id].val]==1)ans++; &#125; swap(change[id].val,a[change[id].id]);&#125;void solve()&#123; init(); ll ans=0; int l=1,r=0,now=0;; rep(i,1,cntq)&#123; while(l&gt;q[i].l)add(ans,a[--l]); while(l&lt;q[i].l)del(ans,a[l++]); while(r&lt;q[i].r)add(ans,a[++r]); while(r&gt;q[i].r)del(ans,a[r--]); while(now&lt;q[i].pre)work(ans,++now,i); while(now&gt;q[i].pre)work(ans,now--,i); A[q[i].id]=ans; &#125; rep(i,1,cntq)printf("%d\n",A[i]);&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1972]]></title>
    <url>%2Flg1972%2F</url>
    <content type="text"><![CDATA[链接:lg1972 题解 裸的莫队，板子套上搞一搞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e5+7;const int M=1e6+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int col[N],f[M],pos[N],n,m;ll ans;struct node&#123; int l,r,id,ans;&#125;q[N];inline int cmp_id(node a,node b)&#123;return a.id&lt;b.id;&#125;inline int cmp_pos(node a,node b)&#123;return pos[a.l]==pos[b.l]?((pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r):pos[a.l]&lt;pos[b.l];&#125;inline void modify1(int p,ll &amp;ans)&#123;if(++f[col[p]]==1)ans++;&#125;inline void modify2(int p,ll &amp;ans)&#123;if(--f[col[p]]==0)ans--;&#125;inline void init()&#123; read(n); rep(i,1,n)read(col[i]); int x=sqrt(n); rep(i,1,n)pos[i]=(i-1)/x+1; read(m); rep(i,1,m)&#123; read(q[i].l); read(q[i].r); q[i].id=i; &#125; sort(q+1,q+m+1,cmp_pos);&#125;inline void solve()&#123; int l=1,r=0;ans=0; rep(i,1,m)&#123; if(r&lt;q[i].r)&#123; for(r=r+1;r&lt;q[i].r;++r)modify1(r,ans); modify1(r,ans); &#125; if(q[i].l&lt;l)&#123; for(l=l-1;l&gt;q[i].l;--l)modify1(l,ans); modify1(l,ans); &#125; if(r&gt;q[i].r)for(;r&gt;q[i].r;--r)modify2(r,ans); if(q[i].l&gt;l)for(;q[i].l&gt;l;++l)modify2(l,ans); q[i].ans=ans; &#125; sort(q+1,q+m+1,cmp_id); rep(i,1,m)printf("%d\n",q[i].ans);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1494]]></title>
    <url>%2Flg1494%2F</url>
    <content type="text"><![CDATA[链接:lg1494 题解 显然要求的是$\frac {\sum_{i=1}^v{C_{f(i)}^2}}{C_{r-l+1}^2}$ (v表示数字值，f(i)表示数字i在区间内出现的次数) 首先考虑分子$C_{x}^2=\frac {x^2-x}{2}$,分子可写成$\frac{\sum_{i=1}^{v}f(i)^2-\sum_{i=1}^{v}f(i)}{2}$ 显然$\sum_{i=1}^{v}f(i)=r-l+1$ 现在的问题是已知$[l,r]的值,如何求[l,r+1]的值,这时只增加了一个Z,是很好处理的,设原分子为S_0,现在为S$ 显然$S=S_0-f(Z)^2+(f(Z)+1)^2-1=S_0+2*f(Z),O(1)即可完成$ 这样区间间的移动就可以$O(|r-r_i|+|l-l_i|)$做到 接下来就可以用莫队完成了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;x=0;int sign=1; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int n,m,f[N],col[N],pos[N];ll ans;struct node&#123; int l,r,id; ll a,b; &#125;q[N];inline ll gcd(ll a,ll b)&#123; while(b)&#123; ll t=a%b; a=b; b=t; &#125; return a;&#125;inline int cmp_id(node a,node b)&#123;return a.id&lt;b.id;&#125;inline int cmp_pos(node a,node b)&#123;return pos[a.l]==pos[b.l]?pos[a.r]&lt;pos[b.r]:pos[a.l]&lt;pos[b.l];&#125;inline void init()&#123; read(n);read(m); rep(i,1,n)read(col[i]); int x=sqrt(n); rep(i,1,n)pos[i]=(i-1)/x+1; rep(i,1,m)&#123;read(q[i].l);read(q[i].r);q[i].id=i;&#125; sort(q+1,q+m+1,cmp_pos);&#125;inline void modify(int p,ll &amp;ans,int add)&#123; ans+=2*add*f[col[p]]+1; f[col[p]]+=add;&#125;inline void modify(node &amp;a)&#123; ll t=gcd(a.b,a.a); if(t)&#123; a.a/=t; a.b/=t; &#125;&#125;inline void solve()&#123; int l=1,r=0;ans=0; rep(i,1,m)&#123; if(r&lt;q[i].r)&#123; for(r=r+1;r&lt;q[i].r;++r)modify(r,ans,1); modify(r,ans,1); &#125; if(q[i].l&lt;l)&#123; for(l=l-1;l&gt;q[i].l;--l)modify(l,ans,1); modify(l,ans,1); &#125; if(r&gt;q[i].r)&#123; for(;r&gt;q[i].r;--r)modify(r,ans,-1); //modify(r,ans,-1); &#125; if(l&lt;q[i].l)&#123; for(;l&lt;q[i].l;++l)modify(l,ans,-1); //modify(l,ans,-1); &#125; if(q[i].l==q[i].r)&#123; q[i].a=0; q[i].b=1; continue; &#125; q[i].a=ans-q[i].r+q[i].l-1; q[i].b=1ll*(q[i].r-q[i].l+1)*(q[i].r-q[i].l); modify(q[i]); &#125; sort(q+1,q+m+1,cmp_id); rep(i,1,m)printf("%lld/%lld\n",q[i].a,q[i].b);&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6319[多校第三场A]]]></title>
    <url>%2Fhdu6319-%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BAA%2F</url>
    <content type="text"><![CDATA[链接:hdu6319[多校第三场A] Description InputOutputSample InputSample Output题解1]]></content>
  </entry>
  <entry>
    <title><![CDATA[hdu6315[多校第二场G]]]></title>
    <url>%2Fhdu6315-%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BAG%2F</url>
    <content type="text"><![CDATA[链接:hdu6315[多校第二场G] 题解 线段树维护c[i]=b[i]-a[i]%b[i]的最小值以及$ans=\frac{a[i]}{b[i]}$(向下取整)的区间和,当有小于等于0的东西出现的时候就暴力往下更新 有的人可能会说这东西会T 0.0,是的如果没有题目上那句b is a static permutation of 1 to n.这个算法确实会T.既然b是1-n的一个排列,并且a[i]从0最多到m,所以总的是$\sum_{i=0}^n{\frac{m}{i}}$,这东西是个调和级数约等于$mlog(n)$,加个线段树显然复杂度是$O(m*{log^2(n)})$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,r#define lowbit(x) x&amp;(-x)using namespace std;const int N=1e5+7;int nm[N],tr[N&lt;&lt;2],lz[N&lt;&lt;2],n,m;ll ans[N&lt;&lt;2];char op[10];void pushdown(int o,int l,int r)&#123; int v=lz[o]; lz[o&lt;&lt;1]+=v; lz[o&lt;&lt;1|1]+=v; tr[o&lt;&lt;1]-=v; tr[o&lt;&lt;1|1]-=v; lz[o]=0;&#125;inline void pushup(int o,int l,int r)&#123; tr[o]=min(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); ans[o]=ans[o&lt;&lt;1]+ans[o&lt;&lt;1|1];&#125;void build(int o,int l,int r)&#123; lz[o]=0; if(l==r)&#123; scanf("%d",&amp;nm[l]); tr[o]=nm[l]; ans[o]=0; return ; &#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o,l,r);&#125;void update(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; tr[o]--; if(tr[o]&gt;0)&#123;lz[o]++;return ;&#125; if(l==r&amp;&amp;tr[o]&lt;=0)&#123; tr[o]+=nm[l]; ans[o]++; return ; &#125; &#125; if(lz[o])pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R); if(R&gt;mid)update(rson,L,R); pushup(o,l,r);&#125;ll query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return ans[o]; if(lz[o])pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll res=0; if(L&lt;=mid)res+=query(lson,L,R); if(R&gt;mid)res+=query(rson,L,R); return res;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; build(1,1,n); while(m--)&#123; int l,r; scanf("%s%d%d",op,&amp;l,&amp;r); if(op[0]=='a')update(1,1,n,l,r); else printf("%lld\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6298[多校第一场A]]]></title>
    <url>%2Fhdu6298-%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BAA%2F</url>
    <content type="text"><![CDATA[链接:hdu6298[多校第一场A] 题解 显然n=\frac{n}{a}+\frac{n}{b}+\frac{n}{c},a|n,b|n,c|n 约分之后是1=\frac{1}{a}+\frac{1}{b}+\frac{1}{c} 1=\frac{1}{2}+\frac{1}{3}+\frac{1}{6}=\frac{1}{3}+\frac{1}{3}+\frac{1}{3}=\frac{1}{2}+\frac{1}{4}+\frac{1}{4} 显然要使得\frac{n^3}{abc}最大只有右面两种情况可能，即n%3==0||n%4==0成立才有解，且前者优先 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;int n,T;int main()&#123; scanf("%d",&amp;T); while(T--&amp;&amp;~scanf("%d",&amp;n))&#123; if(n%3==0)&#123; n/=3; printf("%lld\n",1ll*n*n*n); &#125; else if(n%4==0)&#123; printf("%lld\n",1ll*n*n*n/32); &#125; else puts("-1"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6301[多校第一场D]]]></title>
    <url>%2Fhdu6301-%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BAD%2F</url>
    <content type="text"><![CDATA[链接:hdu6301[多校第一场D] 题解 当时忘了set自带排序功能2333,TLE无数发 思路很简单，断开的区间很好处理，无脑填就好，又重复区间的时候，a[lst].l~a[i].l-1这一段是可以重复使用的，把它放到set,然后依次填就好。具体看代码吧0.0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define ull unsigned long longusing namespace std;const int N=1e5+7;const int M=1e5+7;struct node&#123; int l,r;&#125;a[N],tp[N];int T,n,m,ans[N];set&lt;int&gt;st;inline int cmp(node x,node y)&#123;return x.l!=y.l?x.l&lt;y.l:x.r&lt;y.r;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; st.clear(); scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)st.insert(i); memset(ans,0,sizeof(ans)); rep(i,1,m)&#123; scanf("%d%d",&amp;a[i].l,&amp;a[i].r); &#125; sort(a+1,a+m+1,cmp); int lst=0; rep(i,1,m)&#123; if(a[i].l&lt;=a[lst].r&amp;&amp;a[i].r&lt;=a[lst].r)continue; if(a[i].l&lt;=a[lst].r)&#123; rep(j,a[lst].l,a[i].l-1)st.insert(ans[j]); rep(j,a[lst].r+1,a[i].r)&#123; ans[j]=*st.begin(); st.erase(ans[j]); &#125; &#125; else &#123; if(i!=1)rep(j,a[lst].l,a[lst].r)if(!st.count(ans[j]))st.insert(ans[j]); rep(j,a[i].l,a[i].r)&#123; ans[j]=*st.begin(); st.erase(ans[j]); &#125; &#125; lst=i; &#125; rep(i,1,n)printf("%d%c",ans[i]?ans[i]:1,i!=n?' ':'\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj3981]]></title>
    <url>%2Fzoj3981%2F</url>
    <content type="text"><![CDATA[链接:zoj3981 题解 假设站在第一个点每个AC的不满意度则是d[i]=(s[a]+m-1-b)%m，可能出现负数，没关系，之后会处理这种情况。 然后sort一下站在第一个点的不满意度,显然如果站在第i个AC点，d[i]会变成0，之后每个点都会变成d[j]-d[i],之前的每个点会变成d[j]-d[i]+m。这也正好处理了出现负数的情况。123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(int i=x;i&lt;=y;++i)#define repd(i,x,y) for(int i=x;i&gt;=y;--i)#define ll long long#define lowbit(x) x&amp;(-x)using namespace std;const int N=1e5+7;const ll lnf=0x3f3f3f3f3f3f;ll ans,d[N],res,a,b,s[N],n,m,p,T;int main()&#123; scanf("%d",&amp;T); while(T--&amp;&amp;~scanf("%d%d%d",&amp;n,&amp;m,&amp;p))&#123; res=0;ans=lnf; rep(i,1,n)scanf("%d",&amp;s[i]); rep(i,1,p)&#123; scanf("%lld%lld",&amp;a,&amp;b); d[i]=(ll)((ll)s[a]+m-1-b)%m; res+=d[i]; &#125; sort(d+1,d+p+1); rep(i,1,p)ans=min(ans,res+m*(i-1)-d[i]*p); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3485]]></title>
    <url>%2Fpoj3485%2F</url>
    <content type="text"><![CDATA[链接:poj3485 题解 公路就是x轴，这题其实就是区间选点问题。 以村庄位圆心，D为半径，与x轴两个交点，显然只需要这段区间内选一个点就可以让这个村庄满足题意，所以问题转换为在给定的n个区间中选择最少的点，使得每个区间最少有一个点。 然后就直接贪心一下就可以AC。半夜做题效率确实有点低QWQ123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(int i=x;i&lt;=y;++i)#define repd(i,x,y) for(int i=x;i&gt;=y;--i)#define ll long long#define lowbit(x) x&amp;(-x)using namespace std;const int N=1e5+7;const double eps=1e-10;const int inf=0x3f3f3f3f;typedef pair&lt;double,double&gt; q;q a[N];int ans,L,D,n;int main()&#123; while(~scanf("%d%d%d",&amp;L,&amp;D,&amp;n))&#123; D*=D;ans=1; rep(i,1,n)&#123; double x,y; scanf("%lf%lf",&amp;x,&amp;y); double tp=sqrt(D-y*y); a[i]=q(x+tp,x-tp); &#125; sort(a+1,a+n+1); double lst=a[1].first; rep(i,2,n)if(lst&lt;a[i].second)ans++,lst=a[i].first; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj3993]]></title>
    <url>%2Fzoj3993%2F</url>
    <content type="text"><![CDATA[链接:zoj3993 题解 首先要搞清楚这题的概率怎么算，以建筑物为圆心r为半径的圆在大圆以内的面积除以大圆面积。 很显然在点到初始圆心max(2*r-R,R-2*r)以内的建筑物安全概率都是1，如果没有这样的点，就选距离圆心最近的点。 1234567891011121314151617181920212223242526272829303132#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(int i=x;i&lt;=y;++i)#define repd(i,x,y) for(int i=x;i&gt;=y;--i)#define ll long long#define lowbit(x) x&amp;(-x)using namespace std;const int N=1e5+7;const double eps=1e-10;const int inf=0x3f3f3f3f;int T,R,r,n,ans[N];int main()&#123; scanf("%d",&amp;T); while(T--&amp;&amp;~scanf("%d%d%d",&amp;n,&amp;R,&amp;r))&#123; int res=max(2*r-R,R-2*r),mind=inf,tp,cnt=0; res*=res; rep(i,1,n)&#123; int x,y;scanf("%d%d",&amp;x,&amp;y); if(x*x+y*y&lt;=res)tp=0; else tp=x*x+y*y; if(tp&lt;mind)&#123; mind=tp; cnt=0; ans[++cnt]=i; &#125; else if(tp==mind)ans[++cnt]=i; &#125; printf("%d\n",cnt); rep(i,1,cnt)printf("%d%c",ans[i],i!=cnt?' ':'\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5412]]></title>
    <url>%2Fhdu5412%2F</url>
    <content type="text"><![CDATA[链接:hdu5412 题解 注意这题是单点修改，整体二分一下就可以AC，一发过。。。 把所有修改操作看成把这个点删了，再加上一个数。 每次二分一个mid，对于要修改的数小于（因为求得是第k大）这个值，直接加上然后放到左区间,否则放到右区间，对于查询操作，如果这个区间内大于mid的数x小于k那么显然答案应该比mid大，k-=x后放到右区间，否则放到左区间，注意这里的顺序是不能改变的QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(int i=x;i&lt;=y;++i)#define repd(i,x,y) for(int i=x;i&gt;=y;--i)#define lowbit(x) x&amp;(-x)#define ll long longusing namespace std;const int N=1e6+7;const int inf=0x3f3f3f3f;int n,m,ans[N],tr[N],a[N];struct node&#123; int x,y,k,cnt,num; inline void init(int _x,int _y,int _k,int _cnt,int _num)&#123;x=_x;y=_y;k=_k;cnt=_cnt;num=_num;&#125;&#125;q[N],b[N];inline void update(int x,int y)&#123;for(int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;inline int query(int x)&#123;ll res=0;for(int i=x;i;i-=lowbit(i))res+=tr[i];return res;&#125;void solve(int L,int R,int LL,int RR)&#123; if(LL==RR)&#123;rep(i,L,R)if(q[i].k)ans[q[i].num]=LL;return ;&#125; int mid=LL+RR&gt;&gt;1,l=L,r=R; rep(i,L,R)&#123; if(q[i].k)&#123; q[i].cnt=query(q[i].y)-query(q[i].x-1); if(q[i].cnt&lt;q[i].k)q[i].k-=q[i].cnt,b[r--]=q[i]; else b[l++]=q[i]; &#125; else &#123; if(q[i].y&lt;=mid)b[l++]=q[i],update(q[i].x,q[i].cnt); else b[r--]=q[i]; &#125; &#125; rep(i,L,R)if(!q[i].k&amp;&amp;q[i].y&lt;=mid)update(q[i].x,-q[i].cnt); rep(i,L,l-1)q[i]=b[i]; for(int i=l,j=R;i&lt;=R;--j,++i)q[i]=b[j]; if(l!=L)solve(L,l-1,LL,mid); if(r!=R)solve(r+1,R,mid+1,RR);&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; int len=0; rep(i,1,n)&#123;scanf("%d",&amp;a[i]);q[++len].init(i,a[i],0,1,0);&#125; scanf("%d",&amp;m); rep(i,1,m)&#123; int op;scanf("%d",&amp;op); if(op&amp;1)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); q[++len].init(x,a[x],0,-1,0); q[++len].init(x,y,0,1,0); a[x]=y; ans[i]=0; &#125; else &#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); q[++len].init(x,y,z,0,i); &#125; &#125; solve(1,len,1,inf); rep(i,1,m)if(ans[i])printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2104]]></title>
    <url>%2Fpoj2104%2F</url>
    <content type="text"><![CDATA[链接:poj2104 题解 emmmm 裸的主席树可A,新学了整体二分,想看主席树的可以在我博客搜一下这个题号,有写主席树做法 每次二分一个mid，如果当前区间内大于mid的数x小于k，那么显然答案应该比mid大，k-=x后放到右区间，否则放到左区间。我们可以发现二分mid是logS的，求当前区间内大于mid个数可以用树状数组简单维护,log(N)，注意树状数组清空的时候不能直接清零，要原样减回去，不然会T QAQ，Q次询问，所以是Q*log(S)*log(N)。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(int i=x;i&lt;=y;++i)#define repd(i,x,y) for(int i=x;i&gt;=y;--i)#define lowbit(x) x&amp;(-x)#define ll long longusing namespace std;const int N=1e5+7;const int inf=0x3f3f3f3f;int n,m,ans[N],tr[N];struct node&#123; int x,num;&#125;a[N];struct node2&#123; int l,r,k,cnt,num;&#125;q[N],b[N];inline int cmp(const node &amp;x,const node &amp;y)&#123;return x.x&lt;y.x;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123;scanf("%d",&amp;a[i].x);a[i].num=i;&#125; rep(i,1,m)&#123;scanf("%d%d%d",&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);q[i].num=i;&#125; sort(a+1,a+n+1,cmp);&#125;inline void add(int x,int y)&#123;for(int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;inline int query(int x)&#123;ll res=0;for(int i=x;i;i-=lowbit(i))res+=tr[i];return res;&#125;void cal(int L,int R,int LL,int mid)&#123; int l=1,r=n; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(a[mid].x&gt;=LL)r=mid; else l=mid+1; &#125; for(int i=l;i&lt;=n&amp;&amp;a[i].x&lt;=mid;++i)add(a[i].num,1); rep(i,L,R)q[i].cnt=query(q[i].r)-query(q[i].l-1); for(int i=l;i&lt;=n&amp;&amp;a[i].x&lt;=mid;++i)add(a[i].num,-1);&#125;void solve(int l,int r,int L,int R)&#123; if(L==R)&#123;rep(i,l,r)ans[q[i].num]=L;return ;&#125; int mid=L+R&gt;&gt;1,now1=l,now2=r; cal(l,r,L,mid); rep(i,l,r)if(q[i].cnt&gt;=q[i].k)b[now1++]=q[i];else q[i].k-=q[i].cnt,b[now2--]=q[i]; rep(i,l,r)q[i]=b[i]; if(now1!=l)solve(l,now1-1,L,mid); if(now2!=r)solve(now2+1,r,mid+1,R);&#125;int main()&#123; init(); solve(1,m,-inf,inf); rep(i,1,m)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3327]]></title>
    <url>%2Flg3327%2F</url>
    <content type="text"><![CDATA[链接:lg3327 题解 $ans=\sum_{i}^n{\sum_{j}^m{gcd(i,j)=p}}$ $ans=\sum_{d \in p}^{}{\sum_{i}^{\frac nd}{\sum_{j}^{\frac md}{\sum_{x|gcd(i,j)}^{}{\mu(x)}}}}$ $ans=\sum_{d \in p}^{}{\sum_{x}^{min(\frac nd,\frac md)}{\mu(x)[\frac n{dx}][\frac m{dx}]}}$ 换一个枚举项，枚举dx $ans=\sum_{T}^{min(n,m)}{\sum_{x|T}^{}{\mu(\frac Tx)[\frac nT][\frac mT]}}$ $ans=\sum_{T}^{min(n,m)}{[\frac nT][\frac mT]\sum_{x|T}^{}{\mu(\frac Tx)}}$ 显然这里就可以O($\sqrt n$)做了123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7+7;int n,m,p[N],cnt,vis[N],mu[N],g[N],T,l,r;ll ans,sum[N];void get_mu(int n)&#123; mu[1]=1; rep(i,2,n)&#123; if(!vis[i])mu[i]=-1,p[++cnt]=i; for(int j=1;j&lt;=cnt&amp;&amp;i&lt;=n/p[j];++j)&#123; vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]-=mu[i]; &#125; &#125; rep(j,1,cnt)for(int i=1;i&lt;=n/p[j];++i)g[i*p[j]]+=mu[i]; rep(i,1,n)sum[i]=sum[i-1]+(ll)g[i];&#125;int main()&#123; scanf("%d",&amp;T); get_mu(N-7); while(~scanf("%d%d",&amp;n,&amp;m))&#123; ans=0;l=1; int len=min(n,m); while(l&lt;=len)&#123; r=min(n/(n/l),m/(m/l)); ans+=(ll)(n/l)*(m/l)*(sum[r]-sum[l-1]); l=r+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3455]]></title>
    <url>%2Flg3455%2F</url>
    <content type="text"><![CDATA[链接:lg3455 题解 $ans=\sum_{i}^a{\sum_{j=1}^b{gcd(i,j)=d}}$ $ans=\sum_{i}^{\frac ad}{\sum_{j=1}^{\frac bd}{gcd(i,j)=1}}$ $ans=\sum_{i}^{\frac ad}{\sum_{j=1}^{\frac bd}{\sum_{x|gcd(i,j)}^{}{\mu(x)}}}$ $ans=\sum_{x}^{min(\frac ad,\frac bd)}{\mu(x) \cdot \sum_{i}^{\frac ad}{\sum_{j}^{\frac bd}{x|gcd(i,j)}}}$ 枚举ix jx $ans=\sum_(x)^{min(\frac ad,\frac bd)}{\mu(x) \cdot \sum_{i}^{\frac a{dx}}{\sum_{j}^{\frac b{dx}}}}$ $ans=\sum_(x)^{min(\frac ad,\frac bd)}{[\frac a{dx}]\cdot [\frac b{dx}]}$ 这样就可以O(n)做出来了,但是还是会T,这里用下除法分块就可以在O($\sqrt n$)做出来 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int mu[N],res[N],p[N],vis[N],cnt,a,b,d,T;ll ans;void get_mu(int n)&#123; mu[1]=1; rep(i,2,n)&#123; if(!vis[i])mu[i]=-1,p[++cnt]=i; for(int j=1;j&lt;=cnt&amp;&amp;i&lt;=n/p[j];++j)&#123; vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]-=mu[i]; &#125; &#125; rep(i,1,n)res[i]=res[i-1]+mu[i];&#125;int main()&#123; scanf("%d",&amp;T); get_mu(500500); while(T--&amp;&amp;~scanf("%d%d%d",&amp;a,&amp;b,&amp;d))&#123; int l=1,r,len=min(a,b);ans=0; while(l&lt;=len)&#123; r=min(a/(a/l),b/(b/l)); ans+=1ll*(a/l/d)*1ll*(b/l/d)*1ll*(res[r]-res[l-1]); l=r+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[莫比乌斯函数如下 \mu(d)= \begin{cases} 1 &\mbox{d=1}\\ (-1)^k &\mbox{$d=p_1p_2p_3...p_k,p_i$是互异素数}\\ 0 &\mbox{其余情况} \end{cases} 于是有如下两条性质\sum_{d|n}^{}{\mu(d)=[n=1]}\sum_{d|n}^{}{\frac {\mu(d)}{d}}={\frac {\phi(n)}{n}} 第一个性质用组合数可以很方便得到 莫比乌斯反演如下 如果有$f(n)=\sum_{d|n}^{}{g(d)}$ 那么$g(n)=\sum_{d|n}^{}{\mu(d)\cdot f(\frac nd)}$ $\sum_{d|n}^{}{\mu(d)\cdot f(\frac nd)}=\sum_{d|n}^{}{\mu(d)\cdot \sum_{k| \frac nd}^{}g(k)}$ $=\sum_{d|n}^{}{\sum_{k| \frac nd}^{}{\mu(d) \cdot g(k)}}$ 显然其实就是枚举$d\cdot k|n$ 即$=\sum_{k|n}^{}{\sum_{d| \frac nk}^{}{\mu(d) \cdot g(k)}}$ 由性质1可得该式$=g(n)$ (其实我每次都没构造函数,我直接推的2333…) 上一段线筛莫比乌斯函数代码1234567891011void get_mu(int n)&#123; mu[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])mu[i]=-1,p[++cnt]=i; for(int j=1;j&lt;=cnt&amp;&amp;i&lt;=n/p[j];++j)&#123; vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]-=mu[i]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1007]]></title>
    <url>%2Fhdu1007%2F</url>
    <content type="text"><![CDATA[链接:hdu1007 题解 平面最近点对问题 采用分治,复杂度为O(Knlognlogn) 先考虑一维的情况(虽然可以O(n)扫一遍) 将序列按升序排列,然后划分为两个区间,假设左边最近点对距离为d1 ,右边最近点对距离为d2 d=min(d1,d2)显然不是整个区间的最近点对距离 假设d1,d2已求出的情况下,只需要求出横跨两个区间的最近点对距离d3就好了 显然只有满足dis(p,mid)&lt;d以及dis(q,mid)&lt;d的点才可能会对答案有贡献(p在左区间,q在右区间),求出这部分再按照y轴排序之后在满足y[j]-y[i]&lt;d的点内求就好 具体看代码就好 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const double dnf=0x3f3f3f3f;const int N=1e5+7;double x[N],y[N];int tmp[N],id[N],cnt,n;inline double dis(int a,int b)&#123;return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));&#125;inline int cmpx(int a,int b)&#123;return x[a]==x[b]?y[a]&lt;y[b]:x[a]&lt;x[b];&#125;inline int cmpy(int a,int b)&#123;return y[a]&lt;y[b];&#125;double solve(int l,int r)&#123; if(l==r)return dnf; if(r==l+1)return dis(id[l],id[r]); int mid=l+r&gt;&gt;1; double d1=solve(l,mid); double d2=solve(mid+1,r); double d=min(d1,d2);cnt=0; rep(i,l,r)if(dis(id[i],id[mid])&lt;=d)tmp[++cnt]=id[i]; sort(tmp+1,tmp+cnt+1,cmpy); rep(i,1,cnt)for(int j=i+1;j&lt;=cnt&amp;&amp;y[tmp[j]]-y[tmp[i]]&lt;d;j++)&#123;double tp=dis(tmp[i],tmp[j]);d=min(tp,d);&#125; return d;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; rep(i,1,n)&#123;scanf("%lf%lf",&amp;x[i],&amp;y[i]);id[i]=i;&#125; sort(id+1,id+n+1,cmpx); printf("%.2lf\n",solve(1,n)/2); &#125; return 0;&#125; 看到某个大佬用奇怪的方式O(n^2)暴力过了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const double dnf=0x3f3f3f3f;const int N=1e5+7;struct node&#123; double x,y; inline void init()&#123;scanf("%lf%lf",&amp;x,&amp;y);&#125;&#125;a[N],b[N];int n;inline int cmpx(const node &amp;x,const node &amp;y)&#123;return x.x&lt;y.x;&#125;inline int cmpy(const node &amp;x,const node &amp;y)&#123;return x.y&lt;y.y;&#125;inline double dis(node &amp;x,node &amp;y)&#123;return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; double d=dnf; int tot1=0,tot2=100; rep(i,1,n)a[i].init(); rep(i,1,n)b[i]=a[i]; sort(a+1,a+n+1,cmpx); sort(b+1,b+n+1,cmpy); for(int i1=2,i2=2,j1=1,j2=1;i1&lt;=n&amp;&amp;i2&lt;=n;)&#123; repd(k,j1,1)&#123; d=min(d,dis(a[i1],a[k])); if(a[i1].x-a[k].x&gt;=d||k==1)&#123;j1=i1++;break;&#125; if(tot1&gt;=tot2)&#123;tot1+=20;j1=k-1;break;&#125; tot1++; &#125; repd(k,j2,1)&#123; d=min(d,dis(b[i2],b[k])); if(b[i2].y-b[k].y&gt;=d||k==1)&#123;j2=i2++;break;&#125; if(tot2&gt;=tot1)&#123;tot2+=20;j2=k-1;break;&#125; tot2++; &#125; &#125; printf("%.2lf\n",d/2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯[发现环]]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%8F%91%E7%8E%B0%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯[发现环] 题解 注意起点不一定在环上…太菜了…一头栽进坑 因为根不一定是1 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=3e5+7;int to[N],nxt[N],head[N],in[N],ans[N],len,cnt,n,cl;inline void adde(int a,int b)&#123;to[++cnt]=b;nxt[cnt]=head[a];head[a]=cnt;&#125;int dfs(int u,int f)&#123; in[u]=1; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])!=f)&#123; if(in[v])&#123;cl=v;return 1;&#125; if(dfs(v,u))return 1; &#125; return in[u]=0;&#125;inline void ce(int x)&#123;in[x]=0;for(int i=head[x],v;i;i=nxt[i])&#123;if(v==cl)return ;if(in[v])ce(v);&#125;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123;int a,b;scanf("%d%d",&amp;a,&amp;b);adde(a,b);adde(b,a);&#125; dfs(1,0); if(cl!=1)ce(1); rep(i,1,n)if(in[i])printf("%d ",i); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3205]]></title>
    <url>%2Flg3205%2F</url>
    <content type="text"><![CDATA[链接:lg3205 题解 DP[i][j][0/1]表示区间i~j,最后一个人站在左边或者右边可以推出的原始队形的种数 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+7;const int p=19650827;int dp[N][N][2],nm[N],n;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)dp[i][i][0]=1; rep(i,1,n)scanf("%d",&amp;nm[i]); rep(l,2,n)rep(i,1,n-l+1)&#123; int j=i+l-1; if(nm[j]&gt;nm[j-1])dp[i][j][1]+=dp[i][j-1][1]; if(nm[j]&gt;nm[i])dp[i][j][1]+=dp[i][j-1][0]; if(nm[i]&lt;nm[i+1])dp[i][j][0]+=dp[i+1][j][0]; if(nm[i]&lt;nm[j])dp[i][j][0]+=dp[i+1][j][1]; dp[i][j][0]%=p;dp[i][j][1]%=p; &#125; printf("%d\n",(dp[1][n][0]+dp[1][n][1])%p); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2476]]></title>
    <url>%2Fhdu2476%2F</url>
    <content type="text"><![CDATA[链接:hdu2476 题解 DP[i][j]表示把a串i~j变为b串的最小变化次数,但是如果a,b中某一对应位相同,可以考虑不变 可以先考虑没有相同的情况然后再处理有相同的情况.ans[j]表示1~j串a变为b的最小变化次数 显然如果a[j]==b[j]ans[j]=min(ans[j],ans[j-1]) 否则ans[j]=min(ans[j],ans[i]+dp[i+1][j]) 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=107;const int inf=0x3f3f3f3f;char str[N],ptr[N];int dp[N][N],ans[N],n;int main()&#123; while(~scanf("%s%s",str+1,ptr+1))&#123; memset(dp,0,sizeof(dp)); n=strlen(str+1); rep(i,1,n)dp[i][i]=1; rep(l,2,n)rep(i,1,n-l+1)&#123; int j=i+l-1; dp[i][j]=dp[i+1][j]+1; rep(k,i+1,j)if(ptr[i]==ptr[k])dp[i][j]=min(dp[i][j],dp[i+1][k]+dp[k+1][j]); &#125; rep(j,1,n)&#123; ans[j]=dp[1][j]; if(str[j]==ptr[j])ans[j]=min(ans[j],ans[j-1]); else rep(i,1,j-1)ans[j]=min(ans[j],ans[i]+dp[i+1][j]); &#125; printf("%d\n",ans[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4283]]></title>
    <url>%2Fhdu4283%2F</url>
    <content type="text"><![CDATA[链接:hdu4283 题解 菜鸡的我一开始甚至在想是不是模拟搜索/px DP[i][j]表示区间i~j取得的最小答案,那么枚举区间i~j内第i个人上台的次序就可以划分为dp[i+1][k],dp[k+1][j]两个问题 显然i点的ds值是c[i](k-i) 而i+1~j的ds值为(sum[j]-sum[i])(k-i+1)123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=107;const int inf=0x3f3f3f3f;int dp[N][N],c[N],sum[N],n,T;int main()&#123; scanf("%d",&amp;T); rep(cnt,1,T)&#123; scanf("%d",&amp;n); rep(i,1,n)&#123;scanf("%d",&amp;c[i]);sum[i]=sum[i-1]+c[i];&#125; rep(l,2,n)rep(i,1,n-l+1)&#123; int j=i+l-1; dp[i][j]=inf; rep(k,i,j)dp[i][j]=min(dp[i][j],dp[i+1][k]+dp[k+1][j]+c[i]*(k-i)+(k-i+1)*(sum[j]-sum[k])); &#125; printf("Case #%d: %d\n",cnt,dp[1][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj3469]]></title>
    <url>%2Fzoj3469%2F</url>
    <content type="text"><![CDATA[链接:zoj3469 题解 dp[i][j]表示区间i~j已经分配完之后的最小花费状态转移如下 dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][0]+(sum[i]+sum[n]-sum[j])*(nm[i+1].x-nm[i].x)); dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][1]+(sum[i]+sum[n]-sum[j])*(nm[j].x-nm[i].x)); dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][0]+(sum[i-1]+sum[n]-sum[j-1])*(nm[j].x-nm[i].x)); dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][1]+(sum[i-1]+sum[n]-sum[j-1])*(nm[j].x-nm[j-1].x));1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+7;const ll inf=0x3f3f3f3f;struct node&#123; int x,c; inline void init(int a,int b)&#123;x=a;c=b;&#125;&#125;nm[N];ll dp[N][N][2],sum[N];inline int cmp(node a,node b)&#123;return a.x&lt;b.x;&#125;int n,X,v;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;v,&amp;X))&#123; memset(dp,inf,sizeof(dp)); rep(i,1,n)scanf("%d%d",&amp;nm[i].x,&amp;nm[i].c); nm[n+1].init(X,0);n++; sort(nm+1,nm+n+1,cmp); rep(i,1,n)&#123;sum[i]=sum[i-1]+nm[i].c;if(nm[i].x==X&amp;&amp;nm[i].c==0)dp[i][i][0]=dp[i][i][1]=0;&#125; rep(l,2,n)rep(i,1,n-l+1)&#123; int j=i+l-1; dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][0]+(sum[i]+sum[n]-sum[j])*(nm[i+1].x-nm[i].x)); dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][1]+(sum[i]+sum[n]-sum[j])*(nm[j].x-nm[i].x)); dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][0]+(sum[i-1]+sum[n]-sum[j-1])*(nm[j].x-nm[i].x)); dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][1]+(sum[i-1]+sum[n]-sum[j-1])*(nm[j].x-nm[j-1].x)); &#125; //rep(i,1,n)rep(j,1,n)cout&lt;&lt;dp[i][j][0]&lt;&lt;' '&lt;&lt;dp[i][j][1]&lt;&lt;endl; printf("%lld\n",min(dp[1][n][0],dp[1][n][1])*v); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1651]]></title>
    <url>%2Fpoj1651%2F</url>
    <content type="text"><![CDATA[链接:poj1651 题解 区间i~j可以划分为i~k k+1~j 答案加上nm[k]*nm[i-1]*nm[j]就好12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=107;const ll inf=0x3f3f3f3f3f3f3f;ll dp[N][N],nm[N];int n;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)scanf("%d",&amp;nm[i]); rep(l,2,n-1)rep(i,2,n-l+2)&#123; int j=i+l-1; dp[i][j]=inf; rep(k,i,j-1)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+nm[k]*nm[i-1]*nm[j]); &#125; printf("%lld\n",dp[2][n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces149D]]></title>
    <url>%2Fcodeforces149D%2F</url>
    <content type="text"><![CDATA[链接:codeforces149D 题解 区间l~r可以划分为l~mach[l] mach[l]+1~r,dfs一下分类处理就好12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regitser int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int p=1e9+7;const int N=800;ll dp[N][N][3][3],ans;int mach[N],tmp[N],n,cnt;char str[N+1];inline void init()&#123; scanf("%s",str+1);n=strlen(str+1); rep(i,1,n)if(str[i]=='(')tmp[++cnt]=i;else if(str[i]==')')mach[tmp[cnt--]]=i;&#125;ll dfs(int l,int r)&#123; if(r==l+1)return dp[l][r][0][1]=dp[l][r][0][2]=dp[l][r][1][0]=dp[l][r][2][0]=1; if(mach[l]==r)&#123; dfs(l+1,r-1); rep(i,0,2)rep(j,0,2)&#123; if(j!=1)dp[l][r][0][1]=(dp[l][r][0][1]+dp[l+1][r-1][i][j])%p; if(j!=2)dp[l][r][0][2]=(dp[l][r][0][2]+dp[l+1][r-1][i][j])%p; if(i!=1)dp[l][r][1][0]=(dp[l][r][1][0]+dp[l+1][r-1][i][j])%p; if(i!=2)dp[l][r][2][0]=(dp[l][r][2][0]+dp[l+1][r-1][i][j])%p; &#125; &#125; else &#123; dfs(l,mach[l]); dfs(mach[l]+1,r); rep(i,0,2)rep(j,0,2)rep(x,0,2)rep(y,0,2)&#123; if(x&amp;&amp;x==y)continue; dp[l][r][i][j]=(dp[l][r][i][j]+dp[l][mach[l]][i][x]*dp[mach[l]+1][r][y][j]%p)%p; &#125; &#125;&#125;int main()&#123; init(); dfs(1,n); rep(i,0,2)rep(j,0,2)ans=(ans+dp[1][n][i][j])%p; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2955]]></title>
    <url>%2Fpoj2955%2F</url>
    <content type="text"><![CDATA[链接:poj2955 题解 DP[i][j]表示区间i~j的最大括号匹配数量,显然str[i]与str[j]如果匹配DP[i][j]=DP[i+1][j-1]+2 并且对于区间i~j-1内的k必然有DP[i][j]=max(DP[i][j],DP[i][k]+DP[k+1][j]) 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=107;int dp[N][N],n;char str[N];int main()&#123; while(~scanf("%s",str+1))&#123; if(strcmp(str+1,"end")==0)break; memset(dp,0,sizeof(dp)); n=strlen(str+1); rep(l,2,n)rep(i,1,n-l+1)&#123; int j=i+l-1; if((str[i]=='('&amp;&amp;str[j]==')')||(str[i]=='['&amp;&amp;str[j]==']'))dp[i][j]=dp[i+1][j-1]+2; rep(k,i,j-1)dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]); &#125; printf("%d\n",dp[1][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lightoj1422]]></title>
    <url>%2Flightoj1422%2F</url>
    <content type="text"><![CDATA[链接:lightoj1422 题解 DP[i][j]表示区间i~j所需的最少服装 1: 如果i这件衣服后面无法重复使用DP[i][j]=DP[i+1][j]+1 2: 如果i+1~j内有一个k与i一样,可以考虑在k这个位置重复利用i这件衣服即DP[i][j]=min(DP[i][j],DP[i][k-1]+DP[k+1][j])123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=107;int dp[N][N],c[N],n,T;int main()&#123; scanf("%d",&amp;T); rep(cnt,1,T)&#123; scanf("%d",&amp;n); rep(i,1,n)scanf("%d",&amp;c[i]); rep(i,1,n)dp[i][i]=1; rep(l,2,n)rep(i,1,n-l+1)&#123; int j=i+l-1; dp[i][j]=dp[i+1][j]+1; rep(k,i+1,j)if(c[k]==c[i])dp[i][j]=min(dp[i][j],dp[i][k-1]+dp[k+1][j]); &#125; printf("Case %d: %d\n",cnt,dp[1][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3147]]></title>
    <url>%2Flg3147%2F</url>
    <content type="text"><![CDATA[链接:lg3147 题解 dp[i][j] 表示第i个位置合成到j所需的长度 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define rint register int#define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define lowbit(x) (x&amp;(-x))#define ll long longusing namespace std;const int N=1e6;int dp[N][70],a[N],n,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int main()&#123; read(n); rep(i,1,n)read(a[i]); rep(i,1,n)&#123; dp[i][a[i]]=1; int j=i-1; while(dp[j][a[i]])&#123; j-=dp[j][a[i]]; a[i]++;dp[i][a[i]]=i-j; &#125; ans=max(ans,a[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3146[简单区间DP]]]></title>
    <url>%2Flg3146-%E7%AE%80%E5%8D%95%E5%8C%BA%E9%97%B4DP%2F</url>
    <content type="text"><![CDATA[链接:lg3146[简单区间DP] 题解 简单区间DP,dp[i][j]表示i-j所取得的最大的值 dp[i][j]=max(dp[i][j],dp[i][k]+1) 当dp[i][k]==dp[k+1][j]的时候才可以转移 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define rint register int#define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define lowbit(x) (x&amp;(-x))#define ll long longusing namespace std;const int N=1e3;int dp[N][N],n,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar();if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int main()&#123; read(n); rep(i,1,n)&#123;read(dp[i][i]),ans=max(ans,dp[i][i]);&#125; repd(i,n-1,1)rep(j,i+1,n)&#123; rep(k,i,j-1)if(dp[i][k]==dp[k+1][j])dp[i][j]=max(dp[i][j],dp[i][k]+1); ans=max(ans,dp[i][j]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj3537[最优三角剖分]]]></title>
    <url>%2Fzoj3537-%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[链接:zoj3537[最优三角剖分] 题解 先判个凸多边形,然后最优三角剖分,DP[i][j]=min(DP[i][j,DP[i][k]+DP[k][j]+cst[i][k]+cst[k][j])12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rint register int#define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=407;const ll inf=0x3f3f3f3f;int n,p,cnt;ll dp[N][N],x[N],y[N],res[N],id[N],cst[N][N];template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline ll cul(int a,int b,int c)&#123;return abs(x[a]+x[b])*abs(y[a]+y[b])%p+abs(x[c]+x[b])*abs(y[c]+y[b])%p;&#125;inline int cmp(int a,int b)&#123;return y[a]==y[b]?x[a]&lt;x[b]:y[a]&lt;y[b];&#125;inline int crp(int x1,int y1,int x2,int y2)&#123;return x1*y2-x2*y1;&#125;inline int init()&#123; cnt=0; rep(i,1,n)read(x[i]),read(y[i]),id[i]=i;sort(id+1,id+n+1,cmp); rep(i,1,n)&#123; while(cnt&gt;1&amp;&amp;crp(x[res[cnt]]-x[res[cnt-1]],y[res[cnt]]-y[res[cnt-1]],x[id[i]]-x[res[cnt-1]],y[id[i]]-y[res[cnt-1]])&lt;=0)--cnt; res[++cnt]=id[i]; &#125; int tmp=cnt; repd(i,n-1,1)&#123; while(cnt&gt;tmp&amp;&amp;crp(x[res[cnt]]-x[res[cnt-1]],y[res[cnt]]-y[res[cnt-1]],x[id[i]]-x[res[cnt-1]],y[id[i]]-y[res[cnt-1]])&lt;=0)--cnt; res[++cnt]=id[i]; &#125; return cnt==n+1;&#125;inline void solve()&#123; memset(dp,0x3f,sizeof(dp)); memset(cst,0,sizeof(cst)); rep(i,1,n-1)dp[i][i+1]=0; rep(i,1,n)rep(j,i+2,n) cst[i][j]=cst[j][i]=abs(x[res[i]]+x[res[j]])*abs(y[res[i]]+y[res[j]])%p; repd(i,n-2,1)rep(j,i+2,n)rep(k,i+1,j-1)dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+cst[i][k]+cst[k][j]);&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;p))&#123; if(!init())&#123;puts("I can't cut.");continue;&#125; solve(); printf("%d\n",dp[1][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swust2793[奇怪的01]]]></title>
    <url>%2Fswust2793-%E5%A5%87%E6%80%AA%E7%9A%8401%2F</url>
    <content type="text"><![CDATA[链接:swust2793[奇怪的01] 题解 花费为负数倒着01,然后偏移一下就好 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rint register int #define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int M=2e5;const int N=1e6+7;const int inf=0x3f3f3f3f;int dp[N],n,V,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; rep(i,0,M)dp[i]=-inf; dp[100000]=0; rep(i,1,n)&#123; int c,v; read(v);read(c); if(v&gt;0)repd(j,M,v)dp[j]=max(dp[j],dp[j-v]+c); else rep(j,0,M+v-1)dp[j]=max(dp[j],dp[j-v]+c); &#125; rep(i,100000,M)if(dp[i]&gt;0)ans=max(ans,i+dp[i]-100000); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2108[判凸多边形]]]></title>
    <url>%2Fhdu2108-%E5%88%A4%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[链接:hdu2108[判凸多边形] 题解 其实这道题只需要O(N)扫一遍就ok,只是为了写个Graham的板子1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#define rint register int#define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;typedef pair&lt;int,int&gt; s;int x[N],y[N],id[N],n,vis[N],res[N],cnt;template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline int cmp(int a,int b)&#123;return y[a]==y[b]?x[a]&lt;x[b]:y[a]&lt;y[b];&#125;inline int det(int x1,int x2,int y1,int y2)&#123;return x1*y2-y1*x2;&#125;inline int crp(s a,s b,s c)&#123;return det(b.first-a.first,c.first-a.first,b.second-a.second,c.second-a.second);&#125;inline void init()&#123;rep(i,1,n)read(x[i]),read(y[i]),id[i]=i;sort(id+1,id+n+1,cmp);&#125;inline int solve()&#123; rep(i,1,n)&#123; while(cnt&gt;1&amp;&amp;crp(s(x[res[cnt-1]],y[res[cnt-1]]),s(x[res[cnt]],y[res[cnt]]),s(x[id[i]],y[id[i]]))&lt;=0)cnt--; res[++cnt]=id[i]; &#125; int tmp=cnt; repd(i,n-1,1)&#123; while(cnt&gt;tmp&amp;&amp;crp(s(x[res[cnt-1]],y[res[cnt-1]]),s(x[res[cnt]],y[res[cnt]]),s(x[id[i]],y[id[i]]))&lt;=0)cnt--; res[++cnt]=id[i]; &#125; return cnt==n+1;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; cnt=0;init(); puts(solve()?"convex":"concave"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>计算几何</category>
        <category>Graham</category>
      </categories>
      <tags>
        <tag>Graham</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6140[思维]]]></title>
    <url>%2Fhdu6140-%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[链接:hdu6140[思维] 题解 ZZ的我一开始没看数据范围,直接上dp,结果显然T了 a_i \le \sum_{j = 1}^{i - 1}a_j[b_j = N] + \sum_{j = 1}^{i - 1}a_j[b_i = L \cap b_j = L] + \sum_{j = 1}^{i - 1} a_j[b_i = D \cap b_j = D] (2 \le i \le n). 根据题上的这个公式,就可以发现这就是个巨水的题12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rint register int#define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int ans1,ans2,n,m,T,nm[N];char c;template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void init()&#123; ans1=ans2=0; read(n);read(m); rep(i,1,n)read(nm[i]); rep(i,1,n)&#123; while(isspace(c=getchar())); if(c=='L')ans1+=nm[i]; else if(c=='D')ans2-=nm[i]; else ans1+=nm[i],ans2-=nm[i]; &#125;&#125;inline int solve()&#123;return m&gt;=ans2&amp;&amp;m&lt;=ans1;&#125;int main()&#123; read(T); while(T--)&#123; init(); puts(solve()?"yes":"no"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6143[思维,排列组合]]]></title>
    <url>%2Fhdu6143-%E6%80%9D%E7%BB%B4-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[链接:hdu6143[思维,排列组合] 题解 一开始想的方程是\sum_{i=1}^{m}{C_m^i*!i*(m-i)^n} 之后发现会有重复 dp[i]表示m种字母中选i个出来放在姓上的情况(全部用完) 显然dp[i]=i^n-\sum_{j=1}^{i-1}{C_i^j*dp[j]} 最后答案就是\sum_{i=1}^{m}{C_m^i*dp[i]*(m-i)^n} 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rint register int#define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const ll p=1e9+7;const int N=2000+7;ll a[N],b[N][N],c[N],dp[N],n,m,T;inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;x=1;y=0;return ;&#125; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*y;&#125;inline ll inv(ll d)&#123;ll x,y;exgcd(d,p,x,y);return x&gt;0?x:x+p;&#125;inline void init()&#123; a[0]=1; rep(i,1,N-7)a[i]=i*a[i-1]%p,c[i]=inv(a[i]); rep(i,1,N-7)b[i][1]=i; rep(i,1,N-7)rep(j,2,N-7)b[i][j]=b[i][j-1]*i%p;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; init(); while(T--)&#123; ll ans=0; cin&gt;&gt;n&gt;&gt;m; rep(i,1,m)&#123;dp[i]=b[i][n];rep(j,1,i-1)dp[i]=(dp[i]-a[i]*c[i-j]%p*c[j]%p*dp[j]%p+p)%p;&#125; rep(i,1,m)ans=(ans+a[m]*c[m-i]%p*c[i]%p*dp[i]%p*b[m-i][n])%p; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
        <category>排列组合</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>排列组合</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6138]]></title>
    <url>%2Fhdu6138%2F</url>
    <content type="text"><![CDATA[链接:hdu6138 题解 多记录一个深度,用第一个串进行匹配,沿途做标记,第二个串匹配的时候更新答案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rint register int #define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;int tr[N][26],id[N],fail[N],deep[N],flag[N],ans,T,n,x,y,cnt,m;string a[N];inline void build(string &amp;str,int len)&#123; int now=0; rep(i,1,len)&#123; int k=str[i-1]-'a'; if(!tr[now][k])tr[now][k]=++cnt; deep[tr[now][k]]=deep[now]+1; now=tr[now][k]; &#125;&#125;inline void pre()&#123; queue&lt;int&gt; q; q.push(0); fail[0]=-1; while(!q.empty())&#123; int k=q.front();q.pop(); rep(i,0,25)if(tr[k][i])&#123; int son=tr[k][i],p=fail[k]; while(p&gt;=0&amp;&amp;!tr[p][i])p=fail[p]; fail[son]=p&gt;=0?tr[p][i]:0; q.push(son); &#125; &#125;&#125;inline void update(string &amp;str,int len,int op)&#123; int now=0; rep(i,1,len)&#123; int k=str[i-1]-'a',p=now; while(p&gt;=0&amp;&amp;!tr[p][k])p=fail[p]; now=p&gt;=0?tr[p][k]:0; int tmp=now; if(op)while(tmp)&#123;flag[tmp]=1;tmp=fail[tmp];&#125; else while(tmp)&#123; if(flag[tmp])ans=max(ans,deep[tmp]);tmp=fail[tmp];&#125; if(!op&amp;&amp;flag[now])ans=max(ans,deep[now]); if(op)flag[now]=1; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; memset(tr,0,sizeof(tr)); memset(fail,0,sizeof(fail)); memset(deep,0,sizeof(deep)); cin&gt;&gt;n;cnt=0; rep(i,1,n)&#123;cin&gt;&gt;a[i]; build(a[i],a[i].size());&#125; pre(); cin&gt;&gt;m; while(m--)&#123; memset(flag,0,sizeof(flag)); ans=0; cin&gt;&gt;x&gt;&gt;y; update(a[x],a[x].size(),1); update(a[y],a[y].size(),0); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2222]]></title>
    <url>%2Fhdu2222%2F</url>
    <content type="text"><![CDATA[链接:hdu2222 题解 ac自动机模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rint register int #define rep(i,x,y) for(rint i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int tr[N][26],End[N],fail[N],cnt,ans,T,n;char a[N];inline void build(char *str,int len)&#123; int now=0; rep(i,1,len)&#123; int k=str[i]-'a'; if(!tr[now][k])tr[now][k]=++cnt; now=tr[now][k]; &#125; End[now]++;&#125;inline void pre()&#123; queue&lt;int&gt; q; q.push(0); fail[0]=-1; while(!q.empty())&#123; int k=q.front();q.pop(); rep(i,0,25)if(tr[k][i])&#123; int son=tr[k][i],p=fail[k]; while(p&gt;=0&amp;&amp;!tr[p][i])p=fail[p]; fail[son]=p&gt;=0?tr[p][i]:0; q.push(son); &#125; &#125;&#125;inline void query(char *str,int len)&#123; int now=0; rep(i,1,len)&#123; int p=now,k=str[i]-'a'; while(p&gt;=0&amp;&amp;!tr[p][k])p=fail[p]; now=p&gt;=0?tr[p][k]:0; int tmp=now; while(tmp)&#123;if(End[tmp]&gt;=0)ans+=End[tmp],End[tmp]=-1;else break;tmp=fail[tmp];&#125; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; memset(tr,0,sizeof(tr)); memset(fail,0,sizeof(fail)); memset(End,0,sizeof(End)); scanf("%d",&amp;n);ans=cnt=0; rep(i,1,n)&#123;scanf("%s",a+1); build(a,strlen(a+1));&#125; pre(); scanf("%s",a+1); query(a,strlen(a+1)); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3157[动态逆序对]]]></title>
    <url>%2Flg3157-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[链接:lg3157[动态逆序对] 题解 蒟蒻不会cdq分治…写的树状数套权值线段树,据说线段树套平衡树也可以卡过虽然听说很多巨佬被卡树上下不来… 如果数x被删掉了,那么他对答案的影响是在x前面比他大的数+在x后面比他小的数 具体来讲预处理出原数组的这两个关系,每次删掉一个数减掉相应的值就好,但是删掉的数之间会构成逆序对,这样就会导致多减了 .于是再求一次这次删掉的数x和之前删掉的数组成的逆序对就好了 参考了巨佬hzwer的写法 查询两次,每次直接二分权值. 例如往前查询的时候,如果x&lt;=mid 那么tmp加上右区间的数 往后也是一样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rint register #define rep(i,x,y) for(rint int i=x;i&lt;=y;++i)#define repd(i,x,y) for(rint int i=x;i&gt;=y;--i)#define lowbit(x) x&amp;(-x)#define ll long longusing namespace std;const int N=5e4+7;const int M=N*400;ll tr[M],a1[N&lt;&lt;1],a2[N&lt;&lt;1],ans;int ls[M],rs[M],root[N&lt;&lt;1],nm[N&lt;&lt;1],t[N&lt;&lt;1],pos[N&lt;&lt;1];int L[30],R[30],llen,rlen,n,m,cnt;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;x=0;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void add(int &amp;x)&#123;for(rint int i=x;i&lt;=n;i+=lowbit(i))t[i]++;&#125;inline int query(int &amp;x)&#123;int ans=0;for(rint int i=x;i;i-=lowbit(i))ans+=t[i];return ans;&#125;inline void update(int &amp;o,int l,int r,int x)&#123; if(!o)o=++cnt;tr[o]++; if(l==r)return ; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(ls[o],l,mid,x); else update(rs[o],mid+1,r,x);&#125;inline ll queryl(int a,int b,int k)&#123; int l=1,r=n;ll tmp=0;a--;llen=rlen=0; for(rint int i=a;i;i-=lowbit(i))L[++llen]=root[i]; for(rint int i=b;i;i-=lowbit(i))R[++rlen]=root[i]; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(k&lt;=mid)&#123; rep(i,1,llen)tmp-=tr[rs[L[i]]],L[i]=ls[L[i]]; rep(i,1,rlen)tmp+=tr[rs[R[i]]],R[i]=ls[R[i]]; r=mid; &#125; else &#123;rep(i,1,llen)L[i]=rs[L[i]];rep(i,1,rlen)R[i]=rs[R[i]];l=mid+1;&#125; &#125; return tmp;&#125;inline ll queryr(int a,int b,int k)&#123; int l=1,r=n;ll tmp=0;a--;llen=rlen=0; for(rint int i=a;i;i-=lowbit(i))L[++llen]=root[i]; for(rint int i=b;i;i-=lowbit(i))R[++rlen]=root[i]; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(k&gt;mid)&#123; rep(i,1,llen)tmp-=tr[ls[L[i]]],L[i]=rs[L[i]]; rep(i,1,rlen)tmp+=tr[ls[R[i]]],R[i]=rs[R[i]]; l=mid+1; &#125; else &#123;rep(i,1,llen)L[i]=ls[L[i]];rep(i,1,rlen)R[i]=ls[R[i]];r=mid;&#125; &#125; return tmp;&#125;inline void init()&#123; read(n);read(m); rep(i,1,n)&#123; read(nm[i]);pos[nm[i]]=i;add(nm[i]); a1[i]=i-query(nm[i]); ans+=a1[i]; &#125; memset(t,0,sizeof(t)); repd(i,n,1)&#123;add(nm[i]);a2[i]=query(nm[i])-1;&#125;&#125;inline void solve()&#123; while(m--)&#123; int x;read(x);x=pos[x]; printf("%lld\n",ans); ans-=a1[x]+a2[x]-queryl(1,x-1,nm[x])-queryr(x+1,n,nm[x]); for(rint int i=x;i&lt;=n;i+=lowbit(i))update(root[i],1,n,nm[x]); &#125;&#125;int main()&#123; init(); solve(); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[lg3332]]></title>
    <url>%2Flg3332%2F</url>
    <content type="text"><![CDATA[链接:lg3332 题解 线段树套线段树,动态开点,标记下传不方便,而且会T(我会说我T了一次吗…),更快的方法是CDQ分治或者整体二分… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e4+7;const int M=N*400;ll tr[M],lz[M],C[N],n,m,cnt,rk[N];int ls[M],rs[M],root[N&lt;&lt;2],A[N],B[N],op[N],len,ct;template &lt;typename T&gt;inline void read(T &amp;x)&#123; x=0;char c;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void update(int &amp;o,int l,int r,int L,int R)&#123; if(!o)o=++cnt; tr[o]+=min(r,R)-max(l,L)+1; if(L&lt;=l&amp;&amp;R&gt;=r)&#123;lz[o]++;return ;&#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(ls[o],l,mid,L,R); if(R&gt;mid)update(rs[o],mid+1,r,L,R);&#125;inline void UPDATE(int a,int b,int c)&#123; int l=1,r=len,k=1; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; update(root[k],1,n,a,b); if(c&lt;=mid)k&lt;&lt;=1,r=mid; else k=k&lt;&lt;1|1,l=mid+1; &#125; update(root[k],1,n,a,b);&#125;inline ll query(int o,int l,int r,int L,int R)&#123; if(!o)return 0; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; int mid=l+r&gt;&gt;1;ll ans=lz[o]*(min(r,R)-max(L,l)+1); if(L&lt;=mid)ans+=query(ls[o],l,mid,L,R); if(R&gt;mid)ans+=query(rs[o],mid+1,r,L,R); return ans;&#125;inline int QUERY(int a,int b,int c)&#123; int l=1,r=len,k=1; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1;ll t=query(root[k&lt;&lt;1],1,n,a,b); if(c&lt;=t)r=mid,k&lt;&lt;=1; else l=mid+1,k=k&lt;&lt;1|1,c-=t; &#125; return l;&#125;int main()&#123; read(n);read(m); rep(i,1,m)&#123;read(op[i]);read(A[i]);read(B[i]);read(C[i]);if(op[i]==1)rk[++ct]=C[i];&#125; sort(rk+1,rk+ct+1); len=unique(rk+1,rk+ct+1)-rk-1; rep(i,1,m)if(op[i]==1)C[i]=lower_bound(rk+1,rk+len+1,C[i])-rk; rep(i,1,m)&#123; if(op[i]==1)&#123;UPDATE(A[i],B[i],len-C[i]+1);&#125; else printf("%d\n",rk[len-QUERY(A[i],B[i],C[i])+1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树套树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2617[动态区间第k小]]]></title>
    <url>%2Flg2617-%E5%8A%A8%E6%80%81%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[链接:lg2617[动态区间第k小] 题解 动态区间第k小,我的做法是树状数组套线段树,空间开小了,RE无数次,看了大佬们的题解,建点方式不太一样大佬们的建点方式空间效率常数比我小。。。 数太大了,所以离散化,但是修改的值可能并没有出现过所以必须离线做…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define lowbit(x) x&amp;(-x)#define ll long longusing namespace std;const int N=1e4+7;int tr[N*800],lson[N*800],rson[N*800],root[N],L[30],R[30];int a[N],b[N&lt;&lt;2],s[N][3],llen,rlen,len,cnt,n,m;inline void update(int &amp;o,int l,int r,int x,int v)&#123; if(!o)o=++cnt; tr[o]+=v; if(l==r)return ; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(lson[o],l,mid,x,v); else update(rson[o],mid+1,r,x,v);&#125;inline void UPDATE(int x,int v)&#123; int k=lower_bound(b+1,b+len+1,a[x])-b; for(;x&lt;=n;x+=lowbit(x))update(root[x],1,len,k,v);&#125;inline int query(int l,int r,int k)&#123; if(l==r)return l; int sum=0,mid=l+r&gt;&gt;1; rep(i,1,rlen)sum+=tr[lson[R[i]]]; rep(i,1,llen)sum-=tr[lson[L[i]]]; if(k&lt;=sum)&#123; rep(i,1,rlen)R[i]=lson[R[i]]; rep(i,1,llen)L[i]=lson[L[i]]; return query(l,mid,k); &#125; rep(i,1,rlen)R[i]=rson[R[i]]; rep(i,1,llen)L[i]=rson[L[i]]; return query(mid+1,r,k-sum);&#125;inline int QUERY(int l,int r,int k)&#123; llen=rlen=0; for(register int i=l-1;i;i-=lowbit(i))L[++llen]=root[i]; for(register int i=r;i;i-=lowbit(i))R[++rlen]=root[i]; return query(1,len,k);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123;scanf("%d",&amp;a[i]);b[i]=a[i];&#125;len=n; rep(i,1,m)&#123; char op;while(isspace(op=getchar())); scanf("%d%d",&amp;s[i][0],&amp;s[i][1]); if(op=='Q')scanf("%d",&amp;s[i][2]); else &#123;b[++len]=s[i][1];s[i][2]=-1;&#125; &#125; sort(b+1,b+len+1); len=unique(b+1,b+len+1)-b-1; rep(i,1,n)UPDATE(i,1); rep(i,1,m)&#123; if(s[i][2]==-1)&#123;UPDATE(s[i][0],-1);a[s[i][0]]=s[i][1];UPDATE(s[i][0],1);&#125; else printf("%d\n",b[QUERY(s[i][0],s[i][1],s[i][2])]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树套树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2922[水]]]></title>
    <url>%2Flg2922-%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[链接:lg2922[水] 题解 简单Trie树,匹配路上的所有结束字符串都要加上,经过最后一个位置的字符串也要加上注意计算顺序就好… 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt; #include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define long longusing namespace std;const int N=5e5+7;int tr[N&lt;&lt;2][2],nm[N],sum[N&lt;&lt;2],n,m,cnt=1,end[N];inline void add(int *a,int len)&#123; int p=1; rep(i,1,len)&#123; if(!tr[p][a[i]])tr[p][a[i]]=++cnt; sum[tr[p][a[i]]]++;p=tr[p][a[i]]; &#125; end[p]++;&#125;inline int query(int *a,int len)&#123; int p=1,ans=0; rep(i,1,len)&#123; if(!tr[p][a[i]])return ans; p=tr[p][a[i]]; if(p)ans+=end[p]; &#125; return ans+sum[p]-end[p];&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123; int x;scanf("%d",&amp;x); rep(j,1,x)scanf("%d",&amp;nm[j]); add(nm,x); &#125; rep(i,1,m)&#123; int x;scanf("%d",&amp;x); rep(j,1,x)scanf("%d",&amp;nm[j]); printf("%d\n",query(nm,x)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>Trie树</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2292[dp+trie树]]]></title>
    <url>%2Flg2292-dp-trie%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接:lg2292[dp+trie树] 题解 dp[i]表示表示前缀i能否匹配,那么转移方程显然是dp[i]=dp[j]&amp;&amp;(j-i能否匹配) (j&lt;=i) 走的方向是唯一的,那么显然可以用Trie树来维护. 但是还有一个问题,我们是往前匹配,然而正常的Trie树上反向走并不好走,解决方法是反向建Trie树 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int tr[N][26],end[N],dp[N],cnt,n,m;char a[N];inline void add(char *str)&#123; int len=strlen(str)-1,p=0; repd(i,len,0)&#123; int k=str[i]-'a'; if(!tr[p][k])tr[p][k]=++cnt; p=tr[p][k]; &#125; end[p]++;&#125;inline void query(char *str,int pos)&#123; int p=0,flag=0; repd(i,pos-1,0)&#123; if(!tr[p][str[i]-'a'])break; p=tr[p][str[i]-'a'];if(dp[i]&amp;&amp;end[p])flag=1; &#125; dp[pos]=flag;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123;scanf("%s",a);add(a);&#125; rep(i,1,m)&#123; int ans=0; scanf("%s",a); memset(dp,0,sizeof(dp)); int len=strlen(a); dp[0]=1; rep(i,1,len)&#123;query(a,i);if(dp[i])ans=max(i,ans);&#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>Trie树</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2580[板子]]]></title>
    <url>%2Flg2580-%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[链接:lg2580[板子] 题解 Trie树板子123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int tr[N][26],end[N],cnt,n,m,x;char a[N];inline void add(char* str)&#123; int len=strlen(str)-1,p=1; rep(i,0,len)&#123; int k=str[i]-'a'; if(!tr[p][k])tr[p][k]=++cnt; p=tr[p][k]; &#125; end[p]=1;&#125;inline int query(char* str)&#123; int len=strlen(str)-1,p=1; rep(i,0,len)&#123; p=tr[p][str[i]-'a']; if(p==0)return 0; &#125; return end[p]++;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123;scanf("%s",a);add(a);&#125; scanf("%d",&amp;m); rep(i,1,m)&#123; scanf("%s",a);int t=query(a); if(t==1)&#123;puts("OK");&#125; else if(t&gt;1)puts("REPEAT"); else puts("WRONG"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>Trie树</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3567[简单的主席树]]]></title>
    <url>%2Flg3567-%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接:lg3567[简单的主席树] 题解 数据范围比较小可以不离散化,然后就是模板主席树往2*(sum[j]-sum[i])&gt;r-l+1那边走注意是不带等号的 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e5;int tr[N&lt;&lt;5],lson[N&lt;&lt;5],rson[N&lt;&lt;5],rt[N],cnt,n,m;inline void update(int &amp;o,int l,int r,int x)&#123; tr[++cnt]=tr[o];lson[cnt]=lson[o];rson[cnt]=rson[o]; o=cnt;tr[o]++; if(l==r)return ; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(lson[o],l,mid,x); else update(rson[o],mid+1,r,x);&#125;inline int query(int i,int j,int l,int r,int x)&#123; if(l==r)return l; int mid=l+r&gt;&gt;1; if(2*(tr[lson[j]]-tr[lson[i]])&gt;x)return query(lson[i],lson[j],l,mid,x); if(2*(tr[rson[j]]-tr[rson[i]])&gt;x)return query(rson[i],rson[j],mid+1,r,x); return 0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123;int x;rt[i]=rt[i-1];scanf("%d",&amp;x);update(rt[i],1,n,x);&#125; rep(i,1,m)&#123;int l,r;scanf("%d%d",&amp;l,&amp;r);printf("%d\n",query(rt[l-1],rt[r],1,n,r-l+1));&#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2886[反素数+线段树]]]></title>
    <url>%2Fpoj2886-%E5%8F%8D%E7%B4%A0%E6%95%B0-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[链接:poj2886[反素数+线段树] 题解 重点是求n以内因数个数最大的数及其个数,一开始的做法是用欧拉线性筛,然后打个表,然后看了题解发现有一个神奇的东西叫反素数。 学习了一波然后用更快的方法打了个表23333(好像没啥用…) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=5e5+7;int rev[37] = &#123;1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260 ,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160, 110880,166320,221760,277200,332640,498960,500001&#125;;int revs[37] = &#123;1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72, 80,84,90,96,100,108,120,128,144,160,168,180,192,200,1314521&#125;;int tr[N&lt;&lt;2],w[N],pos,n,k,id;char str[N][20];inline void build(int o,int l,int r)&#123; tr[o]=r-l+1; if(l==r)return ; int mid=l+r&gt;&gt;1; build(lson); build(rson);&#125;inline int update(int o,int l,int r,int x)&#123; tr[o]--; if(l==r)return l; int mid=l+r&gt;&gt;1; if(x&lt;=tr[o&lt;&lt;1])return update(lson,x); return update(rson,x-tr[o&lt;&lt;1]);&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;k))&#123; while(rev[id]&lt;=n)id++; rep(i,1,n)scanf("%s%d",str[i],&amp;w[i]); build(1,1,n); int &amp;p=tr[1];pos=0; int m=rev[id-1]; rep(i,1,m)&#123; if(w[pos]&gt;0)k=((k+w[pos]-2)%p+p)%p+1; else k=((k+w[pos]+p-1)%p+p)%p+1; pos=update(1,1,n,k); &#125; printf("%s %d\n",str[pos],revs[id-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1394[树状数组,逆序对]]]></title>
    <url>%2Fhdu1394-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[链接:hdu1394[树状数组,逆序对] 题解 求出逆序数,O(N)遍历一遍 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define lowbit(x) x&amp;(-x)using namespace std;const int N=1e5;const int inf=0x3f3f3f3f;typedef pair&lt;int,int&gt; s;int tr[N],a[N],n,res,ans;s q[N];inline void update(int x,int y)&#123;for(register int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;inline int query(int x)&#123;int ans=0;for(register int i=x;i;i-=lowbit(i))ans+=tr[i];return ans;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; ans=inf;res=0; memset(tr,0,sizeof(tr)); rep(i,1,n)&#123;scanf("%d",&amp;a[i]);q[i]=s(a[i],i);&#125; sort(q+1,q+n+1); rep(i,1,n)&#123;update(q[i].second,1);res+=i-query(q[i].second);&#125; if(ans&gt;res)ans=res; rep(i,1,n)&#123;res=res-a[i]+n-a[i]-1;ans=min(ans,res);&#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2828[单点修改]]]></title>
    <url>%2Fpoj2828-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[链接:poj2828[单点修改] 题解 倒着单点更新1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=2e5+7;typedef pair&lt;int,int&gt; s;s q[N];int tr[N&lt;&lt;2],ans[N],n;inline void build(int o,int l,int r)&#123; tr[o]=r-l+1; if(l==r)return ; int mid=l+r&gt;&gt;1; build(lson); build(rson);&#125;inline void update(int o,int l,int r,int x,int p)&#123; if(l==r)&#123;ans[l]=p;tr[o]=0;return ;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=tr[o&lt;&lt;1])update(lson,x,p); else update(rson,x-tr[o&lt;&lt;1],p); tr[o]-=1;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; int m=n+1; build(1,1,m); rep(i,1,n)scanf("%d%d",&amp;q[i].first,&amp;q[i].second); repd(i,n,1)update(1,1,m,q[i].first+1,q[i].second); rep(i,1,n)printf("%d ",ans[i]); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3168[求区间前k小的和]]]></title>
    <url>%2Flg3168-%E6%B1%82%E5%8C%BA%E9%97%B4%E5%89%8Dk%E5%B0%8F%E7%9A%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[链接:lg3168[求区间前k小的和] 题解 显然对于区间优先级加k操作进行差分,对时间建主席树,维护优先级前缀和以及在这个优先级区间里的任务个数,更新就很简单了 ,查询类似查区间第k小. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=2e5+7;struct node&#123; int l,val,p; node(int l,int val,int p):l(l),val(val),p(p)&#123;&#125; node()&#123;&#125;&#125;e[N&lt;&lt;2];ll tr[N&lt;&lt;5],size[N&lt;&lt;5];int lson[N&lt;&lt;5],rson[N&lt;&lt;5],root[N],a[N],len,n,m,cnt;inline int cmpv(node x,node y)&#123;return x.val&lt;y.val;&#125;inline int cmpt(node x,node y)&#123;return x.l&lt;y.l;&#125;inline void update(int &amp;o,int l,int r,int k,int p)&#123; lson[++cnt]=lson[o];rson[cnt]=rson[o];tr[cnt]=tr[o];size[cnt]=size[o]; o=cnt;tr[o]+=a[k]*p;size[o]+=p; if(l==r)return; int mid=l+r&gt;&gt;1; if(k&lt;=mid)update(lson[o],l,mid,k,p); else update(rson[o],mid+1,r,k,p);&#125;inline ll query(int o,int l,int r,int k)&#123; if(size[o]&lt;=k)return tr[o]; if(l==r)return tr[o]/size[o]*k; int mid=l+r&gt;&gt;1; if(k&lt;=size[lson[o]])return query(lson[o],l,mid,k); return tr[lson[o]]+query(rson[o],mid+1,r,k-size[lson[o]]);&#125;inline void solve()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); e[(i&lt;&lt;1)-1]=node(a,c,1);e[i&lt;&lt;1]=node(b+1,c,-1); &#125; sort(e+1,e+n*2+1,cmpv); rep(i,1,n*2)&#123;if(e[i].val!=a[len])a[++len]=e[i].val;e[i].val=len;&#125; sort(e+1,e+n*2+1,cmpt); ll pre=1;int k=1; rep(i,1,m)&#123; root[i]=root[i-1]; while(e[k].l==i)update(root[i],1,len,e[k].val,e[k].p),k++; &#125; rep(i,1,m)&#123; int x,A,B,c; scanf("%d%d%d%d",&amp;x,&amp;A,&amp;B,&amp;c); pre=(pre*A+B)%c+1; printf("%lld\n",pre=query(root[x],1,len,pre)); &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1383]]></title>
    <url>%2Flg1383%2F</url>
    <content type="text"><![CDATA[链接:lg1383 题解 主席树水题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;const int M=1e5;char rt[N&lt;&lt;5];int lson[N&lt;&lt;5],rson[N&lt;&lt;5],root[N],cnt,now,len[N],n;inline void update(int pre,int &amp;o,int l,int r,int k,char x)&#123; o=++cnt; lson[o]=lson[pre];rson[o]=rson[pre]; if(l==r)&#123;rt[o]=x; return ;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)update(lson[pre],lson[o],l,mid,k,x); else update(rson[pre],rson[o],mid+1,r,k,x);&#125;inline void query(int o,int l,int r,int k)&#123; if(l==r)&#123;cout&lt;&lt;rt[o]&lt;&lt;endl;return ;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)return query(lson[o],l,mid,k); return query(rson[o],mid+1,r,k);&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; while(n--)&#123; char op,c;int x; cin&gt;&gt;op; if(op=='T')&#123;cin&gt;&gt;c; root[++now]=root[now-1]; len[now]=len[now-1]+1; update(root[now-1],root[now],1,M,len[now],c); &#125; else if(op=='U')&#123;cin&gt;&gt;x;root[++now]=root[now-x-1];len[now]=len[now-x-1];&#125; else &#123;cin&gt;&gt;x;query(root[now],1,M,x);&#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3919【板子】]]></title>
    <url>%2Flg3919%E3%80%90%E6%9D%BF%E5%AD%90%E3%80%91%2F</url>
    <content type="text"><![CDATA[链接:lg3919【板子】 题解 主席树板子 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int rt[N&lt;&lt;5],lson[N&lt;&lt;5],rson[N&lt;&lt;5],root[N];int n,m,cnt;inline void build(int &amp;o,int l,int r)&#123; o=++cnt; if(l==r)&#123;scanf("%d",&amp;rt[o]);return ;&#125; int mid=l+r&gt;&gt;1; build(lson[o],l,mid); build(rson[o],mid+1,r);&#125;inline void update(int pre,int &amp;o,int l,int r,int k,int x)&#123; o=++cnt;rt[o]=rt[pre];lson[o]=lson[pre];rson[o]=rson[pre]; if(l==r)&#123;rt[o]=x;return ;&#125; int mid=l+r&gt;&gt;1; if(k&lt;=mid)update(lson[pre],lson[o],l,mid,k,x); else update(rson[pre],rson[o],mid+1,r,k,x);&#125;inline int query(int o,int l,int r,int k)&#123; if(l==r)return rt[o]; int mid=l+r&gt;&gt;1; if(k&lt;=mid)return query(lson[o],l,mid,k); return query(rson[o],mid+1,r,k);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); build(root[0],1,n); rep(i,1,m)&#123; int pre,op,k,x; scanf("%d%d%d",&amp;pre,&amp;op,&amp;k); if(op==1)&#123;scanf("%d",&amp;x);update(root[pre],root[i],1,n,k,x);&#125; else &#123;printf("%d\n",query(root[pre],1,n,k));root[i]=root[pre];&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2665,poj2104,51nod1175]]></title>
    <url>%2Fhdu2665-poj2104-51nod1175%2F</url>
    <content type="text"><![CDATA[链接:51nod链接:poj链接:hdu链接:luogu 题解 主席树(划分树)入门主席树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;typedef pair&lt;int,int&gt; q;int rt[N*20],root[N],rk[N],lson[N*20],rson[N*20],cnt=1,n,m,T;q nm[N];inline void update(int &amp;o,int l,int r,int num)&#123; rt[cnt]=rt[o];lson[cnt]=lson[o];rson[cnt++]=rson[o];o=cnt-1;rt[o]++; if(l==r)return ; int mid=l+r&gt;&gt;1; if(num&lt;=mid)update(lson[o],l,mid,num); else update(rson[o],mid+1,r,num);&#125;inline int query(int i,int j,int l,int r,int k)&#123; int t=rt[lson[j]]-rt[lson[i]]; if(l==r)return l; int mid=l+r&gt;&gt;1; if(k&lt;=t)return query(lson[i],lson[j],l,mid,k); else return query(rson[i],rson[j],mid+1,r,k-t);&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123; int x; scanf("%d",&amp;x); nm[i]=q(x,i); &#125; scanf("%d",&amp;m); sort(nm+1,nm+n+1); rep(i,1,n)rk[nm[i].second]=i; rep(i,1,n)&#123;root[i]=root[i-1];update(root[i],1,n,rk[i]);&#125; while(m--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); a++;b++; c=b-a+2-c; printf("%d\n",nm[query(root[a-1],root[b],1,n,c)].first); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选课[树形dp]]]></title>
    <url>%2F%E9%80%89%E8%AF%BE-%E6%A0%91%E5%BD%A2dp%2F</url>
    <content type="text"><![CDATA[链接1:选课[树形dp]链接2:选课[树形dp] 题解 乍一看是有依赖的背包问题,然而并不是。因为有依赖的背包问题没有间接依赖关系,然而这题有 正解是树形dp。 建图之后是一个森林? 人为加一个源点就OK 因为第二个链接中要求输出决策 我建图为二叉树,多跑一遍dfs记录决策多叉树123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;map&gt;#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,r#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3;vector&lt;int&gt;edge[N];int dp[N][N],pre[N],n,m,w[N],root;void dfs(int u)&#123; rep(i,1,m)dp[u][i]=w[u]; int len=edge[u].size()-1; rep(i,0,len)&#123; int v=edge[u][i]; dfs(v); repd(j,m,1)rep(k,1,(u==root?j:j-1))dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123; scanf("%d%d",&amp;pre[i],&amp;w[i]); if(pre[i])edge[pre[i]].push_back(i); &#125; root=0; rep(i,1,n)if(!pre[i])edge[root].push_back(i); dfs(root); cout&lt;&lt;dp[root][m]&lt;&lt;endl; return 0;&#125; 二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;map&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3;int dp[N][N],lson[N],rson[N],w[N],n,m,ans[N];void maketree()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); w[i]=b; rson[i]=lson[a]; lson[a]=i; &#125;&#125;void dfs(int x,int y)&#123; if(dp[x][y]||x==0||y==0)return ; dfs(rson[x],y); rep(i,0,y-1)&#123; dfs(rson[x],i); dfs(lson[x],y-i-1); dp[x][y]=max(dp[x][y],max(dp[rson[x]][y],dp[rson[x]][i]+dp[lson[x]][y-i-1]+w[x])); &#125;&#125;void path(int x,int y)&#123; if(x==0||y==0)&#123;dp[x][y]=0;return;&#125; dfs(rson[x],y); rep(i,0,y-1)if(dp[x][y]==dp[rson[x]][i]+dp[lson[x]][y-i-1]+w[x])&#123; path(rson[x],i); path(lson[x],y-i-1); ans[x]=1; &#125;&#125;int main()&#123; maketree(); dfs(lson[0],m); path(lson[0],m); cout&lt;&lt;dp[lson[0]][m]&lt;&lt;endl; rep(i,1,n)if(ans[i])cout&lt;&lt;i&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4578[多标记]]]></title>
    <url>%2Fhdu4578-%E5%A4%9A%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[链接:hdu4578[多标记] 题解 非常裸的线段树,但是很麻烦,三个标记很多细节考虑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long #define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=100000+5;const int p=10007;ll sum[3][N&lt;&lt;2],add[N&lt;&lt;2],st[N&lt;&lt;2],mul[N&lt;&lt;2];int n,m;inline void pushup(int o)&#123;rep(i,0,2)sum[i][o]=(sum[i][o&lt;&lt;1]+sum[i][o&lt;&lt;1|1])%p;&#125;inline void pushdown(int o,int l,int r)&#123; int mid=l+r&gt;&gt;1; if(st[o])&#123; add[o&lt;&lt;1]=add[o&lt;&lt;1|1]=0; mul[o&lt;&lt;1]=mul[o&lt;&lt;1|1]=1; st[o&lt;&lt;1]=st[o&lt;&lt;1|1]=st[o]; rep(i,0,2)&#123; sum[i][o&lt;&lt;1]=(mid-l+1)*(ll)pow(st[o],i+1)%p; sum[i][o&lt;&lt;1|1]=(r-mid)*(ll)pow(st[o],i+1)%p; &#125; st[o]=0; &#125; if(mul[o]!=1)&#123; mul[o&lt;&lt;1]=mul[o&lt;&lt;1]*mul[o]%p; mul[o&lt;&lt;1|1]=mul[o&lt;&lt;1|1]*mul[o]%p; if(add[o&lt;&lt;1])add[o&lt;&lt;1]=add[o&lt;&lt;1]*mul[o]%p; if(add[o&lt;&lt;1|1])add[o&lt;&lt;1|1]=add[o&lt;&lt;1|1]*mul[o]%p; sum[2][o&lt;&lt;1]=sum[2][o&lt;&lt;1]*mul[o]%p*mul[o]%p*mul[o]; sum[2][o&lt;&lt;1|1]=sum[2][o&lt;&lt;1|1]*mul[o]%p*mul[o]%p*mul[o]; sum[1][o&lt;&lt;1]=sum[1][o&lt;&lt;1]*mul[o]%p*mul[o]%p; sum[1][o&lt;&lt;1|1]=sum[1][o&lt;&lt;1|1]*mul[o]%p*mul[o]%p; sum[0][o&lt;&lt;1]=sum[0][o&lt;&lt;1]*mul[o]%p; sum[0][o&lt;&lt;1|1]=sum[0][o&lt;&lt;1|1]*mul[o]%p; mul[o]=1; &#125; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; add[o&lt;&lt;1|1]+=add[o]; ll tp=add[o]*add[o]%p*add[o]%p; sum[2][o&lt;&lt;1]=(sum[2][o&lt;&lt;1]+tp*(mid-l+1)%p+3*add[o]*(sum[1][o&lt;&lt;1]+sum[0][o&lt;&lt;1]*add[o]%p)%p)%p; sum[2][o&lt;&lt;1|1]=(sum[2][o&lt;&lt;1|1]+tp*(r-mid)%p+3*add[o]*(sum[1][o&lt;&lt;1|1]+sum[0][o&lt;&lt;1|1]*add[o]%p)%p)%p; sum[1][o&lt;&lt;1]=(sum[1][o&lt;&lt;1]+2*sum[0][o&lt;&lt;1]*add[o]%p+add[o]*add[o]%p*(mid-l+1)%p)%p; sum[1][o&lt;&lt;1|1]=(sum[1][o&lt;&lt;1|1]+2*sum[0][o&lt;&lt;1|1]*add[o]%p+add[o]*add[o]%p*(r-mid)%p)%p; sum[0][o&lt;&lt;1]=(sum[0][o&lt;&lt;1]+add[o]*(mid-l+1))%p; sum[0][o&lt;&lt;1|1]=(sum[0][o&lt;&lt;1|1]+add[o]*(r-mid))%p; add[o]=0; &#125;&#125;inline void build(int o,int l,int r)&#123; add[o]=st[o]=0;mul[o]=1; if(l==r)&#123;rep(i,0,2)sum[i][o]=0;return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int L,int R,int op,int c)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; if(op==3)&#123; st[o]=c; add[o]=0;mul[o]=1; sum[0][o]=(r-l+1)*c%p; sum[1][o]=(r-l+1)*c%p*c%p; sum[2][o]=(r-l+1)*c%p*c%p*c%p; &#125; if(op==2)&#123; mul[o]=mul[o]*c%p; if(add[o])add[o]=(add[o]*c)%p; sum[0][o]=sum[0][o]*c%p; sum[1][o]=sum[1][o]*c%p*c%p; sum[2][o]=sum[2][o]*c%p*c%p*c%p; &#125; if(op==1)&#123; add[o]+=c; ll tp=c*c%p*c%p; sum[2][o]=(sum[2][o]+tp*(r-l+1)%p+3*c*(sum[1][o]+c*sum[0][o]%p))%p; sum[1][o]=(sum[1][o]+c*c%p*(r-l+1)%p+2*c%p*sum[0][o]%p)%p; sum[0][o]=(sum[0][o]+c*(r-l+1))%p; &#125; return ; &#125; pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R,op,c); if(R&gt;mid)update(rson,L,R,op,c); pushup(o);&#125;inline int query(int o,int l,int r,int L,int R,int op)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return sum[op-1][o]%p; pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=query(lson,L,R,op); if(R&gt;mid)ans+=query(rson,L,R,op); return ans%p;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; if(!n&amp;&amp;!m)break; build(1,1,n); while(m--)&#123; int x,l,r,c; scanf("%d%d%d%d",&amp;x,&amp;l,&amp;r,&amp;c); if(x==4)printf("%d\n",query(1,1,n,l,r,c)); else update(1,1,n,l,r,x,c); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2763]]></title>
    <url>%2Fpoj2763%2F</url>
    <content type="text"><![CDATA[链接:poj2763 题解 单点修改区间查询,注意维护边信息…坑了好几次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=u;--i)#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,r#define ll long longusing namespace std;const int N=1e6;ll rt[N&lt;&lt;2],id[N],hson[N],size[N],deep[N],f[N],top[N];ll head[N],to[N],nxt[N],w[N],wt[N],e[N][2];int n,m,s,cnt;inline void adde(int x,int y,int z,int k)&#123;nxt[k]=head[x];to[k]=y;wt[k]=z;head[x]=k;&#125;inline void pushup(int o)&#123;rt[o]=rt[o&lt;&lt;1]+rt[o&lt;&lt;1|1];&#125;inline void build(int o,int l,int r)&#123; if(l==r)&#123;rt[o]=w[l];return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int x,int y)&#123; if(l==r)&#123;rt[o]=y;return ;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(lson,x,y); else update(rson,x,y); pushup(o);&#125;inline ll query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return rt[o]; int mid=l+r&gt;&gt;1;ll ans=0; if(L&lt;=mid)ans+=query(lson,L,R); if(R&gt;mid)ans+=query(rson,L,R); return ans;&#125;inline void dfs1(int x)&#123; size[x]=1; for(int i=head[x];i;i=nxt[i])if(to[i]!=f[x])&#123; f[to[i]]=x; deep[to[i]]=deep[x]+1; dfs1(to[i]); size[x]+=size[to[i]]; if(size[hson[x]]&lt;size[to[i]])hson[x]=to[i]; &#125;&#125;inline void dfs2(int x,int t)&#123; top[x]=t;id[x]=++cnt; if(hson[x])dfs2(hson[x],t); for(int i=head[x];i;i=nxt[i])if(hson[x]!=to[i]&amp;&amp;f[x]!=to[i])dfs2(to[i],to[i]);&#125;inline ll queryrange(int x,int y)&#123; ll ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); ans+=query(1,1,n,id[top[x]],id[x]); x=f[top[x]]; &#125; if(x==y)return ans; if(deep[x]&gt;deep[y])swap(x,y); return ans+query(1,1,n,id[hson[x]],id[y]);&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); rep(i,1,n-1)&#123; int u,v,c; scanf("%d%d%d",&amp;e[i][0],&amp;e[i][1],&amp;c); adde(e[i][0],e[i][1],c,i);adde(e[i][1],e[i][0],c,i+n); &#125; dfs1(1); dfs2(1,1); rep(i,1,n-1)&#123;if(deep[e[i][0]]&lt;deep[e[i][1]])swap(e[i][0],e[i][1]);w[id[e[i][0]]]=wt[i];&#125; build(1,1,n); while(m--)&#123; int a,b; scanf("%d",&amp;a); if(!a)&#123;scanf("%d",&amp;b);printf("%lld\n",queryrange(s,b));s=b;&#125; else &#123;scanf("%d%d",&amp;a,&amp;b);update(1,1,n,id[e[a][0]],b);&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学公式]]></title>
    <url>%2F%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[链接:数学公式 Description 一些公式 基姆拉尔森计算公式 (d+2m+3(m+1)/5+y+y/4-y/100+y/400+1)%7 把1月,2月当成上一年13,14月来计算约瑟夫环问题 f(N,M)=(f(N−1,M)+M)%N三角平方数 $$因子和问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[lg3178[维护点权]]]></title>
    <url>%2Flg3178-%E7%BB%B4%E6%8A%A4%E7%82%B9%E6%9D%83%2F</url>
    <content type="text"><![CDATA[链接:lg3178[维护点权] 题解 维护点权,模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e6;ll rt[N],lz[N],id[N],top[N],hson[N],size[N],deep[N],w[N],wt[N],f[N];int head[N],nxt[N],to[N];ll n,m,cnt,op,a,b;inline void adde(int u,int v)&#123;nxt[++cnt]=head[u];to[cnt]=v;head[u]=cnt;&#125;inline void pushup(int o)&#123;rt[o]=rt[o&lt;&lt;1]+rt[o&lt;&lt;1|1];&#125;inline void pushdown(int o,int len)&#123; if(!lz[o])return ; lz[o&lt;&lt;1]+=lz[o]; lz[o&lt;&lt;1|1]+=lz[o]; rt[o&lt;&lt;1]+=lz[o]*(len-(len&gt;&gt;1)); rt[o&lt;&lt;1|1]+=lz[o]*(len&gt;&gt;1); lz[o]=0;&#125;inline void build(int o,int l,int r)&#123; if(l==r)&#123;rt[o]=w[l];return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int L,int R,ll x)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123;rt[o]+=(r-l+1)*x;lz[o]+=x;return ;&#125; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R,x); if(R&gt;mid)update(rson,L,R,x); pushup(o);&#125;inline ll query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return rt[o]; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=query(lson,L,R); if(R&gt;mid)ans+=query(rson,L,R); return ans;&#125;inline void dfs1(int x)&#123; size[x]=1; for(int i=head[x];i;i=nxt[i])if(to[i]!=f[x])&#123; f[to[i]]=x; deep[to[i]]=deep[x]+1; dfs1(to[i]); size[x]+=size[to[i]]; if(size[hson[x]]&lt;size[to[i]])hson[x]=to[i]; &#125;&#125;inline void dfs2(int x,int t)&#123; top[x]=t;id[x]=++cnt;w[cnt]=wt[x]; if(hson[x])dfs2(hson[x],t); for(int i=head[x];i;i=nxt[i])if(to[i]!=f[x]&amp;&amp;to[i]!=hson[x])dfs2(to[i],to[i]);&#125;inline ll queryrange(int x,int y)&#123; ll ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); ans+=query(1,1,n,id[top[x]],id[x]); x=f[top[x]]; &#125; if(deep[x]&gt;deep[y])swap(x,y); return ans+query(1,1,n,id[x],id[y]);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%lld",&amp;wt[i]); rep(i,2,n)&#123;scanf("%d%d",&amp;a,&amp;b);adde(a,b);adde(b,a);&#125; cnt=0; dfs1(1); dfs2(1,1); build(1,1,n); while(m--)&#123; scanf("%d%lld",&amp;op,&amp;a); if(op==1)&#123;scanf("%lld",&amp;b);update(1,1,n,id[a],id[a],b);&#125; else if(op==2)&#123;scanf("%lld",&amp;b);update(1,1,n,id[a],id[a]+size[a]-1,b);&#125; else printf("%lld\n",queryrange(1,a)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3966[维护点权]]]></title>
    <url>%2Fhdu3966-%E7%BB%B4%E6%8A%A4%E7%82%B9%E6%9D%83%2F</url>
    <content type="text"><![CDATA[链接:hdu3966[维护点权] 题解 注意仔细读题,维护点权模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long #define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e5;int rt[N&lt;&lt;2],lz[N&lt;&lt;2],id[N],top[N],deep[N],size[N],f[N],hson[N];int nxt[N],w[N],wt[N],head[N],to[N];int n,m,q,a,b,c,cnt;char op[2];inline void adde(int u,int v)&#123;nxt[++cnt]=head[u];to[cnt]=v;head[u]=cnt;&#125;inline void pushup(int o)&#123;rt[o]=rt[o&lt;&lt;1]+rt[o&lt;&lt;1|1];&#125;inline void pushdown(int o,int len)&#123; if(!lz[o])return ; lz[o&lt;&lt;1]+=lz[o]; lz[o&lt;&lt;1|1]+=lz[o]; rt[o&lt;&lt;1]+=lz[o]*(len-(len&gt;&gt;1)); rt[o&lt;&lt;1|1]+=lz[o]*(len&gt;&gt;1); lz[o]=0;&#125;inline void build(int o,int l,int r)&#123; lz[o]=0; if(l==r)&#123;rt[o]=w[l]; return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int L,int R,int x)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123;rt[o]+=x*(r-l+1); lz[o]+=x;return ;&#125; int mid=l+r&gt;&gt;1; pushdown(o,r-l+1); if(L&lt;=mid)update(lson,L,R,x); if(R&gt;mid)update(rson,L,R,x); pushup(o);&#125;inline int query(int o,int l,int r,int x)&#123; if(l==r)return rt[o]; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; if(x&lt;=mid)return query(lson,x); return query(rson,x);&#125;inline void dfs1(int x)&#123; size[x]=1; for(int i=head[x];i;i=nxt[i])if(to[i]!=f[x])&#123; f[to[i]]=x; deep[to[i]]=deep[x]+1; dfs1(to[i]); size[x]+=size[to[i]]; if(size[hson[x]]&lt;size[to[i]])hson[x]=to[i]; &#125;&#125;inline void dfs2(int x,int t)&#123; top[x]=t;id[x]=++cnt;w[cnt]=wt[x]; if(hson[x])dfs2(hson[x],t); for(int i=head[x];i;i=nxt[i])if(hson[x]!=to[i]&amp;&amp;to[i]!=f[x])dfs2(to[i],to[i]);&#125;inline void uprange(int x,int y,int k)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=f[top[x]]; &#125; if(deep[x]&gt;deep[y])swap(x,y); update(1,1,n,id[x],id[y],k);&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;q))&#123; //memset(f,-1,sizeof(f)); memset(head,0,sizeof(head)); memset(hson,0,sizeof(hson)); cnt=deep[1]=0; rep(i,1,n)scanf("%d",&amp;wt[i]); rep(i,2,n)&#123; scanf("%d%d",&amp;a,&amp;b); adde(a,b);adde(b,a); &#125;cnt=0; dfs1(1); dfs2(1,1); build(1,1,n); while(q--)&#123; scanf("%s",op); if(op[0]=='Q')&#123;scanf("%d",&amp;a);printf("%d\n",query(1,1,n,id[a]));&#125; else &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if(op[0]=='D')c*=-1; uprange(a,b,c); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2420[边权]]]></title>
    <url>%2Flg2420-%E8%BE%B9%E6%9D%83%2F</url>
    <content type="text"><![CDATA[链接:lg2420[边权] 题解 和维护点权差不多,脑洞yy一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e6;ll rt[N],lz[N],deep[N],size[N],hson[N],f[N],top[N],id[N];ll head[N],nxt[N],to[N],w[N],wt[N],wc[N];int cnt,n,m;inline void adde(int u,int v,int x)&#123;nxt[++cnt]=head[u];to[cnt]=v;wt[cnt]=x;head[u]=cnt;&#125;inline void pushup(int o)&#123;rt[o]=rt[o&lt;&lt;1]^rt[o&lt;&lt;1|1];&#125;inline void build(int o,int l,int r)&#123; if(l==r)&#123;rt[o]=w[l];return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline ll query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return rt[o]; int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)&#123;ll tp=query(lson,L,R);if(!ans)ans=tp;else ans^=tp;&#125; if(R&gt;mid)&#123;ll tp=query(rson,L,R);if(!ans)ans=tp;else ans^=tp;&#125; return ans;&#125;inline void dfs1(int x)&#123; size[x]=1; for(int i=head[x];i;i=nxt[i])if(to[i]!=f[x])&#123; wc[to[i]]=wt[i]; f[to[i]]=x; deep[to[i]]=deep[x]+1; dfs1(to[i]); size[x]+=size[to[i]]; if(size[hson[x]]&lt;size[to[i]])hson[x]=to[i]; &#125;&#125;inline void dfs2(int x,int t)&#123; top[x]=t;id[x]=++cnt;w[cnt]=wc[x]; if(hson[x])dfs2(hson[x],t); for(int i=head[x];i;i=nxt[i])if(to[i]!=hson[x]&amp;&amp;to[i]!=f[x])dfs2(to[i],to[i]);&#125;inline ll queryrange(int x,int y)&#123; ll ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); ll tp=query(1,1,n,id[top[x]],id[x]); if(!ans)ans=tp;else ans^=tp; x=f[top[x]]; &#125; if(x==y)return ans; if(deep[x]&gt;deep[y])swap(x,y); return ans^query(1,1,n,id[hson[x]],id[y]);&#125;int main()&#123; scanf("%d",&amp;n); rep(i,2,n)&#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); adde(x,y,z);adde(y,x,z); &#125;cnt=0; dfs1(1); dfs2(1,1); build(1,1,n); scanf("%d",&amp;m); while(m--)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); printf("%lld\n",queryrange(x,y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg3384[树剖模板]]]></title>
    <url>%2Flg3384-%E6%A0%91%E5%89%96%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[链接:lg3384[树剖模板] 题解 模板没什么说的…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e6+7;ll rt[N&lt;&lt;2],id[N],hson[N],top[N],size[N],deep[N],f[N],lz[N&lt;&lt;2];ll nxt[N],to[N],head[N],w[N],wt[N];int n,m,q,p,cnt;inline void adde(int x,int y)&#123; nxt[++cnt]=head[x]; to[cnt]=y; head[x]=cnt;&#125;inline void pushup(int o)&#123;rt[o]=(rt[o&lt;&lt;1]+rt[o&lt;&lt;1|1])%p;&#125;inline void pushdown(int o,int len)&#123; if(!lz[o])return ; lz[o&lt;&lt;1]+=lz[o]; lz[o&lt;&lt;1|1]+=lz[o]; rt[o&lt;&lt;1]=(rt[o&lt;&lt;1]+(len-(len&gt;&gt;1))*lz[o])%p; rt[o&lt;&lt;1|1]=(rt[o&lt;&lt;1|1]+(len&gt;&gt;1)*lz[o])%p; lz[o]=0;&#125;inline void build(int o,int l,int r)&#123; lz[o]=0; if(l==r)&#123;rt[o]=wt[l]%p;return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int L,int R,ll x)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; lz[o]+=x; rt[o]=(rt[o]+(r-l+1)*x)%p; return ; &#125; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R,x); if(R&gt;mid)update(rson,L,R,x); pushup(o);&#125;inline ll query(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return rt[o]; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=query(lson,L,R); if(R&gt;mid)ans+=query(rson,L,R); return ans%p;&#125;inline void dfs1(int x)&#123; size[x]=1; for(int i=head[x];i;i=nxt[i])if(to[i]!=f[x])&#123; f[to[i]]=x; deep[to[i]]=deep[x]+1; dfs1(to[i]); size[x]+=size[to[i]]; if(size[hson[x]]&lt;size[to[i]])hson[x]=to[i]; &#125;&#125;inline void dfs2(int x,int t)&#123; top[x]=t;id[x]=++cnt;wt[cnt]=w[x]; if(!hson[x])return ; dfs2(hson[x],t); for(int i=head[x];i;i=nxt[i])if(hson[x]!=to[i]&amp;&amp;to[i]!=f[x])dfs2(to[i],to[i]);&#125;inline ll queryrange(int x,int y)&#123; ll ans=0; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); ans=(ans+query(1,1,n,id[top[x]],id[x]))%p; x=f[top[x]]; &#125; if(deep[x]&gt;deep[y])swap(x,y); return (ans+query(1,1,n,id[x],id[y]))%p;&#125;inline void uprange(int x,int y,ll k)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=f[top[x]]; &#125; if(deep[x]&gt;deep[y])swap(x,y); update(1,1,n,id[x],id[y],k);&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;q,&amp;p); rep(i,1,n)scanf("%d",&amp;w[i]); rep(i,2,n)&#123;int a,b;scanf("%d%d",&amp;a,&amp;b);adde(a,b);adde(b,a);&#125; cnt=0; dfs1(q); dfs2(q,q); build(1,1,n); while(m--)&#123; int op,x,y,z; scanf("%d",&amp;op); if(op==1)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); uprange(x,y,z%p); &#125; else if(op==2)&#123; scanf("%d%d",&amp;x,&amp;y); printf("%lld\n",queryrange(x,y)); &#125; else if(op==3)&#123; scanf("%d%d",&amp;x,&amp;y); update(1,1,n,id[x],id[x]+size[x]-1,y%p); &#125; else &#123; scanf("%d",&amp;x); printf("%lld\n",query(1,1,n,id[x],id[x]+size[x]-1)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4553[线段树维护连续区间]]]></title>
    <url>%2Fhdu4553-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[链接:hdu4553[线段树维护连续区间] 题解 poj3667升级版,注意更新顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e6+7;int llen[2][N&lt;&lt;2],rlen[2][N&lt;&lt;2],mlen[2][N&lt;&lt;2],lz[2][N&lt;&lt;2],n,m,T,a,b;char op[10];inline void pushup(int o,int len ,int t)&#123; llen[t][o]=llen[t][o&lt;&lt;1];rlen[t][o]=rlen[t][o&lt;&lt;1|1]; if(llen[t][o]==len-(len&gt;&gt;1))llen[t][o]+=llen[t][o&lt;&lt;1|1]; if(rlen[t][o]==len&gt;&gt;1)rlen[t][o]+=rlen[t][o&lt;&lt;1]; mlen[t][o]=max(max(mlen[t][o&lt;&lt;1],mlen[t][o&lt;&lt;1|1]),rlen[t][o&lt;&lt;1]+llen[t][o&lt;&lt;1|1]);&#125;inline void pushdown(int o,int len,int t)&#123; if(lz[t][o]==-1)return ; lz[t][o&lt;&lt;1]=lz[t][o&lt;&lt;1|1]=lz[t][o]; llen[t][o&lt;&lt;1]=rlen[t][o&lt;&lt;1]=mlen[t][o&lt;&lt;1]=lz[t][o]?len-(len&gt;&gt;1):0; llen[t][o&lt;&lt;1|1]=rlen[t][o&lt;&lt;1|1]=mlen[t][o&lt;&lt;1|1]=lz[t][o]?len&gt;&gt;1:0; lz[t][o]=-1;&#125;inline void build(int o,int l,int r)&#123; rep(t,0,1)llen[t][o]=rlen[t][o]=mlen[t][o]=r-l+1,lz[t][o]=-1; if(l==r)return ; int mid=l+r&gt;&gt;1; build(lson); build(rson);&#125;inline void update(int o,int l,int r,int L,int R,int x,int t)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; llen[t][o]=rlen[t][o]=mlen[t][o]=x?(r-l+1):0; lz[t][o]=x; return ; &#125; pushdown(o,r-l+1,t); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R,x,t); if(R&gt;mid)update(rson,L,R,x,t); pushup(o,r-l+1,t);&#125;inline int query(int o,int l,int r,int L,int R,int x,int t)&#123; if(L==R)return L; pushdown(o,r-l+1,t); int mid=l+r&gt;&gt;1; if(mlen[t][o&lt;&lt;1]&gt;=x)return query(lson,L,mid,x,t); if(rlen[t][o&lt;&lt;1]+llen[t][o&lt;&lt;1|1]&gt;=x)return mid-rlen[t][o&lt;&lt;1]+1; return query(rson,mid+1,R,x,t);&#125;int main()&#123; scanf("%d",&amp;T); rep(k,1,T)&#123; printf("Case %d:\n",k); scanf("%d%d",&amp;n,&amp;m); build(1,1,n); while(m--)&#123; scanf("%s",op); if(op[0]=='D')&#123; scanf("%d",&amp;a); if(mlen[0][1]&gt;=a)&#123; printf("%d,let's fly\n",b=query(1,1,n,1,n,a,0)); update(1,1,n,b,b+a-1,0,0); &#125; else puts("fly with yourself"); &#125; else if(op[0]=='N')&#123; scanf("%d",&amp;a); if(mlen[0][1]&gt;=a)&#123; printf("%d,don't put my gezi\n",b=query(1,1,n,1,n,a,0)); update(1,1,n,b,b+a-1,0,0); update(1,1,n,b,b+a-1,0,1); &#125; else if(mlen[1][1]&gt;=a)&#123; printf("%d,don't put my gezi\n",b=query(1,1,n,1,n,a,1)); update(1,1,n,b,b+a-1,0,0); update(1,1,n,b,b+a-1,0,1); &#125; else puts("wait for me"); &#125; else &#123; scanf("%d%d",&amp;a,&amp;b); update(1,1,n,a,b,1,0); update(1,1,n,a,b,1,1); puts("I am the hope of chinese chengxuyuan!!"); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3667]]></title>
    <url>%2Fpoj3667%2F</url>
    <content type="text"><![CDATA[链接:poj3667 题解 线段树维护连续区间,hdu4553的削弱版,注意细节。。。因为一个小细节疯狂wa 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e6+7;int llen[N&lt;&lt;2],rlen[N&lt;&lt;2],mlen[N&lt;&lt;2],cr[N&lt;&lt;2],n,m,x,y;inline void pushup(int o,int len)&#123; llen[o]=llen[o&lt;&lt;1];rlen[o]=rlen[o&lt;&lt;1|1]; if(llen[o]==len-(len&gt;&gt;1))llen[o]+=llen[o&lt;&lt;1|1]; if(rlen[o]==len&gt;&gt;1)rlen[o]+=rlen[o&lt;&lt;1]; mlen[o]=max(max(mlen[o&lt;&lt;1],mlen[o&lt;&lt;1|1]),rlen[o&lt;&lt;1]+llen[o&lt;&lt;1|1]);&#125;inline void pushdown(int o,int len)&#123; if(cr[o]==-1)return ; cr[o&lt;&lt;1]=cr[o&lt;&lt;1|1]=cr[o]; llen[o&lt;&lt;1]=rlen[o&lt;&lt;1]=mlen[o&lt;&lt;1]=cr[o]?(len-(len&gt;&gt;1)):0; llen[o&lt;&lt;1|1]=rlen[o&lt;&lt;1|1]=mlen[o&lt;&lt;1|1]=cr[o]?len&gt;&gt;1:0; cr[o]=-1;&#125;inline void build(int o,int l,int r)&#123; llen[o]=rlen[o]=mlen[o]=r-l+1;cr[o]=-1; if(l==r)return ; int mid=l+r&gt;&gt;1; build(lson); build(rson);&#125;inline void update(int o,int l,int r,int L,int R,int x)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; cr[o]=x; llen[o]=rlen[o]=mlen[o]=cr[o]?(r-l+1):0; return ; &#125; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R,x); if(R&gt;mid)update(rson,L,R,x); pushup(o,r-l+1);&#125;inline int query(int o,int l,int r,int L,int R,int x)&#123; if(L==R)return L; pushdown(o,r-l+1); int Mid=L+R&gt;&gt;1,mid=l+r&gt;&gt;1; if(mlen[o&lt;&lt;1]&gt;=x)return query(lson,L,Mid,x); if(rlen[o&lt;&lt;1]+llen[o&lt;&lt;1|1]&gt;=x)return Mid-rlen[o&lt;&lt;1]+1; return query(rson,Mid+1,R,x);&#125;int main()&#123; //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; build(1,1,n); while(m--)&#123; scanf("%d%d",&amp;x,&amp;y); if(x==1)&#123; int b; if(mlen[1]&lt;y)puts("0"); else &#123;b=query(1,1,n,1,n,y);printf("%d\n",b);update(1,1,n,b,b+y-1,0);&#125; &#125; else &#123;scanf("%d",&amp;x);update(1,1,n,y,y+x-1,1);&#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swust2619]]></title>
    <url>%2Fswust2619%2F</url>
    <content type="text"><![CDATA[链接:swust2619 题解 树链剖分,初始置为0,毁坏一个点置1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(x) x&amp;(-x)using namespace std;const int N=2e5+50;int n,m,id[N],rt[N&lt;&lt;2],top[N],hson[N],size[N],deep[N],head[N],f[N],x,y,op,cnt;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];inline void adde(int u,int v)&#123; e[++cnt].init(v,head[u]); head[u]=cnt;&#125;void dfs1(int x)&#123; size[x]=1; for(int i=head[x],v;i;i=e[i].nxt)if((v=e[i].v)!=f[x])&#123; f[v]=x; deep[v]=deep[x]+1; dfs1(v); size[x]+=size[v]; if(size[hson[x]]&lt;size[v])hson[x]=v; &#125;&#125;void dfs2(int x,int t)&#123; top[x]=t;id[x]=++cnt; if(hson[x])dfs2(hson[x],t); for(int i=head[x],v;i;i=e[i].nxt)if(hson[x]!=(v=e[i].v)&amp;&amp;v!=f[x])dfs2(v,v);&#125;inline void update(int x,int y)&#123;for(register int i=x;i&lt;=n;i+=lowbit(i))rt[i]+=y;&#125;inline int query(int x)&#123;int ans=0;for(register int i=x;i;i-=lowbit(i))ans+=rt[i];return ans;&#125;inline int check(int x,int y)&#123; while(top[x]!=top[y])&#123; if(deep[top[x]]&lt;deep[top[y]])swap(x,y); if(query(id[x])-query(id[top[x]]-1))return 0; x=f[top[x]]; &#125; if(id[x]&lt;id[y])swap(x,y); return query(id[x])-query(id[y]-1)==0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,2,n)&#123; scanf("%d%d",&amp;x,&amp;y); adde(x,y);adde(y,x); &#125; dfs1(1);cnt=0; dfs2(1,1); while(m--)&#123; scanf("%d",&amp;op); if(op==1)&#123; scanf("%d%d",&amp;x,&amp;y); puts(check(x,y)?"YES":"NO"); &#125; else if(op==2)&#123;scanf("%d",&amp;x);update(id[x],-1);&#125; else &#123;scanf("%d",&amp;x);update(id[x],1);&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4614]]></title>
    <url>%2Fhdu4614%2F</url>
    <content type="text"><![CDATA[链接:hdu4614 题解 区间修改线段树,注意是从0开始,具体看代码吧,挺简单的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long #define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e5;int rt[N&lt;&lt;2],lz[N&lt;&lt;2],n,m,T;inline void pushup(int o)&#123;rt[o]=rt[o&lt;&lt;1]+rt[o&lt;&lt;1|1];&#125;inline void pushdown(int o,int len)&#123; if(lz[o]==-1)return ; lz[o&lt;&lt;1]=lz[o&lt;&lt;1|1]=lz[o]; if(!lz[o])&#123; rt[o&lt;&lt;1]=len-(len&gt;&gt;1); rt[o&lt;&lt;1|1]=len&gt;&gt;1; &#125; else rt[o&lt;&lt;1]=rt[o&lt;&lt;1|1]=0;; lz[o]=-1;&#125;inline void build(int o,int l,int r)&#123; lz[o]=-1; if(l==r)&#123;rt[o]=1;return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123;rt[o]=0;lz[o]=1;return ;&#125; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(lson,L,R); if(R&gt;mid)update(rson,L,R); pushup(o);&#125;inline int clear(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123;lz[o]=0;int t=rt[o];rt[o]=r-l+1;return rt[o]-t;&#125; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=clear(lson,L,R); if(R&gt;mid)ans+=clear(rson,L,R); pushup(o); return ans;&#125;inline int query(int o,int l,int r,int L,int R)&#123; if(L&gt;r||R&lt;l)return 0; if(L&lt;=l&amp;&amp;R&gt;=r)return rt[o]; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1,ans=0; if(L&lt;=mid)ans+=query(lson,L,R); if(R&gt;mid)ans+=query(rson,L,R); return ans;&#125;inline int ask(int o,int l,int r,int L,int R,int x)&#123; if(l==r)return l; pushdown(o,r-l+1); int mid=l+r&gt;&gt;1; int t=query(lson,L,R); if(x&lt;=t)return ask(lson,L,R,x); else return ask(rson,L,R,x-t);&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); build(1,1,n); while(m--)&#123; int op,l,r; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1)&#123; int t=query(1,1,n,l+1,n); if(!t)puts("Can not put any one."); else &#123; l=ask(1,1,n,l+1,n,1); r=ask(1,1,n,l,n,min(t,r)); printf("%d %d\n",l-1,r-1); update(1,1,n,l,r); &#125; &#125; else printf("%d\n",clear(1,1,n,l+1,r+1)); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3974]]></title>
    <url>%2Fhdu3974%2F</url>
    <content type="text"><![CDATA[链接:hdu3974 题解 可能会有人想要用不压缩的并查集去做,显然不可以。 正解是用线段树维护时间戳,给x分配任务y实际上就是把in[x]—out[x]这段置为y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e5;int rt[N&lt;&lt;2],in[N],out[N],n,m,cnt,T;vector&lt;int&gt; g[N],em[N];char c;void init()&#123;rep(i,1,n)&#123;g[i].clear();em[i].clear();&#125;&#125;inline void dfs(int x)&#123; in[x]=++cnt; for(int i=0;i&lt;g[x].size();++i)dfs(g[x][i]); out[x]=cnt;&#125;inline void pushdown(int o)&#123;rt[o&lt;&lt;1]=rt[o&lt;&lt;1|1]=rt[o];rt[o]=-1;&#125;inline void build(int o,int l,int r)&#123; rt[o]=-1; if(l==r)return ; int mid=l+r&gt;&gt;1; build(lson); build(rson);&#125;inline void update(int o,int l,int r,int L,int R,int x)&#123; if(L==l&amp;&amp;R==r)&#123;rt[o]=x;return;&#125; if(rt[o]!=-1)pushdown(o); int mid=l+r&gt;&gt;1; if(R&lt;=mid)update(lson,L,R,x); else if(L&gt;mid)update(rson,L,R,x); else &#123; update(lson,L,mid,x); update(rson,mid+1,R,x); &#125;&#125;inline int query(int o,int l,int r,int x)&#123; if(l==r)return rt[o]; if(rt[o]!=-1)pushdown(o); int mid=l+r&gt;&gt;1; if(x&lt;=mid)return query(lson,x); else return query(rson,x);&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; rep(cs,1,T)&#123; cnt=0; cin&gt;&gt;n; build(1,1,n); init(); rep(i,1,n-1)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; g[y].push_back(x); em[x].push_back(y); &#125; rep(i,1,n)if(em[i].size()==0)dfs(i); cin&gt;&gt;m; cout&lt;&lt;"Case #"&lt;&lt;cs&lt;&lt;":"&lt;&lt;endl; while(m--)&#123; char c;cin&gt;&gt;c; if(c=='C')&#123; int x;cin&gt;&gt;x; cout&lt;&lt;query(1,1,n,in[x])&lt;&lt;endl; &#125; else &#123;int x,y;cin&gt;&gt;x&gt;&gt;y; update(1,1,n,in[x],out[x],y); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1540]]></title>
    <url>%2Fhdu1540%2F</url>
    <content type="text"><![CDATA[链接:hdu1540 题解 线段树维护连续区间,状态维护有点麻烦。。。 有个巨坑。。。多组输入。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,rusing namespace std;const int N=1e5;int llen[N&lt;&lt;2],rlen[N&lt;&lt;2],mlen[N&lt;&lt;2],d[N];int n,m,t,cnt;char c;inline void pushup(int o,int l,int r)&#123; int mid=l+r&gt;&gt;1; llen[o]=llen[o&lt;&lt;1]; rlen[o]=rlen[o&lt;&lt;1|1]; mlen[o]=max(max(mlen[o&lt;&lt;1],mlen[o&lt;&lt;1|1]),rlen[o&lt;&lt;1]+llen[o&lt;&lt;1|1]); if(llen[o&lt;&lt;1]==mid-l+1)llen[o]+=llen[o&lt;&lt;1|1]; if(rlen[o&lt;&lt;1|1]==r-mid)rlen[o]+=rlen[o&lt;&lt;1];&#125;inline void build(int o,int l,int r)&#123; llen[o]=rlen[o]=mlen[o]=r-l+1; if(l==r)return; int mid=l+r&gt;&gt;1; build(lson); build(rson);&#125;inline void update(int o,int l,int r,int x,int c)&#123; if(l==r)&#123;llen[o]=rlen[o]=mlen[o]=c;return ;&#125; int mid=l+r&gt;&gt;1; if(x&lt;=mid)update(lson,x,c); else update(rson,x,c); pushup(o,l,r);&#125;inline int query(int o,int l,int r,int x)&#123; if(l==r||!mlen[o]||mlen[o]==r-l+1)return mlen[o]; int mid=l+r&gt;&gt;1; if(x&lt;=mid)&#123; if(x&gt;mid-rlen[o&lt;&lt;1])return query(lson,x)+query(rson,mid+1); else return query(lson,x); &#125; else &#123; if(x&lt;=mid+llen[o&lt;&lt;1|1])return query(lson,mid)+query(rson,x); else return query(rson,x); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; build(1,1,n); while(m--)&#123; cin&gt;&gt;c; if(c=='D')&#123;cin&gt;&gt;t;d[++cnt]=t;update(1,1,n,t,0);&#125; else if(c=='Q')&#123;cin&gt;&gt;t;cout&lt;&lt;query(1,1,n,t)&lt;&lt;endl;&#125; else &#123;update(1,1,n,d[cnt--],1);&#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4027]]></title>
    <url>%2Fhdu4027%2F</url>
    <content type="text"><![CDATA[链接:hdu4027 题解 注意区间里如果都是1就不用更新了,然后坑点是输入会有l&gt;r的情况。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,r#define LL long longusing namespace std;const int N=1e6;LL rt[N&lt;&lt;2];int n,m,cnt;inline void pushup(int o)&#123;rt[o]=rt[o&lt;&lt;1]+rt[o&lt;&lt;1|1];&#125;inline void build(int o,int l,int r)&#123; if(l==r)&#123;scanf("%lld",&amp;rt[o]);return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); pushup(o);&#125;inline void update(int o,int l,int r,int ll,int rr)&#123; if(l==r)&#123;rt[o]=sqrt(rt[o]);return ;&#125; if(rt[o]==r-l+1)return ; int mid=l+r&gt;&gt;1; if(ll&lt;=mid)update(lson,ll,rr); if(rr&gt;mid)update(rson,ll,rr); pushup(o);&#125;inline LL query(int o,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;rr&gt;=r)return rt[o]; int mid=l+r&gt;&gt;1; LL ans=0; if(ll&lt;=mid)ans+=query(lson,ll,rr); if(rr&gt;mid)ans+=query(rson,ll,rr); return ans;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; printf("Case #%d:\n",++cnt); build(1,1,n); scanf("%d",&amp;m); while(m--)&#123; int op,x,y; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if(x&gt;y)swap(x,y); if(op)printf("%lld\n",query(1,1,n,x,y)); else update(1,1,n,x,y); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMQ]]></title>
    <url>%2FRMQ%2F</url>
    <content type="text"><![CDATA[RMQ算法 是一个快速求区间最值的离线算法，预处理时间复杂度O（n*log(n)），查询O(1)，所以是一个很快速的算法， 当然这个问题用线段树同样能够解决。 算法分析 这个算法其实就是dp+位运算,dp[i][j]表示$i到i+2^j-1$这个区间的最值, 因为状态定义的关系,我们可以很方便的把d[i][j]表示的区间划分为两部分, 分别为$i到i+2^{j-1}-1$以及$i+2^{j-1}$到$i+2^j-1$ 这两个部分,那么转移方程也就很容易出来了 dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]); 代码 1234567891011121314151617void rmq()&#123; int end=log(n+0.0)/log(2.0); rep(i,1,n)mx[i][0]=mn[i][0]=a[i]; rep(j,1,end)&#123; int end_i=n-(1&lt;&lt;j)+1; rep(i,1,end_i)&#123; mx[i][j]=max(mx[i][j-1],mx[i+(1&lt;&lt;j-1)][j-1]); mn[i][j]=min(mn[i][j-1],mn[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ask(int l,int r)&#123; int k=log(r-l+1.0)/log(2.0); int ans1=max(mx[l][k],mx[r-(1&lt;&lt;k)+1][k]); int ans2=min(mn[l][k],mn[r-(1&lt;&lt;k)+1][k]); return ans1-ans2;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3264]]></title>
    <url>%2Fpoj3264%2F</url>
    <content type="text"><![CDATA[链接:poj3264 题解 区间最值,先上线段树做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson o&lt;&lt;1,l,mid#define rson o&lt;&lt;1|1,mid+1,r#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;typedef pair&lt;int,int&gt; s;const int N=1e6;s rt[N&lt;&lt;2];int n,m,a[N];inline void build(int o,int l,int r)&#123; if(l==r)&#123;rt[o]=s(a[l],a[l]);return ;&#125; int mid=l+r&gt;&gt;1; build(lson); build(rson); rt[o]=s(max(rt[o&lt;&lt;1].first,rt[o&lt;&lt;1|1].first),min(rt[o&lt;&lt;1].second,rt[o&lt;&lt;1|1].second));&#125;inline int query(int o,int l,int r,int ll,int rr,int op)&#123; if(l==ll&amp;&amp;r==rr)return op?rt[o].first:rt[o].second; int mid=l+r&gt;&gt;1; if(rr&lt;=mid)return query(lson,ll,rr,op); else if(ll&gt;mid) return query(rson,ll,rr,op); else &#123; int x=query(lson,ll,mid,op); int y=query(rson,mid+1,rr,op); return op?max(x,y):min(x,y); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%d",&amp;a[i]); build(1,1,n); rep(i,1,m)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int ans=query(1,1,n,x,y,1); ans-=query(1,1,n,x,y,0); printf("%d\n",ans); &#125; return 0;&#125; RMQ做法 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;int mx[N][100],mn[N][100],a[N],n,m;void rmq()&#123; int end=log(n+0.0)/log(2.0); rep(i,1,n)mx[i][0]=mn[i][0]=a[i]; rep(j,1,end)&#123; int end_i=n-(1&lt;&lt;j)+1; rep(i,1,end_i)&#123; mx[i][j]=max(mx[i][j-1],mx[i+(1&lt;&lt;j-1)][j-1]); mn[i][j]=min(mn[i][j-1],mn[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125;&#125;int ask(int l,int r)&#123; int k=log(r-l+1.0)/log(2.0); int ans1=max(mx[l][k],mx[r-(1&lt;&lt;k)+1][k]); int ans2=min(mn[l][k],mn[r-(1&lt;&lt;k)+1][k]); return ans1-ans2;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%d",&amp;a[i]); rmq(); while(m--)&#123;int x,y;scanf("%d%d",&amp;x,&amp;y);printf("%d\n",ask(x,y));&#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj1610]]></title>
    <url>%2Fzoj1610%2F</url>
    <content type="text"><![CDATA[链接:zoj1610 题解 和poj2528差不多,但是不需要离散化. 注意,这里染的不是点是区间,比如0 1 1, 1 2 1这组数据输出应该是1 2,解决方法是所有左标+1 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e5;const int M=8000;int rt[N&lt;&lt;2],num[N],n,m,nc;inline void pushdown(int o)&#123;rt[o&lt;&lt;1]=rt[o&lt;&lt;1|1]=rt[o];rt[o]=-1;&#125;void update(int o,int l,int r,int ll,int rr,int c)&#123; if(ll&lt;=l&amp;&amp;rr&gt;=r)&#123;rt[o]=c;return ;&#125; if(rt[o]!=-1)pushdown(o); int mid=l+r&gt;&gt;1; if(ll&lt;=mid)update(o&lt;&lt;1,l,mid,ll,rr,c); if(rr&gt;mid)update(o&lt;&lt;1|1,mid+1,r,ll,rr,c);&#125;void query(int o,int l,int r)&#123; if(l==r)&#123;if(rt[o]&gt;=0&amp;&amp;rt[o]!=nc)num[rt[o]]++;nc=rt[o];return ;&#125; if(rt[o]!=-1)pushdown(o); int mid=l+r&gt;&gt;1; query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r);&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; nc=-1; memset(rt,-1,sizeof(rt)); memset(num,0,sizeof(num)); rep(i,1,n)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); update(1,1,M,a+1,b,c); &#125; query(1,1,M); rep(i,0,M)if(num[i])printf("%d %d\n",i,num[i]); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1698]]></title>
    <url>%2Fhdu1698%2F</url>
    <content type="text"><![CDATA[链接:hdu1698 题解 区间修改线段树模板题,注意输出格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&lt;=y;++i)using namespace std;const int N=1e6;int tr[N&lt;&lt;2],lz[N&lt;&lt;2],n,m,T;inline void pushdown(int o,int l,int r)&#123; if(l==r)&#123;tr[o]=lz[o];&#125; lz[o&lt;&lt;1|1]=lz[o&lt;&lt;1]=lz[o]; int mid=l+r&gt;&gt;1; tr[o&lt;&lt;1]=lz[o]*(mid-l+1); tr[o&lt;&lt;1|1]=lz[o]*(r-mid); lz[o]=0;&#125;void build(int o,int l,int r)&#123; if(l==r)&#123;tr[o]=1;return ;&#125; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;void update(int o,int l,int r,int ll,int rr,int c)&#123; if(ll&lt;=l&amp;&amp;rr&gt;=r)&#123;lz[o]=c,tr[o]=c*(r-l+1);return ;&#125; if(lz[o])pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(ll&lt;=mid)update(o&lt;&lt;1,l,mid,ll,rr,c); if(rr&gt;mid)update(o&lt;&lt;1|1,mid+1,r,ll,rr,c); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;int main()&#123; scanf("%d",&amp;T); rep(k,1,T)&#123; memset(lz,0,sizeof(lz)); scanf("%d%d",&amp;n,&amp;m); build(1,1,n); rep(i,1,m)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); update(1,1,n,a,b,c); &#125; printf("Case %d: The total value of the hook is %d.\n",k,tr[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2528]]></title>
    <url>%2Fpoj2528%2F</url>
    <content type="text"><![CDATA[链接:poj2528 题解 线段树+离散化,注意离散化的时候在相邻距离大于1的点之间要插入一个点,避免覆盖问题,比如1-10 1-4 6-10 如果不加点,答案 是2,显然不正确 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e6;int hash[N],rt[N&lt;&lt;2],x[N],y[N],a[N],n,nn,m,T,ans;void pushdown(int o)&#123;rt[o&lt;&lt;1]=rt[o&lt;&lt;1|1]=rt[o];rt[o]=-1;&#125;void update(int o,int l,int r,int ll,int rr,int c)&#123; if(ll&lt;=l&amp;&amp;rr&gt;=r)&#123;rt[o]=c;return ;&#125; if(rt[o]!=-1)pushdown(o); int mid=l+r&gt;&gt;1; if(ll&lt;=mid)update(o&lt;&lt;1,l,mid,ll,rr,c); if(rr&gt;mid)update(o&lt;&lt;1|1,mid+1,r,ll,rr,c);&#125;void query(int o,int l,int r)&#123; if(l==r)&#123;if(rt[o]!=-1&amp;&amp;!hash[rt[o]])ans++,hash[rt[o]]=1;return ;&#125; if(rt[o]!=-1)pushdown(o); int mid=l+r&gt;&gt;1; query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r);&#125;int ask(int c)&#123; int l=1,r=m; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(a[mid]==c)return mid; if(a[mid]&lt;c)l=mid+1; else r=mid-1; &#125; return l;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; m=1;ans=nn=0; memset(hash,0,sizeof(hash)); memset(rt,-1,sizeof(rt)); scanf("%d",&amp;n); rep(i,1,n)&#123;scanf("%d%d",&amp;x[i],&amp;y[i]);a[++nn]=x[i];a[++nn]=y[i];&#125; sort(a,a+nn); rep(i,2,nn-1)if(a[i]!=a[i-1])a[++m]=a[i]; repd(i,m,1)if(a[i]-a[i-1]&gt;1)a[++m]=a[i]-1; sort(a+1,a+m+1); rep(i,1,n)&#123; int l=ask(x[i]); int r=ask(y[i]); update(1,1,m,l,r,i); &#125; query(1,1,m); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3026]]></title>
    <url>%2Fpoj3026%2F</url>
    <content type="text"><![CDATA[链接:poj3026 题解 这题很有意思,不用管A,S,当成一样的就好,跑一遍bfs跑出所有A的相关信息,然后套模板,然而我疯狂WA,原因是输入有坑,巨坑, 详情看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=107;const int inf=0x3f3f3f3f;typedef pair&lt;int,int&gt; s;int T,n,m,dis[N][N],d[N][N],cnt,t[N][N],vis[N],ds[N];int dx[5]=&#123;0,-1,1,0,0&#125;;int dy[5]=&#123;0,0,0,-1,1&#125;;char g[107][107];queue&lt;s&gt; q;void bfs(int a,int b)&#123; while(!q.empty())q.pop(); memset(t,-1,sizeof(t)); q.push(s(a,b)); t[a][b]=0; while(!q.empty())&#123; int x=q.front().first; int y=q.front().second; if(d[x][y])dis[d[a][b]][d[x][y]]=t[x][y]; q.pop(); rep(i,1,4)&#123; int nx=x+dx[i]; int ny=y+dy[i]; if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m||g[nx][ny]=='#'||t[nx][ny]!=-1)continue; t[nx][ny]=t[x][y]+1; q.push(s(nx,ny)); &#125; &#125;&#125;int prim(int n)&#123; int ans=0; memset(ds,0,sizeof(ds)); memset(vis,0,sizeof(vis)); vis[1]=1; rep(i,1,n)ds[i]=dis[1][i]; rep(i,2,n)&#123; int minm=inf,p; rep(j,1,n)if(!vis[j]&amp;&amp;ds[j]&lt;minm)minm=ds[j],p=j; if(minm==inf)return -1; ans+=minm; vis[p]=1; rep(j,1,n)if(!vis[j]&amp;&amp;ds[j]&gt;dis[p][j])ds[j]=dis[p][j]; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; char c; cnt=0; scanf("%d%d",&amp;m,&amp;n); memset(d,0,sizeof(d)); do&#123; //坑点 c=getchar(); &#125;while(c!='\n'); rep(i,1,n)&#123; gets(g[i]+1); rep(j,1,m)if(g[i][j]=='S'||g[i][j]=='A')d[i][j]=++cnt; &#125; rep(i,1,n)rep(j,1,m)if(d[i][j])bfs(i,j); printf("%d\n",prim(cnt)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgP2862[USACO06JAN]]]></title>
    <url>%2FlgP2862-USACO06JAN%2F</url>
    <content type="text"><![CDATA[链接:lgP2862[USACO06JAN] 题解 500的N，直接枚举左上角和长，时间复杂度$O(N^3)$，可以过，但是很显然长度是可以二分处理的于是复杂度为$O(N^2log_2N)$ 注意题目描述，最后答案要+1，并且判断的时候也有坑。wa了一下午，不知道哪里写挂了，一下午都没找出来，最后重写一遍 AC。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3;struct node&#123; int x,y;&#125;a[N];int n,m,t[N],l,r=1000000;inline int cmp(node x,node y)&#123;return x.x&lt;y.x;&#125;int ok(int l,int r,int L)&#123; if(r-l+1&lt;m)return 0; int tp=0; rep(i,l,r)t[++tp]=a[i].y; sort(t+1,t+tp+1); rep(i,m,tp)if(t[i]-t[i-m+1]&lt;=L)return 1; return 0;&#125;int judge(int L)&#123; int tp=1; rep(i,1,n)&#123; if(a[i].x-a[tp].x&gt;L&amp;&amp;ok(tp,i-1,L))return 1; while(a[i].x-a[tp].x&gt;L)tp++; &#125; return ok(tp,n,L);&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); rep(i,1,n)scanf("%d%d",&amp;a[i].x,&amp;a[i].y); sort(a+1,a+n+1,cmp); while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(judge(mid))r=mid; else l=mid+1; &#125; printf("%d",l+1); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgP2746[USACO5.3]校园网]]></title>
    <url>%2FlgP2746-USACO5-3-%E6%A0%A1%E5%9B%AD%E7%BD%91%2F</url>
    <content type="text"><![CDATA[链接:lgP2746[USACO5.3]校园网 题解 显然分发学校向接受学校连一条边，然后缩点。 子任务A显然就是入度为零的缩点个数 子任务B则是入度为零和出度为零的缩点个数的最大值 有一个坑点，只有一个强连通分量的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define rep(i,x,y) for(register int i=x;i&lt;=y;++i) #define repd(i,x,y) for(register int i=x;i&gt;=y;--i) #define ll long long using namespace std; const int N=1e5; struct node&#123; int v,nxt; inline void init(int x,int y)&#123;v=x; nxt=y;&#125; &#125;e[N]; int head[N],dfn[N],low[N],cnt,bl[N],du[N][2],n,m,in[N],stck[N],idx,tot,x,ans,res[2]; inline void adde(int x,int y)&#123;e[cnt].init(y,head[x]);head[x]=cnt++;&#125; void tarjan(int u)&#123; in[u]=1; stck[++idx]=u; dfn[u]=low[u]=++tot; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123;tarjan(v); low[u]=min(low[u],low[v]);&#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; cnt++; do&#123;in[stck[idx]]=0; bl[stck[idx--]]=cnt;&#125;while(u!=stck[idx+1]); &#125; &#125; int main()&#123; memset(head,-1,sizeof(head)); scanf("%d",&amp;n); rep(i,1,n)while(~scanf("%d",&amp;x)&amp;&amp;x)&#123; adde(i,x); &#125;cnt=0; rep(i,1,n)if(!dfn[i])tarjan(i); rep(u,1,n)for(int i=head[u],v;i!=-1;i=e[i].nxt)if(bl[v=e[i].v]!=bl[u])&#123; du[bl[u]][0]++; du[bl[v]][1]++; &#125; rep(i,1,cnt)&#123;ans+=(du[i][1]==0); res[0]+=(du[i][0]==0);res[1]+=(du[i][1]==0);&#125; printf("%d\n%d",ans,cnt!=1?max(res[0],res[1]):0); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgP2341[HAOI2006]受欢迎的牛]]></title>
    <url>%2FlgP2341-HAOI2006-%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[链接:lgP2341[HAOI2006]受欢迎的牛 题解 爱慕可以传递，很自然想到缩点，所以只需要找到可以被所有缩点遍历到的那个缩点，自然想到出度为零的缩点就是我们要求的 但是如果有两个这样的缩点，自然无解，然后很迷人的操作WA 3发 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];int head[N],cnt,n,m,dfn[N],low[N],tot,ans[N],idx,stck[N],in[N],lg[N],du[N],tp;inline void adde(int x,int y)&#123;e[cnt].init(y,head[x]);head[x]=cnt++;&#125;void tarjan(int u)&#123; in[u]=1; stck[++idx]=u; dfn[u]=low[u]=++tot; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; int x; cnt++; do&#123;in[idx]=0;lg[stck[idx--]]=cnt;ans[cnt]++;&#125;while(stck[idx+1]!=u); &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)&#123;int x,y;scanf("%d%d",&amp;x,&amp;y);adde(x,y);&#125;cnt=0; rep(i,1,n)if(!dfn[i])tarjan(i); rep(i,1,n)for(int j=head[i];j!=-1;j=e[j].nxt)if(lg[e[j].v]!=lg[i])du[lg[i]]++; rep(i,1,cnt)if(!du[i])&#123;if(tp)&#123;puts("0");return 0;&#125; tp=i;&#125; printf("%d",ans[tp]); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgP1407[国家集训队]稳定婚姻]]></title>
    <url>%2FlgP1407-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%2F</url>
    <content type="text"><![CDATA[链接:lgP1407[国家集训队]稳定婚姻 题解 尝试将所有丈夫和夫妻连起来，表示他们之间存在过关系，那么显然无论是之前还是现在，他们总有关系，所以这两种情况是一样的 那么怎么判断是否安全呢。 由于已经将所有存在过关系的丈夫和夫妻连起来了，那么显然如果如果丈夫和夫妻在一个环里，那么不安全 注意连接的时候一定要是男-&gt;女-&gt;男-&gt;女这样链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];string a,b;map&lt;string,int&gt; id;int n,m,bl[N],head[N],cnt,in[N],dfn[N],low[N],tot,stck[N],idx;inline void adde(int x,int y)&#123;e[cnt].init(y,head[x]);head[x]=cnt++;&#125;void tarjan(int u)&#123; in[u]=1; low[u]=dfn[u]=++tot; stck[++idx]=u; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; cnt++; do&#123; bl[stck[idx--]]=cnt; in[stck[idx+1]]=0; &#125;while(stck[idx+1]!=u); &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf("%d",&amp;n); rep(i,1,n)&#123;cin&gt;&gt;a&gt;&gt;b;id[a]=i;id[b]=i+n;adde(i,i+n);&#125; scanf("%d",&amp;m); rep(i,1,m)&#123;cin&gt;&gt;a&gt;&gt;b;adde(id[b],id[a]);&#125; cnt=0; rep(i,1,2*n)if(!dfn[i])tarjan(i); rep(i,1,n)if(bl[i]==bl[i+n])puts("Unsafe");else puts("Safe"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2863[USACO06JAN]牛的舞会]]></title>
    <url>%2Flg2863-USACO06JAN-%E7%89%9B%E7%9A%84%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[链接:lg2863[USACO06JAN]牛的舞会 题解 tarjan模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];int dfn[N],low[N],in[N],ans,cnt,head[N],n,m,stck[N],indx;inline void adde(int a,int b)&#123; e[cnt].init(b,head[a]); head[a]=cnt++;&#125;void tarjan(int u)&#123; in[u]=1; low[u]=dfn[u]=++cnt; stck[++indx]=u; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123;tarjan(v); low[u]=min(low[u],low[v]);&#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(low[u]==dfn[u])&#123; int k=0; do&#123; in[indx]=0; --indx; k++; &#125;while(stck[indx+1]!=u); if(k&gt;1)ans++; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(head,-1,sizeof(head)); rep(i,1,m)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); adde(x,y); //adde(y,x); &#125; cnt=0; rep(i,1,n)&#123; if(!dfn[i])tarjan(i); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1963[NOI2009]变换序列]]></title>
    <url>%2Flg1963-NOI2009-%E5%8F%98%E6%8D%A2%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[链接:lg1963[NOI2009]变换序列 题解这题难点在于要求字典序最小的匹配 首先建图的时候要先连大的点,因为处理的时候,是倒序 匈牙利算法是当前点无法匹配的时候尝试更改之前匹配的点,所以倒着匈牙利就可以保证小的点优先匹配小的点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];int mark[N],n,vis[N],head[N],cnt,ans;inline int solve(int x)&#123;if(x&lt;0)x+=n; if(x&gt;n-1)x-=n; return x+n;&#125;void add(int u,int x)&#123; int v1=solve(u+x),v2=solve(u-x); if(v1&lt;v2)swap(v1,v2); e[++cnt].init(v1,head[u]);head[u]=cnt; e[++cnt].init(v2,head[u]);head[u]=cnt;&#125;int find(int x)&#123; vis[x]=1; for(int i=head[x],v;i;i=e[i].nxt)if(!vis[v=e[i].v])&#123; vis[v]=1; if(!mark[v]||find(mark[v]))&#123; mark[v]=x;mark[x]=v; return 1; &#125; &#125; return 0;&#125;int r()&#123; repd(i,n-1,0)if(!mark[i])&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; return ans==n;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,0,n-1)&#123;int x;scanf("%d",&amp;x); add(i,x);&#125; if(r())rep(i,0,n-1)printf("%d ",mark[i]-n); else puts("No Answer"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛13]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B13%2F</url>
    <content type="text"><![CDATA[链接:牛客练习赛13 A幸运数字1 幸运数字是只含4,7的数字,给一个字符串,求出现次数最多的且是幸运数字的子串 题解 没啥说的,答案只有4,7,-1三种可能B幸运数字2 next(x)表示比x大的第一个幸运数字,给定l,r,求出next(l)+…+next(r)题解 我的做法是跑出所有幸运数字，1-1e10中最多2^9个，然后二分l和r在数组中的位置，累加答案 实际上不需要二分,对于幸运数字i来说,满足next(x)==i的只有上一个幸运数字y的后一个数y+1到i的那些 不多说,上代码 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll c[N],len,ans,l,r;int main()&#123; rep(i,1,10)rep(j,0,(1&lt;&lt;i)-1)&#123; ll num=0; rep(k,0,i-1)if(j&gt;&gt;k&amp;1)num=num*10+4;else num=num*10+7; c[++len]=num; &#125; sort(c+1,c+len+1); scanf("%d%d",&amp;l,&amp;r); for(int i=1;l&lt;=r;++i)if(c[i]&gt;=l)ans+=(ll)(min(r,c[i])-l+1)*c[i],l=c[i]+1; printf("%lld",ans); return 0;&#125; C幸运数字3]]></content>
      <categories>
        <category>比赛</category>
        <category>牛客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poj1988]]></title>
    <url>%2Fpoj1988%2F</url>
    <content type="text"><![CDATA[链接:poj1988 Description Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations: moves and counts. In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. Write a program that can verify the results of the game. Input Line 1: A single integer, P Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X. Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. Output Print the output from each of the count operations in the same order as the input file. Sample Input 6 M 1 6 C 1 M 2 4 M 2 6 C 3 C 4Sample Output 1 0 2题解 带权并查集，和lg1196差不多 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regiser int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e5+7;int f[N],rl[N],n,a,b,nm[N];char c;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]+=rl[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); f[b]=a; rl[b]=nm[a]; //更新x所在列头 nm[a]+=nm[b]; //更新b的长度 //nm[a]=0; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,1,30000)f[i]=i,nm[i]=1; rep(i,1,n)&#123; cin&gt;&gt;c&gt;&gt;a; if(c=='M')&#123;cin&gt;&gt;b;un(a,b);&#125; else cout&lt;&lt;nm[find(a)]-rl[a]-1&lt;&lt;endl; &#125; return 0;&#125; 更厉害的 看了大神的博客，发现，根本不需要多开一个rl数组保存列长度 果然是太弱了 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;int f[N],dis[N],n,a,b;char c;int find(int x)&#123; if(f[x]&lt;0)return x; int t=find(f[x]); dis[x]+=dis[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; dis[y]=(-f[x]); f[x]+=f[y]; f[y]=x; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; memset(f,-1,sizeof(f)); rep(i,1,n)&#123; cin&gt;&gt;c&gt;&gt;a; if(c=='M')&#123;cin&gt;&gt;b; un(a,b);&#125; else cout&lt;&lt;f[find(a)]*(-1)-dis[a]-1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1811]]></title>
    <url>%2Fhdu1811%2F</url>
    <content type="text"><![CDATA[链接:hdu1811 Description 自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。 为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还 响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。 终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。 同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是”A &gt; B”,”A = B”,”A &lt; B”，分别表示A的 Rating高于B,等于B,小于B。 现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出”OK”。否则就请你 判断出错的原因，到底是因为信息不完全（输出”UNCERTAIN”），还是因为这些信息中包含冲突（输出”CONFLICT”）。 注意，如果信息中同时包含冲突且信息不完全，就输出”CONFLICT”。 Input 本题目包含多组测试，请处理到文件结束。 每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),分别表示要排名的人数以及得到的关系数。 接下来有M行，分别表示这些关系Output 对于每组测试，在一行里按题目要求输出Sample Input 3 3 0 &gt; 1 1 &lt; 2 0 &gt; 2 4 4 1 = 2 1 &gt; 3 2 &gt; 0 0 &gt; 1 3 3 1 &gt; 0 1 &gt; 2 2 &lt; 1Sample Output OK CONFLICT UNCERTAIN题解 等于的话放在同一个集合，然后对集合建图。 入度等于0的点多于1个说明信息不完整 有环说明冲突 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];struct nd&#123; int a,b; char c;&#125;mes[N];int head[N],n,m,f[N],cnt,in[N],flag,sum;queue&lt;int&gt; q;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;inline int un(int x,int y)&#123;x=find(x); y=find(y); f[x]=y; return x!=y;&#125;inline void add(int a,int b)&#123; e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int top()&#123; rep(i,0,n-1)if(!in[i]&amp;&amp;find(i)==i)q.push(i); while(!q.empty())&#123; if(q.size()&gt;1)flag=1; int u=q.front(); q.pop();sum--; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int t=e[i].v; in[t]--; if(in[t]==0)q.push(t); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; flag=0;sum=n; cnt=0; rep(i,0,n)f[i]=i; memset(in,0,sizeof(in)); memset(head,-1,sizeof(head)); rep(i,1,m)&#123; cin&gt;&gt;mes[i].a&gt;&gt;mes[i].c&gt;&gt;mes[i].b; if(mes[i].c=='=')&#123;if(un(mes[i].a,mes[i].b))sum--;&#125; &#125; rep(i,1,m)if(mes[i].c!='=')&#123; int a=find(mes[i].a); int b=find(mes[i].b); if(mes[i].c=='&gt;')&#123;add(a,b);in[b]++;&#125; else &#123;add(b,a); in[a]++;&#125; &#125; top(); if(sum&gt;0)cout&lt;&lt;"CONFLICT"&lt;&lt;endl; else if(flag)cout&lt;&lt;"UNCERTAIN"&lt;&lt;endl; else cout&lt;&lt;"OK"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1196]]></title>
    <url>%2Flg1196%2F</url>
    <content type="text"><![CDATA[链接:lg1196 Description 公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。 宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山 河集团点名将杨威利组织麾下三万艘战舰迎敌。 杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成30000列，每列依次 编号为1, 2, …,30000。之后，他把自己的战舰也依次编号为1, 2, …, 30000，让第i号战舰处于第i列(i = 1, 2, …, 30000)，形成 “一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻 击。合并指令为M i j，含义为第i号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显 然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增 大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。 在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：C i j。该指令意思是， 询问电脑，杨威利的第i号战舰与第j号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。 作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。 最终的决战已经展开，银河的历史又翻过了一页…… Input 以下有T行，每行有一条指令。指令有两种格式： M i j ：i和j是两个整数（1&lt;=i , j&lt;=30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指 令，并且保证第i号战舰与第j号战舰不在同一列。 C i j ：i和j是两个整数（1&lt;=i , j&lt;=30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。Output 输出文件为galaxy.out。你的程序应当依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息； 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i 号战舰与第j 号战舰之间布置的战舰数 目。如果第i 号战舰与第j号战舰当前不在同一列上，则输出-1。Sample Input 4 M 2 3 C 1 2 M 2 4 C 4 2Sample Output -1 1题解 简单的并查集，维护一个队列长度，x所在列头 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regiser int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e5+7;int f[N],rl[N],n,a,b,nm[N];char c;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]+=rl[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); f[a]=b; rl[a]+=nm[b]; //更新x所在列头 nm[b]+=nm[a]; //更新b的长度 nm[a]=0; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,1,30000)f[i]=i,nm[i]=1; rep(i,1,n)&#123; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; if(c=='M')un(a,b); else &#123;if(find(a)!=find(b))cout&lt;&lt;-1&lt;&lt;endl;else cout&lt;&lt;abs(rl[a]-rl[b])-1&lt;&lt;endl;&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3038]]></title>
    <url>%2Fhdu3038%2F</url>
    <content type="text"><![CDATA[链接:hdu3038 Description TT and FF are … friends. Uh… very very good friends -____-b FF is a bad boy, he is always wooing TT to play the following game with him. This is a very humdrum game. To begin with, TT should write down a sequence of integers-_-!!(bored). Then, FF can choose a continuous subsequence from it(for example the subsequence from the third to the fifth integer inclusively). After that, FF will ask TT what the sum of the subsequence he chose is. The next, TT will answer FF’s question. Then, FF can redo this process. In the end, FF must work out the entire sequence of integers. BoringBoringa very very boring game!!! TT doesn’t want to play with FF at all. To punish FF, she often tells FF the wrong answers on purpose. The bad boy is not a fool man. FF detects some answers are incompatible. Of course, these contradictions make it difficult to calculate the sequence. However, TT is a nice and lovely girl. She doesn’t have the heart to be hard on FF. To save time, she guarantees that the answers are all right if there is no logical mistakes indeed. What’s more, if FF finds an answer to be wrong, he will ignore it when judging next answers. But there will be so many questions that poor FF can’t make sure whether the current answer is right or wrong in a moment. So he decides to write a program to help him with this matter. The program will receive a series of questions from FF together with the answers FF has received from TT. The aim of this program is to find how many answers are wrong. Only by ignoring the wrong answers can FF work out the entire sequence of integers. Poor FF has no time to do this job. And now he is asking for your help~(Why asking trouble for himself~~Bad boy) Input Line 1: Two integers, N and M (1 &lt;= N &lt;= 200000, 1 &lt;= M &lt;= 40000). Means TT wrote N integers and FF asked her M questions. Line 2..M+1: Line i+1 contains three integer: Ai, Bi and Si. Means TT answered FF that the sum from Ai to Bi is Si. It’s guaranteed that 0 &lt; Ai &lt;= Bi &lt;= N. You can assume that any sum of subsequence is fit in 32-bit integer.Output A single line with a integer denotes how many answers are wrong.Sample Input 10 5 1 10 100 7 10 28 1 3 32 4 6 41 6 6 1Sample Output 1题解 带权并查集问题，一样的找向量偏移量 然后这题卡多组。。。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int f[N],rl[N],n,m,t,a,b,ans;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]+=rl[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b&amp;&amp;rl[y]-rl[x]!=t)&#123;ans++; return ;&#125; f[b]=a; rl[b]=rl[x]-rl[y]+t;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; rep(i,1,n)f[i]=i; rep(i,1,m)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;t); un(--a,b); &#125; printf("%d",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1829]]></title>
    <url>%2Fhdu1829%2F</url>
    <content type="text"><![CDATA[链接:hdu1829 Description Background Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs. Problem Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it. Input The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one.Output The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong.Sample Input 2 3 3 1 2 2 3 1 3 4 2 1 2 3 4Sample Output Scenario #1: Suspicious bugs found! Scenario #2: No suspicious bugs found! 题解 这题很好玩，找gay 也是带权并查集 算一下向量偏移量就好了 压缩路径的偏移量算错了wa了一发，输出标记错了又wa一发。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e4+7;int f[N],rl[N],T,a,b,cnt,ans,n,m;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]=(rl[x]+rl[f[x]])&amp;1; //rl[x] 表示x与f[x]的关系 return f[x]=t;&#125;inline int un(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b)if(rl[x]==rl[y])return ans=1; f[b]=a; rl[b]=(rl[x]-rl[y]+1)&amp;1; return 0;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; ans=0; scanf("%d%d",&amp;n,&amp;m); memset(rl,0,sizeof(rl)); rep(i,1,n)f[i]=i; printf("Scenario #%d:\n",++cnt); rep(i,1,m)&#123; scanf("%d%d",&amp;a,&amp;b); if(ans)continue; if(un(a,b))puts("Suspicious bugs found!\n"); &#125; if(!ans)puts("No suspicious bugs found!\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1182]]></title>
    <url>%2Fpoj1182%2F</url>
    <content type="text"><![CDATA[链接:poj1182 Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是”1 X Y”，表示X和Y是同类。 第二种说法是”2 X Y”，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就 是假话，否则就是真话。 1）当前的话与前面的某些真的话冲突，就是假话； 2）当前的话中X或Y比N大，就是假话； 3）当前的话表示X吃X，就是假话。 你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。Output 只有一个整数，表示假话的数目。Sample Input 100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5Sample Output 3题解 并查集高级操作，带权并查集 用向量的方式算一下偏移量就好 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+10;int f[N],rl[N],n,m,op,x,y,ans;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]=(rl[x]+rl[f[x]])%3; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b)&#123; if((3+rl[y]-rl[x])%3!=op)ans++; return ; &#125; f[b]=a; rl[b]=(3+op+rl[x]-rl[y])%3;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)f[i]=i; rep(i,1,m)&#123; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); op--; if(x&gt;n||y&gt;n||(op&amp;&amp;x==y))&#123;ans++; continue;&#125; un(x,y); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论小结]]></title>
    <url>%2F%E6%95%B0%E8%AE%BA%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[欧几里德算法(gcd) 辗转相除,求最小公因数 定理 gcd(a,b)=gcd(b,a%b); gcd(a,0)=0;证明(假设a&gt;b)充分性 将a写成 a=k*b+r; 设d为a,b的一个公因数,则d|a,d|b 而r=a-k*b r/d=a/d-k*b/d 由假设可知右侧为正整数 显然d|r 得证必要性 设d|a,d|(a%b) 显然d|(a-k*b) (k为整数) 显然d|a 得证拓展欧几里德算法 在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a,b) = d（解一定存在，根据数论中的相关定理）。扩展欧几里德常 用在求解模线性方程及方程组中。(依赖于欧几里德算法)贝祖等式 在数论中，裴蜀等式（英语：Bézout’s identity）或贝祖定理（Bézout’s lemma）是一个关于最大公约数（或最大公约式）的定理。 裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程（称为裴蜀等 式）： ax + by = gcd(a,b) = d 有整数解时当且仅当m是d的倍数。 裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数，可用扩展欧几里得算法(Extended Euclidean algorithm)求得。 特别来说，方程 ax+by=1 有整数解当且仅当整数a和b互素。 裴蜀等式也可以用来给最大公约数定义： d其实就是最小的可以写成ax+by形式的正整数。(这个定义的本质是整环中“理想”的概念。因 此对于多项式整环也有相应的裴蜀定理。)证明: 如果 a 和 b 中有一个是 0，比如 a=0，那么它们两个的最大公约数是 b。这时裴蜀等式变成 by=d，它有整数解 (x,y) 当且仅当 d 是 b 的倍数，而且有解时必然有无穷多个解，因为 x 可以是任何整数。定理成立。 以下设 a和 b 都不为0。 设 A={xa+yb;(x,y)∈Z2} ，下面证明A中的最小正元素是 a 与 b 的最大公约数。 首先，A∩N∗ 不是空集（至少包含|a| 和|b|），因此由于自然数集合是良序的， A 中存在最小正元素d0=x0a+y0b。考虑A中任意一个正 元素p（=x1a+y1b）对 d0 的带余除法：设p=qd0+r，其中 q 为正整数，0≤r&lt;d0。但是 r=p−qd0=x1a+y1b−q(x0a+y0b)∈A 而d0 已经是集合 A 中最小的正元素了，又 0≤r&lt;d0,所以 r=0。 因此 d0 | p。也就是说，A中任意一个正元素p都是 d0 的倍数，特别地：d0 | a、d0 | b。因此 d0 是 a 和 b 的公约数。 另一方面，对 a 和 b 的任意正公约数d，设 a=kd、b=ld，那么 d0=x0a+y0b=(x0k+y0l)d x0k+y0l≥1 ,因此 d | d0。所以 d0 是 a 和 b 的最大公约数。 在方程ax+by=m中，如果 m=m0d0，那么方程显然有无穷多个解 相反的，如果ax+by=m有整数解，那么 |m|∈A，于是由前可知 d0 | |m|（即 d0 | m）。 m=1时，方程有解当且仅当a、b互质。拓展欧几里德算法 扩展欧几里德算法就是在求 a,b 的最大公约数 m=gcd(a,b) 的同时，求出贝祖等式ax + by = m的一个解 (x,y)。 有两个数 a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以 得到 ax+by=gcd(a,b)的整数解。 先来看下这个几乎所有总结扩展欧几里德算法的帖子中都会用到的例子 123456789101112131415161718192021用类似辗转相除法，求二元一次不定方程47x+30y=1的整数解。47=30*1+1730=17*1+1317=13*1+413=4*3+1然后把它们改写成“余数等于”的形式17=47*1+30*(-1) //式113=30*1+17*(-1) //式24=17*1+13*(-1) //式31=13*1+4*(-3)然后把它们“倒回去”1=13*1+4*(-3) //应用式31=13*1+[17*1+13*(-1)]*(-3)1=13*4+17*(-3) //应用式21=[30*1+17*(-1)]*4+17*(-3)1=30*4+17*(-7) //应用式11=30*4+[47*1+30*(-1)]*(-7)1=30*11+47*(-7)得解x=-7, y=11。 现在的问题就是找到这个倒推回去的递推式 12345678910111213 设：a&gt;b。 推理1，显然当 b=0，gcd（a，b）=a。 此时 x=1，y=0;//推理1 推理2，ab!=0 时 设 ax1+by1=gcd(a,b); bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)*b)y2=ay2+bx2-(a/b)*by2; 根据恒等定理得：x1=y2 ,y1=x2-(a/b)*y2;//推理2 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.上面的思想是以递归定义的因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 然后我们就找到了递推式 x1=y2; y1=x2−(a/b)∗y2; 当b=0，gcd（a，b）=a。此时x=1，y=0;(终止条件) 于是我们得到了拓展欧几里德算法的代码 1234567inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0;&#125; else &#123; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*x; &#125;&#125; 乘法逆元 若ax≡1 mod m, 则称a关于1模m的乘法逆元为x。也可表示为ax≡1(mod m)。 如果a,m不互质，则无解。如果m为质数，则从1到m−1的任意数都与m互质，即在1到m−1之间都恰好有一个关于模m的乘法逆元。求法 欧拉定理 欧拉定理：aφ(m)≡1(mod m) (φ(m)是小于m且与m互质的数的个数。) 变形得: a⋅aφ(m)−1≡1(mod m) 故aφ(m)−1为a在模m下的逆元。(aφ(m)−1用快速幂求解即可)费马小定理 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)， 那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。 则a*a^(p-2)≡1(mod p) 显然a^(p-2)就是a关于%p的逆元 费马小定理实质上是欧拉定理的一个特殊情况拓展欧几里德 详情看上面，但是注意求出来的逆元可能为负数，只需要加上p再%p就好斯特林公式 斯特林公式是一条用来取n的阶乘的近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特林公式十分好用， 而且，即使在n很小的时候，斯特林公式的取值已经十分准确。n!\approx\sqrt{2\pi n}(\frac{n}{e})^n lucas定理 Lucas定理是用来求 C(n,m)mod p，p为素数的值。 适用领域范围：大组合数求模,n,m&gt;pC_n^m \%p=C_{n/p}^{m/p}*C_{n \%p}^{n \%m}\ %p 线性求逆元 有时我们需要1~p所有元素的逆元，当p很大的时候常规的求逆元方式的时间复杂度都比较高最快也是O(p*log(p)) 只需要一点简单的推倒，我们就可以O(p)地求解 先给出递推式inv[i]=(p-p/i)*inv[p%i]%p 推导 设 t=p/i,k=p%i,那么 t*i+k≡0(mod p) -ti≡k(mod p) 两边同除ik 得到 -t*inv[k]≡invi 替换回去可以得到 inv[i]=(p-p/i)*inv[p%i]%p 初始化inv[1]=1 就可以递推地求解了判断组合数奇偶 C_n^m为奇数时n%m==m]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1999高维正方体]]></title>
    <url>%2Flg1999%E9%AB%98%E7%BB%B4%E6%AD%A3%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[链接:lg1999高维正方体 Description 0维空间的元素是点，这个毋庸置疑。 2个0维空间的元素可以围成一个1维空间的元素，线段。 4个1维空间的元素可以围成一个2维空间的元素，正方形。 6个2维空间的元素可以围成一个3维空间的元素，正方体。 8个3维空间的元素可以围成一个4维空间的元素，超正方体。 …… 一个正方形中，有4个（顶）点，4条线段（边），1个正方形。 一个正方体中，有8个（顶）点，12条线段（棱），6个正方形（面），1个正方体。 …… 我们的问题是：给出a与b，请求出：在a维空间的元素中，包含着多少个b维空间的元素。答案可能很大，只需要输出它除以1000000007 的余数。 Input 两个整数a,b，以空格隔开。Output 一个整数，即答案。Sample Input 3 1Sample Output 12题解 找规律,答案等于C(a,b)*pow(2,(a-b)) a,b很大，组合数直接做肯定爆ll 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const ll mod=1000000007;const int N=1e6+7;ll n,m,inv[N];inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0;&#125; else &#123; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*x; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=(ans*a)%mod; a=(a*a)%mod;b&gt;&gt;=1; &#125; return ans;&#125;ll cal()&#123; ll t,ans=1; rep(i,1,m)&#123;exgcd(i,mod,inv[i],t); inv[i]=inv[i]&lt;=0?(inv[i]+mod)%mod:inv[i];&#125; rep(i,1,m)ans=(ans%mod*inv[i]%mod*(n-m+i))%mod; return ans;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(n&lt;m)printf("0\n"); else printf("%lld\n",cal()*qpow(2,n-m)%mod); //cout&lt;&lt;cal()&lt;&lt;' '&lt;&lt;qpow(2,n-m)%mod; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里德</category>
      </categories>
      <tags>
        <tag>拓展欧几里德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1433:[ZJOI2009]假期的宿舍]]></title>
    <url>%2Fbzoj1433-ZJOI2009-%E5%81%87%E6%9C%9F%E7%9A%84%E5%AE%BF%E8%88%8D%2F</url>
    <content type="text"><![CDATA[链接:bzoj1433:[ZJOI2009]假期的宿舍 Description 学校放假了······有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。比如A 和B都是学校的学生，A要回家，而C来看B，C与A不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一 个解决方案就是B睡A的床而C睡B的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也 不一定都互相认识。我们已知一共有n个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家 。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。 Input 第一行一个数T表示数据组数。接下来T组数据， 每组数据第一行一个数n表示涉及到的总人数。 接下来一行n个数，第i个数表示第i个人是否是在校学生(0表示不是，1表示是)。 再接下来一行n个数，第i个数表示第i个人是否回家 (0表示不回家，1表示回家，注意如果第i个人不是在校学生，那么这个位置上的数是一个随机的数， 你应该在读入以后忽略它)。 接下来n行每行n个数， 第i行第j个数表示i和j是否认识 (1表示认识，0表示不认识，第i行i个的值为0，但是显然自己还是可以睡自己的床)， 认识的关系是相互的。 1 ≤ n ≤ 50,1 ≤ T ≤ 20Output 对于每组数据，如果存在一个方案则输出“^_^”(不含引号)否则输出“T_T”(不含引号)。 (注意输出的都是半角字符，即三个符号的ASCII码分别为94,84,95)Sample Input 1 3 1 1 0 0 1 0 0 1 1 1 0 0 1 0 0Sample Output ˆ ˆ题解 人和床匹配，没什么多说的。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=55;int sc[N],bed[N],mark[N],l[N][N],vis[N],people[N],cnt2,cnt1,n,ans;int find(int x)&#123; rep(i,1,cnt1)if(!vis[bed[i]]&amp;&amp;l[x][bed[i]])&#123; vis[bed[i]]=1; if(!mark[bed[i]]||find(mark[bed[i]]))&#123; mark[bed[i]]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;n); while(~scanf("%d",&amp;n))&#123; cnt1=ans=cnt2=0; memset(mark,0,sizeof(mark)); rep(i,1,n)scanf("%d",&amp;sc[i]); rep(i,1,n)&#123; int x;scanf("%d",&amp;x); if(sc[i])if(x)bed[++cnt1]=i;else bed[++cnt1]=people[++cnt2]=i; else people[++cnt2]=i; &#125; rep(i,1,n)rep(j,1,n)scanf("%d",&amp;l[i][j]); rep(i,1,n)if(sc[i])l[i][i]=1; rep(i,1,cnt2)&#123;memset(vis,0,sizeof(vis)); ans+=find(people[i]);&#125; if(cnt1&lt;cnt2||ans!=cnt2)puts("T_T"); else if(ans==cnt2)puts("^_^"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lightoj1042]]></title>
    <url>%2Flightoj1042%2F</url>
    <content type="text"><![CDATA[链接:lightoj1042 Description This is the tale of Zephyr, the greatest time traveler the world will never know. Even those who are aware of Zephyr’s existence know very little about her. For example, no one has any clue as to which time period she is originally from. But we do know the story of the first time she set out to chart her own path in the time stream. Zephyr had just finished building her time machine which she named - “Dokhina Batash”. She was making the final adjustments for her first trip when she noticed that a vital program was not working correctly. The program was supposed to take a number N, and find what Zephyr called its Onoroy value. The Onoroy value of an integer N is the number of ones in its binary representation. For example, the number 13 (11012) has an Onoroy value of 3. Needless to say, this was an easy problem for the great mind of Zephyr. She solved it quickly, and was on her way. You are now given a similar task. Find the first number after N which has the same Onoroy value as N. Input Input starts with an integer T (≤ 65), denoting the number of test cases. Each case begins with an integer N (1 ≤ N ≤ 109).Output For each case of input you have to print the case number and the desired result.Sample Input 5 23 14232 391 7 8Sample Output Case 1: 27 Case 2: 14241 Case 3: 395 Case 4: 11 Case 5: 16题解 思路还行，代码实现有点困难，太弱了 把n最右边的连续的1向右移动直到个数-1，把n最左边连续的1的末尾的相邻0改为1就是答案了 以下是我的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;int pre,T,n,ct,now,bit[40],id;int get(int x)&#123; int cnt=0; while(x)&#123; if(x&amp;1)cnt++; x&gt;&gt;=1; &#125; return cnt;&#125;int getbit(int x)&#123; rep(i,0,30)&#123; if(x&amp;1)bit[i]=1; else bit[i]=0; x&gt;&gt;=1; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); ct=get(n); n+=lowbit(n);getbit(n);now=get(n); while(ct!=now)&#123; rep(i,0,30)if(!bit[i])&#123; now++;bit[i]=1; n|=(1&lt;&lt;i);break; &#125; &#125; printf("Case %d: %d\n",++id,n); &#125; return 0;&#125; 以下是大佬的代码，我只想说。。差距好大12345678910111213141516171819#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; int main() &#123; ll t; scanf("%lld",&amp;t); for(ll k=1;k&lt;=t;++k) &#123; ll n; scanf("%lld",&amp;n); ll x=n&amp;-n,y=n+x; n=((n&amp;~y)/x&gt;&gt;1)|y; printf("Case %lld: %lld\n",k,n); &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2825[HEOI2016/TJOI2016]]]></title>
    <url>%2FP2825-HEOI2016-TJOI2016%2F</url>
    <content type="text"><![CDATA[链接:P2825[HEOI2016/TJOI2016] Description 在2016年，佳缘姐姐喜欢上了一款游戏，叫做泡泡堂。简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者 躲开对手的炸弹。在玩游戏的过程中，小H想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个 炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。给定一张 nm的网格地图:其中代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。x代表软石头，炸弹的威力可以穿透，不能在此放置 炸弹。#代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出14的网格地图xx*，这个地图上最多只能放置一个炸 弹。给出另一个14的网格地图x#，这个地图最多能放置两个炸弹。现在小H任意给出一张nm的网格地图，问你最多能放置多少炸弹。 Input 第一行输入两个正整数n,m,n表示地图的行数，m表示地图的列数。1≤n,m≤50。接下来输入n行m列个字符，代表网格地图。*的个数不超过 n*m个。Output 输出一个整数a，表示最多能放置炸弹的个数Sample Input 4 4* # # xxx#Sample Output 5题解 提取出每一行和每一列的极长连续不含#的非空字串 显然，炸弹只能放在*上，而放一个就会把它周围清空，这样显然就是二分图最大匹配了 以他们为节点，每一行和每一列连边。跑一个匈牙利就出来了。 zz地弄了个骚操作加边，然后WA一万次。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=55;const int M=3e3;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[M];int head[M],cnt,tol,col[N][N],row[N][N],n,m,vis[M],mark[M],ans;char str[N][N];inline void add(int a,int b)&#123; e[++cnt].init(b,head[a]); head[a]=cnt;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,1,m)cin&gt;&gt;str[i][j]; rep(i,1,n)rep(j,1,m)if(str[i][j]!='#')&#123; if(j==1||str[i][j-1]=='#')tol++; row[i][j]=tol; &#125; rep(j,1,m)rep(i,1,n)if(str[i][j]!='#')&#123; if(i==1||str[i-1][j]=='#')tol++; col[i][j]=tol; &#125; rep(i,1,n)rep(j,1,m)if(str[i][j]=='*')add(row[i][j],col[i][j]); rep(i,1,tol)&#123;memset(vis,0,sizeof(vis));ans+=find(i);&#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1640]]></title>
    <url>%2Flg1640%2F</url>
    <content type="text"><![CDATA[链接:lg1640 Description lxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使 用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。游戏进行到最后，lxhgww遇到了终极boss，这个终 极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能 使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此 类推。现在lxhgww想知道他最多能连续攻击boss多少次？ Input 输入的第一行是一个整数N，表示lxhgww拥有N种装备接下来N行，是对这N种装备的描述，每行2个数字，表示第i种装备的2个属性值Output 输出一行，包括1个数字，表示lxhgww最多能连续攻击的次数。Sample Input 3 1 2 3 2 4 5Sample Output 2题解 mdzz 因为标记方式不同，各种RE TLE 思路很简单，但是不好想，用伤害匹配装备 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1000070;const int M=10070;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N&lt;&lt;1];int head[M],mark[N],cnt,n,vis[M],ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void add(int a,int b)&#123; e[++cnt].init(b,head[a]); head[a]=cnt;&#125;int find(int u)&#123; if(vis[u])return 0; vis[u]=1; for(int i=head[u];i;i=e[i].nxt)if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; return 0;&#125;int main()&#123; read(n); rep(i,1,n)&#123;int x; read(x); add(x,i); read(x); add(x,i);&#125; rep(i,1,10000)&#123;memset(vis,0,sizeof(vis)); if(find(i))ans++;else break;&#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1402]]></title>
    <url>%2Flg1402%2F</url>
    <content type="text"><![CDATA[链接:lg1402 Description XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也 有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。 有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜 欢的房间，吃到喜欢的菜）。 这里要怎么分配，能使最多顾客满意呢？ Input 第一行给出三个正整数表示n,p,q(&lt;=100)。 之后n行，每行p个数包含0或1，第i个数表示喜不喜欢第i个房间（1表示喜欢，0表示不喜欢）。 之后n行，每行q个数，表示喜不喜欢第i道菜。Output 顾客最大满意数Sample Input 2 2 2 1 0 1 0 1 1 1 1Sample Output 1题解 做两个最大匹配，如果都匹配上了，答案+1，否则返回上次状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define abs(x) x=x&gt;0?x:(-x)using namespace std;const int N=300;int l[N][N][2],m[N][2],vis[N][2],n,p,q,tp[N][2];template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x,int op)&#123; rep(i,1,n)if(l[x][i][op]&amp;&amp;!vis[i][op])&#123; vis[i][op]=1; if(!m[i][op]||find(m[i][op],op))&#123; m[i][op]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; int ans=0; read(n);read(p);read(q); rep(i,1,n)rep(j,1,p)read(l[i][j][0]); rep(i,1,n)rep(j,1,q)read(l[i][j][1]); rep(i,1,n)&#123; rep(j,0,1)rep(k,1,n)tp[k][j]=m[k][j]; memset(vis,0,sizeof(vis)); if(find(i,0)&amp;&amp;find(i,1))ans++; else rep(j,0,1)rep(k,1,n)m[k][j]=tp[k][j]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1129]]></title>
    <url>%2Flg1129%2F</url>
    <content type="text"><![CDATA[链接:lg1129 Description 小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个N*N黑白方阵进行（如同国际象 棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作： 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色） 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色） 游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。 对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有 解。 Input 第一行包含一个整数T，表示数据的组数。 接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。Output 包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。Sample Input 2 2 0 0 0 1 3 0 0 1 0 1 0 1 0 0Sample Output No Yes题解 N行和N列都能匹配且值为N的话，一定会有解 所以建个二分图，跑个最大匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=500;int l[N][N],mark[N],vis[N],n,ans,T;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x)&#123; rep(i,1,n)if(l[x][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!mark[i]||find(mark[i]))&#123; mark[i]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; read(T); while(T--)&#123; ans=0; memset(mark,0,sizeof(mark)); read(n); rep(i,1,n)rep(j,1,n)read(l[i][j]); rep(i,1,n)&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; if(ans==n)printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3041]]></title>
    <url>%2Fhdu3041%2F</url>
    <content type="text"><![CDATA[链接:hdu3041 Description Bessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 &lt;= N &lt;= 500). The grid contains K asteroids (1 &lt;= K &lt;= 10,000), which are conveniently located at the lattice points of the grid. Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids. Input Line 1: Two integers N and K, separated by a single space. Lines 2..K+1: Each line contains two space-separated integers R and C (1 &lt;= R, C &lt;= N) denoting the row and column coordinates of an asteroid, respectively.Output Line 1: The integer representing the minimum number of times Bessie must shoot.Sample Input 3 4 1 1 1 3 2 2 3 2Sample Output 2题解 二分图最小点覆盖 其实就等于二分图最大匹配 数组忘了清零，WA一发，数组开大十倍，TLE一发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],cnt=1,vis[N],mark[N],n,m,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void reade(int a,int b)&#123;e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; ans=0; memset(head,0,sizeof(head)); memset(mark,0,sizeof(mark)); rep(i,1,m)&#123; int x,y; read(x);read(y); reade(x,y); &#125; rep(i,1,n)&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2071]]></title>
    <url>%2Flg2071%2F</url>
    <content type="text"><![CDATA[链接:lg2071 Description 已知车上有N排座位，有N*2个人参加省赛，每排座位只能坐两人，且每个人都有自己想坐的排数，问最多使多少人坐到自己想坐的位置。 Input 第一行，一个正整数Ｎ。 第二行至第Ｎ*2+1行，每行两个正整数Si1，Si2，为每个人想坐的排数。Output 一个非负整数，为最多使得多少人满意。Sample Input 4 1 2 1 3 1 2 1 3 1 3 2 4 1 3 2 3Sample Output 7题解 二分图匹配，每个人加4次边就好了 mdzz 数组开大10倍，TLE无限次。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],cnt=1,vis[N],mark[N],n,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void reade(int a,int b)&#123;e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n*2)&#123; int x; scanf("%d",&amp;x); reade(i,x); reade(i,x+n); scanf("%d",&amp;x); reade(i,x); reade(i,n+x); &#125; ans=0; rep(i,1,n*2)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2063]]></title>
    <url>%2Fhdu2063%2F</url>
    <content type="text"><![CDATA[链接:hdu2063 Description RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的 规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做 partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只 让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山 车吗？ Input 输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000 1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。Sample Input 6 3 3 1 1 1 2 1 3 2 1 2 3 3 1 0Sample Output 3题解 二分图最优匹配模板题 用的匈牙利算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],mark[N],vis[N],cnt=1,k,n,m,ans;int find(int u)&#123; for(int i=head[u];i!=-1;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;k)&amp;&amp;k)&#123; memset(head,-1,sizeof(head)); memset(mark,0,sizeof(mark)); read(m);read(n); rep(i,1,k)&#123; int x,y; read(x);read(y); e[i].init(y,head[x]); head[x]=i; &#125; ans=0; rep(i,1,m)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1233]]></title>
    <url>%2Fhdu1233%2F</url>
    <content type="text"><![CDATA[链接:hdu1233 Description 某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路 交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正 整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。 当N为0时，输入结束，该用例不被处理。Output 对每个测试用例，在1行里输出最小的公路总长度。Sample Input 3 1 2 1 1 3 2 2 3 4 4 1 2 1 1 3 4 1 4 1 2 3 3 2 4 2 3 4 5 0Sample Output 3 5题解 模板题 写的kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define abs(x) x=x&gt;0?x:(-x)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int u,v,w; bool operator &lt;(const node y)&#123;return w&lt;y.w;&#125; inline void init(int a,int b,int c)&#123;u=a; v=b; w=c;&#125;&#125;e[N];int f[N],n,m;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123;x=find(x); y=find(y); return x==y?0:f[x]=y;&#125;int kruskal()&#123; rep(i,1,n)f[i]=i; int ans=0,cnt=0; rep(i,1,m)&#123; int x=find(e[i].u); int y=find(e[i].v); if(un(x,y))ans+=e[i].w,cnt++; if(cnt==n-1)return ans; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; m=n*(n-1)/2; rep(i,1,m)&#123; int a,b,c; read(a);read(b);read(c); e[i].init(a,b,c); e[m+i].init(b,a,c); &#125; m&lt;&lt;=1; sort(e+1,e+m+1); printf("%d\n",kruskal()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1875]]></title>
    <url>%2Fhdu1875%2F</url>
    <content type="text"><![CDATA[链接:hdu1875 Description 相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府 决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分 了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省 资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 Input 输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。 每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000 的整数。Output 每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.Sample Input 2 2 10 10 20 20 3 1 1 2 2 1000 1000Sample Output 1414.2 oh!题解 模板题 用kruskal做的，智障地答案不清零，wa了一发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;struct node&#123; int u,v; double w; inline void init(int a,int b,double c)&#123;u=a; v=b; w=c;&#125;&#125;e[N];int x[N],y[N],f[N],ct,n,T;double ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;x=0;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;double dis(int a,int b)&#123;return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;int find(int a)&#123;return f[a]==a?a:f[a]=find(f[a]);&#125;void un(int a,int b)&#123;a=find(a); b=find(b); if(a!=b)f[a]=b;&#125; bool cmp(node a,node b)&#123;return a.w&lt;b.w;&#125;int kruskal()&#123; rep(i,1,n)f[i]=i; int cnt=0; rep(i,0,ct-1)&#123; int a=find(e[i].u),b=find(e[i].v); if(a!=b)&#123; un(a,b); cnt++; ans+=e[i].w; &#125; if(cnt==n-1)return 1; &#125; if(cnt!=n-1)return 0;&#125;int main()&#123; read(T); while(T--)&#123; ct=0; ans=0; read(n); rep(i,1,n)read(x[i]),read(y[i]); rep(i,1,n)rep(j,i+1,n)&#123; double a=dis(i,j); if(a&lt;10||a&gt;1000)continue; e[ct++].init(i,j,a); e[ct++].init(j,i,a); &#125; sort(e,e+ct,cmp); if(kruskal())printf("%.1lf\n",ans*100); else puts("oh!"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf#469]]></title>
    <url>%2Fcf-469%2F</url>
    <content type="text"><![CDATA[链接:cf#469 C题目大意 给你一个01串，将他分成k个子串，每个子串由0开始0结尾，01交替出现 题解 两个数组分别存以0结尾，以1结尾的串的序号，当当前字符为1的时候，如果以0结尾的串为空，输出-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=200010; char s[N];vector&lt;int&gt; ans[N],z1,z0;int main()&#123; scanf("%s",s+1); int len=strlen(s+1); rep(i,1,len)&#123; if(s[i]=='1')&#123; if(!z0.size())&#123; puts("-1");return 0; &#125; int t=z0.back();z0.pop_back(); ans[t].push_back(i);z1.push_back(t); &#125; else &#123; if(!z1.size())&#123; z0.push_back(i);ans[i].push_back(i); &#125; else &#123; int t=z1.back();z1.pop_back(); ans[t].push_back(i);z0.push_back(t); &#125; &#125; &#125; if(z1.size())&#123; puts("-1");return 0; &#125; printf("%d\n",z0.size()); len=z0.size(); rep(i,0,len-1)&#123; int tp=ans[z0[i]].size(); printf("%d",tp); rep(j,0,tp-1)printf(" %d",ans[z0[i]][j]); printf("\n"); &#125; return 0;&#125; D题目大意 n个数字，每两个数字中间插一个空，每次将最右边的数移动到最右边的空格处，q个询问，问最后在xi位置的元素题解 数据范围是1e18次方，显然需要找规律，显然n/2左边的数字都是不动的，对于第x(i)个位置的元素，他会转移到2*(x(i)-n)的位置 上去，即是P(x)=n+x/2 (x位置上的元素由P(x)转移过来)12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;ll n,q,x;int main()&#123; while(~scanf("%I64d%I64d",&amp;n,&amp;q))&#123; while(q--)&#123; scanf("%I64d",&amp;x); while(!(x&amp;1))x+=n-x/2; printf("%I64d\n",(x+1)/2); &#125; &#125; return 0;&#125; 总结 考场上两道题都没做出来，没状态，code能力太弱。 再弱小也还是要努力地活下去。]]></content>
      <categories>
        <category>比赛</category>
        <category>cf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ccf认证2017-12-4行车路线]]></title>
    <url>%2Fccf%E8%AE%A4%E8%AF%812017-12-4%E8%A1%8C%E8%BD%A6%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[链接:ccf认证2017-12-4行车路线 Description 小明和小芳出去乡村玩，小明负责开车，小芳来导航。 小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快 速增加，连续走s公里小明会增加s2的疲劳度。 例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路 口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。 现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。 Input 输入的第一行包含两个整数n, m，分别表示路口的数量和道路的数量。路口由1至n编号，小明需要开车从1号路口到n号路口。 接下来m行描述道路，每行包含四个整数t, a, b, c，表示一条类型为t，连接a与b两个路口，长度为c公里的双向道路。其中t为0表示大 道，t为1表示小道。保证1号路口和n号路口是连通的。Output 输出一个整数，表示最优路线下小明的疲劳度。Sample Input 6 7 1 1 2 3 1 2 3 2 0 1 3 30 0 3 4 20 0 4 5 30 1 3 5 6 1 5 6 1Sample Output 76题解 最短路，小路和大路分开来计算，注意中间结果可能爆int，并且可能给出重复的路，需要取最优值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+10;const ll inf=1e18+7;ll dis[N],dis0[N],n,m,in[N],g[N][N],g0[N][N];queue&lt;int&gt; q;void spfa(int s,int t)&#123; q.push(s); dis[s]=dis0[s]=0; in[s]=1; rep(i,1,n)if(i!=s)dis[i]=dis0[i]=inf; while(!q.empty())&#123; int k=q.front(); q.pop(); in[k]=0; rep(i,1,n)&#123; ll tp=g[k][i]; if(dis[i]&gt;dis[k]+tp)&#123; //前一次走的大路 dis[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(dis[i]&gt;dis0[k]+tp)&#123; //前一次走的小路 dis[i]=dis0[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(g0[k][i]!=inf)&#123; //现在走小路 tp=g0[k][i]*g0[k][i]; if(dis0[i]&gt;dis[k]+tp)&#123; dis0[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,i,n)g[i][j]=g[j][i]=g0[i][j]=g0[j][i]=inf; rep(i,1,m)&#123; int a,b,c,d; scanf("%d%d%d%d",&amp;d,&amp;a,&amp;b,&amp;c); if(d==0)g[a][b]=g[b][a]=min(g[a][b],(ll)c); else g0[a][b]=g0[b][a]=min(g0[a][b],(ll)c); &#125; rep(k,1,n)rep(i,1,n)rep(j,i+1,n)g0[i][j]=min(g0[i][k]+g0[k][j],g0[i][j]); //floyd先求出两点间最小的小路 spfa(1,n); printf("%lld\n",min(dis[n],dis0[n])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>spfa</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青出于蓝胜于蓝]]></title>
    <url>%2F%E9%9D%92%E5%87%BA%E4%BA%8E%E8%93%9D%E8%83%9C%E4%BA%8E%E8%93%9D%2F</url>
    <content type="text"><![CDATA[链接:青出于蓝胜于蓝 Description 武当派一共有 n 人，门派内 n 人按照武功高低进行排名，武功最高的人排名第 1，次高的人排名第 2，…武功最低的人排名第 n。现 在我们用武功的排名来给每个人标号，除了祖师爷，每个人都有一个师父，每个人可能有多个徒弟。 我们知道，武当派人才辈出，连祖师爷的武功都只能排行到 p。也就是说徒弟的武功是可能超过师父的，所谓的青出于蓝胜于蓝。 请你帮忙计算每个人的所有子弟（包括徒弟的徒弟，徒弟的徒弟的徒弟….）中，有多少人的武功超过了他自己。 Input 输入第一行两个整数 n,p(1≤n≤100000,1≤p≤n)。 接下来 n−1 行，每行输入两个整数u,v(1≤u,v≤n)，表示 u 和 v 之间存在师徒关系。Output 输出一行 n 个整数，第 i 个整数表示武功排行为 i 的人的子弟有多少人超过了他。行末不要输出多余的空格。Sample Input 10 5 5 3 5 8 3 4 3 1 2 1 6 7 8 7 9 8 8 10Sample Output 0 0 2 0 4 0 1 2 0 0题解 树状数组维护dfs的时间戳，每访问一个点，in数组标记他，标记完所有子树的节点后，out数组取消标记 然后这个点的答案就是out[u]到in[u]区间内的和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=100070;int f[N],tr[N&lt;&lt;2],p,n,cnt,in[N],out[N ];vector&lt;int&gt;e[N];void add(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;int ask(int x)&#123; int tp=0; for(int i=x;i;i-=lowbit(i))tp+=tr[i]; return tp;&#125;void dfs(int u,int fa)&#123; in[u]=++cnt; int len=e[u].size(); rep(i,0,len-1)if(e[u][i]!=fa)dfs(e[u][i],u); out[u]=cnt;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;p; rep(i,2,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; e[x].push_back(y); e[y].push_back(x); &#125; dfs(p,-1); rep(i,1,n)&#123; cout&lt;&lt;ask(out[i])-ask(in[i]); if(i!=n)cout&lt;&lt;' '; add(in[i],1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数列求值]]></title>
    <url>%2F%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[链接:数列求值 Description 对于一个含有 n+2个元素的数列A0, A1, … , An，满足这样的递归公式: Ai = (Ai-1 + Ai+1) /2 - Ci 1≤i≤n 现在我们知道A0, An+1和C1, C2, … , Cn 现在请你帮忙计算A1的值。 Input 第一行输入一个整数n(1≤n≤1000)。 第二行输入两个数A0, An+1，接着是 n个数据分别是C1, C2, … , Cn。所有的数据均是两位小数的浮点数。Output 输出A1的值，结果保留两位小数。Sample Input 1 50.50 25.50 10.15 2 -756.89 52.52 172.22 67.17 Sample Output27.85 -761.49 题解 根据公式可以推导出 A(2)==2A(1)-A(0)+2C(1) 先不看后面的C A(3)==2A(2)-A(1)==3A(1)-2*A(0) . . . A(n+1)==(n+1)A(1)-nA(0) 由于我们已知A(n+1) 看起来好像只需要这个公式就可以求出A(1) 然而还有我们忽略的C 由于未知A(1) 先将A(1)看成0 然后根据这个式子地推出A(n+1)暂时命名为tp,跟正确的A(n+1)相差的只有(n+1)*A(1) 剩下的就不用说了吧。。。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+11;int n;double tp,f[N],c;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;f[0]&gt;&gt;tp; rep(i,2,n+1)&#123; cin&gt;&gt;c; f[i]=2*f[i-1]-f[i-2]+2*c; &#125; printf("%.2lf\n",(tp-f[n+1])/(n+1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天上的星星]]></title>
    <url>%2F%E5%A4%A9%E4%B8%8A%E7%9A%84%E6%98%9F%E6%98%9F%2F</url>
    <content type="text"><![CDATA[链接:天上的星星 Description 在一个星光摧残的夜晚，蒜头君一颗一颗的数这天上的星星。 蒜头君给在天上巧妙的画了一个直角坐标系，让所有的星星都分布在第一象。天上有 n 颗星星，他能知道每一颗星星的坐标和亮度。 现在，蒜头君问自己 q 次，每次他问自己每个矩形区域的星星的亮度和是多少（包含边界上的星星）。 Input 第一行输入一个整数n(1≤n≤50000)，表示星星的数量。 接下来n行，每行输入三个整数x,y,w(0≤x,y,w≤2000)，表示在坐标(x,y)有一颗亮度为w的星星。注意一个点可能有多个星星。 接下来一行输入一个整数q(1≤q≤50000)，表示查询的次数。 接下来q行，每行输入四个整数x1,y1,x2,y2，其中(x1,y1)表示查询的矩形的左下角的坐标，(x2,y2)表示查询的矩形的右上角的坐标， 0≤x1≤x2≤2000，0≤y1≤y2≤2000。Output 对于每一次查询，输出一行一个整数，表示查询的矩形区域内的星星的亮度总和。Sample Input 5 5 0 6 7 9 7 8 6 13 9 7 1 3 0 19 4 0 8 7 9 0 0 7 10 2 7 10 9 5 4 7 5Sample Output 7 32 8 0题解 容斥原理加前缀和，水题，傻逼地写了个n颗线段树维护。。。 答案是dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1] 计算dp的时候，维护每行的前缀和，然后dp[i][j]=dp[i-1][j]+tp[i][j]; 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=3000;int dp[N][N],tp[N][N],g[N][N],q,n;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); g[x+1][y+1]+=w; //注意这里是+= 有可能给出重复的点 &#125; rep(i,1,2001)rep(j,1,2001)&#123; tp[i][j]=tp[i][j-1]+g[i][j]; //第i行1-j列的和 dp[i][j]=dp[i-1][j]+tp[i][j]; &#125; scanf("%d",&amp;q); while(q--)&#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); x1++;y1++;x2++;y2++; printf("%d\n",dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2253]]></title>
    <url>%2Fpoj2253%2F</url>
    <content type="text"><![CDATA[链接:poj2253 Description Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping. Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps. To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence. The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone. Input The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n. Output For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. Sample Input 2 0 0 3 4 3 17 4 19 4 18 5 0 Sample Output Scenario #1 Frog Distance = 5.000 Scenario #2 Frog Distance = 1.414题解 最短路变形，松弛及松弛条件改为max(dis[k],g[k][i])&lt;dis[i] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;typedef pair&lt;double,int&gt; l;const int N=507;double g[N][N],dis[N];int vis[N],x[N],y[N],n,cnt;priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;double dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(vis,0,sizeof(vis)); rep(i,1,n)dis[i]=0x3f3f3f3f; q.push(l(dis[s]=0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); vis[k]=1; rep(i,1,n)if(max(dis[k],g[k][i])&lt;dis[i])&#123; dis[i]=max(dis[k],g[k][i]); if(!vis[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t];&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,i-1)g[i][j]=g[j][i]=len(i,j); printf("Scenario #%d\nFrog Distance = %.3lf\n\n",++cnt,dijkstra(1,2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1491]]></title>
    <url>%2Flg1491%2F</url>
    <content type="text"><![CDATA[链接:lg1491 Description 每次有大的活动，大家都要在一起“聚一聚”，不管是去好乐迪，还是避风塘，或者汤姆熊，大家都要玩的痛快。还记得心语和花儿在跳舞 机上的激情与释放，还记得草草的投篮技艺是如此的高超，还记得狗狗的枪法永远是’S’……还有不能忘了，胖子的歌声永远是让我们惊叫 的！！ 今天是野猫的生日，所以想到这些也正常，只是因为是上学日，没法一起去玩了。但回忆一下那时的甜蜜总是一种幸福嘛。。。 但是每次集合的时候都会出现问题！野猫是公认的“路盲”，野猫自己心里也很清楚，每次都提前出门，但还是经常迟到，这点让大家很是 无奈。后来，野猫在每次出门前，都会向花儿咨询一下路径，根据已知的路径中，总算能按时到了。 现在提出这样的一个问题：给出n个点的坐标，其中第一个为野猫的出发位置，最后一个为大家的集合位置，并给出哪些位置点是相连 的。野猫从出发点到达集合点，总会挑一条最近的路走，如果野猫没找到最近的路，他就会走第二近的路。请帮野猫求一下这条第二最短 路径长度。 Input 第一行是两个整数n(1&lt;=n&lt;=200)和m，表示一共有n个点和m条路，以下n行每行两个数xi，yi，(-500&lt;=xi,yi&lt;=500),代表第i个点的坐 标，再往下的m行每行两个整数pj，qj,(1&lt;=pj,qj&lt;=n)，表示两个点相通。Output 只有一行包含一个数，为第二最短路线的距离（保留两位小数），如果存在多条第一短路径，则答案就是第一最短路径的长度；如果不存 在第二最短路径，输出－1。Sample Input 3 3 0 0 1 1 0 2 1 2 1 3 2 3Sample Output 2.83题解 求次短路，只需要把最长路求出来记录路劲，然后所有第二短路求最小值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;typedef pair&lt;double,int&gt; l;const int N=507;int pre[N],head[N],in[N],n,m,x[N],y[N],cnt;double dis[N],g[N][N],tp[N];priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow(x[a]-x[b],2)+pow(y[a]-y[b],2));&#125;double dijkstra(int s,int t,int op)&#123; while(!q.empty())q.pop(); rep(i,1,n)dis[i]=0x3f3f3f3f; memset(in,0,sizeof(in)); q.push(l(0,s)); dis[s]=0; while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; rep(i,1,n)&#123; if(dis[k]+g[k][i]&gt;=dis[i])continue; dis[i]=dis[k]+g[k][i]; if(op)pre[i]=k; if(!in[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t]==0x3f3f3f3f?-1:dis[t];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,n)if(i!=j)g[i][j]=0x3f3f3f3f; rep(i,1,m)&#123; int a,b,c; scanf("%d%d",&amp;a,&amp;b); g[a][b]=g[b][a]=len(a,b); &#125; if(dijkstra(1,n,1)==-1)printf("-1\n"); else &#123; for(int i=n;i!=1;i=pre[i])&#123; double k=g[i][pre[i]]; g[i][pre[i]]=g[pre[i]][i]=0x3f3f3f3f; tp[cnt++]=dijkstra(1,n,0); g[i][pre[i]]=g[pre[i]][i]=k; &#125; double ans=0x3f3f3f3f; rep(i,0,cnt-1)if(tp[i]!=-1)ans=min(ans,tp[i]); printf("%.2lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1119]]></title>
    <url>%2Flg1119%2F</url>
    <content type="text"><![CDATA[链接:lg1119 Description B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村 庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 给出B地区的村庄数N，村庄编号从0到N-1，和所有M条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间t[i]，你可以认为 是同时开始重建并在第t[i]天重建完成，并且在当天即可通车。若t[i]为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有 Q个询问(x, y, t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经 过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回-1。 Input 输入文件rebuild.in的第一行包含两个正整数N，M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数t[0], t[1], …, t[N – 1]，表示了每个村庄重建完成的时间，数据保证了t[0] ≤ t[1] ≤ … ≤ t[N – 1]。 接下来M行，每行3个非负整数i, j, w，w为不超过10000的正整数，表示了有一条连接村庄i与村庄j的道路，长度为w，保证i≠j，且对 于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。 接下来Q行，每行3个非负整数x, y, t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。Output 输出文件rebuild.out包含Q行，对每一个询问(x, y, t)输出对应的答案，即在第t天，从村庄x到村庄y的最短路径长度为多少。如果在 第t天无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未修复完成，则输出-1。Sample Input 4 5 1 2 3 4 0 2 1 2 3 1 3 1 2 2 1 4 0 3 5 4 2 0 2 0 1 2 0 1 3 0 1 4Sample Output -1 -1 5 4题解 n&lt;=200 floyd就可以了，每次提问，枚举中间的k 如果k这个点重建完成或者没访问过就用它松弛其他路径 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=307;int t[N],dis[N][N],vis[N];int n,m,q;int main()&#123; ios::sync_with_stdio(false); memset(dis,0x3f,sizeof(dis)); cin&gt;&gt;n&gt;&gt;m; rep(i,0,n-1)cin&gt;&gt;t[i]; rep(i,1,m)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dis[a][b]=dis[b][a]=c; &#125; cin&gt;&gt;q; while(q--)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; rep(k,0,n-1)&#123; if(t[k]&gt;c||vis[k])continue; rep(i,0,n-1)if(i!=k)rep(j,0,n-1)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); vis[k]=1; &#125; if(dis[a][b]==0x3f3f3f3f||!vis[a]||!vis[b])cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;dis[a][b]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>floyd</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spfa]]></title>
    <url>%2Fspfa%2F</url>
    <content type="text"><![CDATA[SPFA: Shortest Path Faster Algorithm 看到名字不禁为之一颤，SPFA算法是西南交通大学段凡丁于1994年发表的。 SPFA 也是竞赛中最常见的算法之一，不仅仅用来解决带负权的单源最短路 而且是求解差分约束问题的专用算法，也常用它和最大流合作解决最小费问题 SPFA 算法的最坏复杂度为 O(2*E)。。 SPFA 和dijkstra 格式很接近，只是加了个队列或栈就变得无比神奇了。 这里用邻接表形式写下spfa 的模板 后面再介绍它的其它功能，这里只知道它处理最短路很快即可 优点 可以处理负权，判负环，快代码12345678910111213141516171819202122queue&lt;int&gt; q;int spfa(int s,int t)&#123; memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(vis)); //memset(c,0,sizeof(c)); q.push(s); in[s]=1; //c[s]=1; while(!q.empty())&#123; int k=q.front();q.pop(); in[k]=0; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i]&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])&#123; q.push(e[i].t); in[e[i].t]++; c[e[i].t]++; //if(c[e[i].t]&gt;n)return ok=0 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra优化]]></title>
    <url>%2Fdijkstra%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化 dijkstra 注意到贪心的过程是每次选取最小的dis值出来，这里是O(n)的，我们可以用优先队列把他优化到O(logn) 12345678910111213141516171819typedef pair&lt;int,int&gt; l;priority_queue&lt;s,vector&lt;s&gt;,greater&lt;s&gt; &gt;q;int dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(0)); d[s]=0;in[s]=1; q.push(l(0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i].w&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])q.push(l(d[i],e[i].t)); &#125; &#125; return d[t]!=inf?d[t]:-1;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra算法详解]]></title>
    <url>%2Fdijkstra%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最短路 从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决算法： floyd dijkstra spfa dijktsra优化 spfa优化 dijkstra算法介绍 算法思路: 利用贪心的思想，维护一个dis数组，值为源点到各个顶点的最短距离，以及一个vis数组，表示该点已经算出最短路的点的集合 每次找到dis值最小的顶点（这个dis值就是改点到源点的最短距离），标记它，然后用它来松弛可以松弛的点， 时间复杂度： 很显然是O(n2)的 缺点：无法处理负权代码int dijkstra(int s,int t){ rep(i,1,n+1){ d[i]=g[s][i]; vis[i]=0; } vis[s]=1; rep(i,2,n+1){ int mx=inf,k=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;d[j]&lt;mx){ mx=d[j]; k=j; } vis[k]=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;mx+g[k][j]&lt;d[j]){ d[j]=mx+g[k][j]; } } return d[t]!=inf?d[t]:-1; }]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3252]]></title>
    <url>%2Fpoj3252%2F</url>
    <content type="text"><![CDATA[链接:poj3252 Description The cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone’ (also known as ‘Rock, Paper, Scissors’, ‘Ro, Sham, Bo’, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can’t even flip a coin because it’s so hard to toss using hooves. They have thus resorted to “round number” matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both “round numbers”, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a “round number” if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many “round numbers” are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start &lt; Finish ≤ 2,000,000,000). Input Line 1: Two space-separated integers, respectively Start and Finish.Output Line 1: A single integer that is the count of round numbers in the inclusive range Start..FinishSample Input 2 12Sample Output 6题解 模板题 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)const int N=66;int a[N],dp[N][N];//当前第i位，零的个数为j共有多少种情况 int dfs(int pos,int sta,int limit,int lead)&#123; if(pos==-1)return sta&gt;=32;; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:1; int tmp=0; rep(i,0,up+1)&#123; if(i==0&amp;&amp;lead)tmp+=dfs(pos-1,sta,limit&amp;&amp;i==a[pos],lead); else tmp+=dfs(pos-1,sta+(i==0?1:-1),i==a[pos]&amp;&amp;limit,lead&amp;&amp;i==0); &#125; if(!limit&amp;&amp;!lead)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x&amp;1; x&gt;&gt;=1; &#125; return dfs(cnt-1,32,1,1);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4734]]></title>
    <url>%2Fhdu4734%2F</url>
    <content type="text"><![CDATA[链接:hdu4734 Description For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An 2n-1 + An-1 2n-2 + … + A2 2 + A1 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). Input The first line has a number T (T &lt;= 10000) , indicating the number of test cases. For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109)Output For every case,you should output “Case #t: “ at first, without quotes. The t is the case number starting from Then output the answer.Sample Input30 1001 105 100Sample OutputCase #1: 1Case #2: 2Case #3: 13题解 模板题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)using namespace std;const int N=4600;int a[10],dp[10][N];int n;int dfs(int pos,int limit,int sum)&#123; if(sum&lt;0)return 0; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sum]!=-1)return dp[pos][sum]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(pos-1,limit&amp;&amp;i==a[pos],sum-i*(1&lt;&lt;pos)); &#125; if(!limit)dp[pos][sum]=tmp; return tmp;&#125;int solve(int x,int y)&#123; int cnt=0,len=0,ans=0; while(y)&#123; ans+=y%10*(1&lt;&lt;len); len++; y/=10; &#125; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,1,ans);&#125;int main()&#123; scanf("%d",&amp;n); memset(dp,-1,sizeof(dp)); rep(i,0,n)&#123; int A,B; scanf("%d%d",&amp;A,&amp;B); printf("Case #%d: %d\n",i+1,solve(B,A)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3709]]></title>
    <url>%2Fhdu3709%2F</url>
    <content type="text"><![CDATA[链接:hdu3709 Description A balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 42 + 11 = 9 and 9*1 = 9, for left part and right part, respectively. It’s your job to calculate the number of balanced numbers in a given range [x, y]. Input The input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018).Output For each case, print the number of balanced numbers in the range [x, y] in a line.Sample Input 2 0 9 7604 24324Sample Output 10 897题解 模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=22;ll dp[N][N][2000];//第i位，枢轴为j的时候和为k时共有多少种情况满足符合要求 int a[N];ll dfs(int len,int pos,int limit,int sta)&#123; if(len==-1)return sta?0:1; if(sta&lt;0)return 0; if(!limit&amp;&amp;dp[len][pos][sta]!=-1)return dp[len][pos][sta]; int up=limit?a[len]:9; ll tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(len-1,pos,limit&amp;&amp;i==a[len],sta+i*(len-pos)); &#125; if(!limit)dp[len][pos][sta]=tmp; return tmp;&#125;ll solve(ll x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; ll ans=0; rep(i,0,cnt)&#123; ans+=dfs(cnt-1,i,1,0); &#125; return ans-cnt+1;&#125;int main()&#123; ll l,r; int T; scanf("%d",&amp;T); memset(dp,-1,sizeof(dp)); while(T--)&#123; scanf("%lld%lld",&amp;l,&amp;r); printf("%lld\n",solve(r)-solve(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2089]]></title>
    <url>%2Fhdu2089%2F</url>
    <content type="text"><![CDATA[链接:hdu2089 Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别 的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。Sample Input 1 100 0 0Sample Output 80题解 模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define rep(i,l,n)for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=55;int a[N];ll dp[N][2];//当前第i位，前置有或没有6共有多少种情况 int dfs(int pos,int pre,int sta,int limit)&#123; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; if(pre==6&amp;&amp;i==2)continue; if(i==4)continue; tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;a[pos]==i); &#125; if(!limit)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,-1,0,true);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp));//不管l与r怎么给 已经计算出来的状态是不会改变的 while(~scanf("%d%d",&amp;l,&amp;r))&#123; if(l==0&amp;&amp;r==0)break; printf("%d\n",solve(r)-solve(l-1)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1352]]></title>
    <url>%2Flg1352%2F</url>
    <content type="text"><![CDATA[链接:lg1352 题解 模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)using namespace std;const int N=1e4;int fa[N],r[N],dp[N][2],vis[N];int n,root=1;template &lt;typename T&gt;inline void read(T&amp;x)&#123; x=0;char c;int sign=1; do&#123; c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123; x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void tdp(int node)&#123; vis[node]=1; rep(i,1,n)if(!vis[i]&amp;&amp;fa[i]==node)&#123; tdp(i); dp[node][1]+=dp[i][0]; dp[node][0]+=max(dp[i][1],dp[i][0]); &#125;&#125;int main()&#123; read(n); rep(i,1,n)read(dp[i][1]); rep(i,1,n-1)&#123; int x,y; read(x);read(y); fa[x]=y; &#125; rep(i,1,n)if(!fa[i])&#123; root=i;break; &#125; tdp(root); printf("%d",max(dp[root][1],dp[root][0])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5647]]></title>
    <url>%2Fhdu5647%2F</url>
    <content type="text"><![CDATA[链接:hdu5647 Description DZY has an unrooted tree consisting of n nodes labeled from 1 to n. DZY likes connected sets on the tree. A connected set S is a set of nodes, such that every two nodes u,v in S can be connected by a path on the tree, and the path should only contain nodes from S. Obviously, a set consisting of a single node is also considered a connected set. The size of a connected set is defined by the number of nodes which it contains. DZY wants to know the sum of the sizes of all the connected sets. Can you help him count it? The answer may be large. Please output modulo 109+7. Input First line contains t denoting the number of testcases.t testcases follow. In each testcase, first line contains n. In lines 2∼n, ith line contains pi, meaning there is an edge between node i and node pi. (1≤pi≤i−1,2≤i≤n) (n≥1， sum of n in all testcases does not exceed 200000)Output Output one line for each testcase, modulo 109+7.Sample Input 2 1 5 1 2 2 3Sample Output 1 42题解 ans[i]由两部分组成，这个节点做的贡献dp[u](sum[x]+1) 孩子做的贡献dp[x]sum[u] 具体看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;const int mod=1e9+7;int T,n;ll dp[N],sum[N],head[N],cnt;ll ans;struct node&#123; int v,nxt;&#125;e[N];void readin()&#123; scanf("%d",&amp;n); rep(i,2,n)&#123; int x; scanf("%d",&amp;x); e[cnt].v=i; e[cnt].nxt=head[x]; head[x]=cnt++; &#125;&#125;void dfs(int u)&#123; sum[u]=1; dp[u]=1; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int x=e[i].v; dfs(x); dp[u]=(dp[u]*(sum[x]+1)%mod+dp[x]*sum[u]%mod)%mod;//新加的点做的贡献+这个孩子原来做的贡献 sum[u]=(sum[u]*(sum[x]+1))%mod; &#125; ans=(ans+dp[u])%mod;&#125;int main()&#123; //ios::sync_with_stdio(false); scanf("%d",&amp;T); while(T--)&#123; ans=0; cnt=0; memset(head,-1,sizeof(head)); readin(); dfs(1); //cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2196]]></title>
    <url>%2Fhdu2196%2F</url>
    <content type="text"><![CDATA[链接:hdu2196 Description A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. Input Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. Output For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).Sample Input 5 1 1 2 1 3 1 1 1Sample Output 3 2 3 4 4题解 对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点， 或者经过他父亲到达的一个节点。但是可能当前节点在根节点最远距离的路径上 父节点存的最大值可能正好是从该点过来的 1]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5627]]></title>
    <url>%2Fhdu5627%2F</url>
    <content type="text"><![CDATA[链接:hdu5627 Description Clarke is a patient with multiple personality disorder. One day he turned into a learner of graph theory. He learned some algorithms of minimum spanning tree. Then he had a good idea, he wanted to find the maximum spanning tree with bit operation AND. A spanning tree is composed by n−1 edges. Each two points of n points can reach each other. The size of a spanning tree is generated by bit operation AND with values of n−1 edges. Now he wants to figure out the maximum spanning tree. Input The first line contains an integer T(1≤T≤5), the number of test cases. For each test case, the first line contains two integers n,m(2≤n≤300000,1≤m≤300000), denoting the number of points and the number of edge 、 respectively. Then mlines followed, each line contains three integers x,y,w(1≤x,y≤n,0≤w≤109), denoting an 、 edge between x,ywith value w. The number of test case with n,m&gt;100000 will not exceed 1. Output For each test case, print a line contained an integer represented the answer. If there is no any spanning tree, print 0.Sample Input 1 4 5 1 2 5 1 3 3 1 4 2 2 3 1 3 4 7Sample Output 1题解 按位与最大生成树，从最高位贪心到最低位，看该位和其他已经获得的位能否构成生成树 能构成就加上这一位，不然就扔掉 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e6;int x[N],y[N],w[N],f[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x);y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); int ans=0; repd(i,20,0)&#123; ans+=(1&lt;&lt;i); rep(j,1,m)f[j]=j; int cnt=0; rep(j,1,m)if((w[j]&amp;ans)==ans&amp;&amp;un(x[j],y[j]))cnt++; //注意此处不是(w[j]&amp;(1&lt;&lt;i))==(1&lt;&lt;i) if(cnt!=n-1)ans-=(1&lt;&lt;i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5651]]></title>
    <url>%2Fhdu5651%2F</url>
    <content type="text"><![CDATA[链接:hdu5651 Description As we all known, xiaoxin is a brilliant coder. He knew palindromic strings when he was only a six grade student at elementry school. This summer he was working at Tencent as an intern. One day his leader came to ask xiaoxin for help. His leader gave him a string and he wanted xiaoxin to generate palindromic strings for him. Once xiaoxin generates a different palindromic string, his leader will give him a watermelon candy. The problem is how many candies xiaoxin’s leader needs to buy? Input This problem has multi test cases. First line contains a single integer T(T≤20) which represents the number of test cases. For each test case, there is a single line containing a string S(1≤length(S)≤1,000).Output For each test case, print an integer which is the number of watermelon candies xiaoxin’s leader needs to buy after mod 1,000,000,007.Sample Input 3 aa aabb aSample Output 1 2 1题解 如果奇数大于1肯定无解，然后所有字母出现次数除2，按照不相异的元素的全排列公式进行计算，然后用乘法逆元做一下， 乘法逆元用拓展欧几里得做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;const ll p=1000000007;char str[N];int a[30],T,len,cnt,flag;int exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0; d=a;&#125; else &#123;exgcd(b,a%b,d,x,y); ll t=x;x=y;y=t-a/b*x;&#125;&#125;ll inv(ll a,ll p)&#123; ll d,x,y; exgcd(a,p,d,x,y); return d==1?(x%p+p)%p:-1;&#125;void readin()&#123; cin&gt;&gt;str; len=strlen(str);cnt=flag=0; memset(a,0,sizeof(a)); rep(i,0,len-1)a[str[i]-'a']++; rep(i,0,29)&#123; if(a[i]&amp;1)flag++; if(a[i])&#123; a[i]&gt;&gt;=1; cnt+=a[i]; &#125; &#125;&#125;ll sum(ll X)&#123; ll tp=1; rep(i,2,X)tp=tp*i%p; return tp;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; readin(); if(flag&gt;1)&#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; rep(i,0,26)if(a[i]!=0)&#123; a[i]=sum(a[i]); a[i]=inv(a[i],p); &#125; ll ans=sum(cnt); rep(i,0,26)if(a[i])ans=ans*a[i]%p; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里德</category>
      </categories>
      <tags>
        <tag>拓展欧几里德</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2044]]></title>
    <url>%2Flg2044%2F</url>
    <content type="text"><![CDATA[链接:lg2044 Description 栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随 机数列，这种方法需要设置四个非负整数参数m,a,c,X[0],按照下面的公式生成出一系列随机数{Xn}： X[n+1]=(aX[n]+c) mod m 其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。 用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的C++和Pascal的产生随机数的库函数使用的也是这 种方法。 栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道X[n]是多少。由于栋栋需要的随机数是0,1,…,g-1之间的， 他需要将X[n]除以g取余得到他想要的数，即X[n] mod g，你只需要告诉栋栋他想要的数X[n] mod g是多少就可以了。 Input 输入包含6个用空格分割的整数m,a,c,X[0],n和g，其中a,c,X[0]是非负整数，m,n,g是正整数。Output 输出一个数，即X[n] mod gSample Input 11 8 7 1 5 3Sample Output 2题解 矩阵快速幂模板 注意要用快速乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;ll n,m,A,c,d,p; struct mat&#123; ll a[2][2];&#125;; mat T=&#123;1,1,0,1&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;m&gt;&gt;A&gt;&gt;c&gt;&gt;d&gt;&gt;n&gt;&gt;p;&#125;ll K(ll x,ll y)&#123; ll ans=0; x%=m;y%=m; while(y)&#123; if(y&amp;1)ans=(ans+x)%m; x=(x+x)%m; y&gt;&gt;=1; &#125; return ans;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; //cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"j="&lt;&lt;j&lt;&lt;' '&lt;&lt;x.a[i][k]*y.a[k][j]&lt;&lt;' '&lt;&lt;ans.a[i][j]&lt;&lt;endl; //cout&lt;&lt;K(x.a[i][k],y.a[k][j])&lt;&lt;endl; ans.a[i][j]=(ans.a[i][j]+K(x.a[i][k],y.a[k][j]))%m; &#125; return ans;&#125;void solve()&#123; readin(); T.a[0][0]=A; mat ans=&#123;0,d,0,c&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1]%p&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1962]]></title>
    <url>%2Flg1962%2F</url>
    <content type="text"><![CDATA[链接:lg1962 Description 大家都知道，斐波那契数列是满足如下性质的一个数列：• f(1) = 1• f(2) = 1• f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数) 请你求出 f(n) mod 1000000007 的值。 Input 第 1 行：一个整数 nOutput 第 1 行： f(n) mod 1000000007 的值Sample Input1: 52: 10Sample Output1: 52: 55 题解 F(n)=F(n-1)+F(n-2) 构造T：{1,1 和A(n-1){F(n-1) 1,0} F(n-2)} 乘起来就得到F(n)，然后这就是个等比数列 然后就可以用快速幂了(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int p=1000000007;struct mat&#123; ll a[2][2];&#125;;ll n;mat T=&#123;1,1,1,0&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%p; &#125; return ans;&#125;void solve()&#123; n-=2; mat ans=&#123;0,1,0,1&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1];&#125;int main()&#123; readin(); if(n==1||n==2)cout&lt;&lt;1&lt;&lt;endl; else solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯国王的烦恼]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯国王的烦恼 Description C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然 而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛 互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。 Input 输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。Output 输出一个整数，表示居民们会抗议的天数。Sample Input 4 4 1 2 2 1 3 2 2 3 1 3 4 3Sample Output 2题解 一道很简单的并查集，拆了就不连通，相当于加上才连通 然后并查集维护一下就ok了，然后要注意的是时间相同的点的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;int f[N],n,m,ans;struct node&#123; int u,v,w;&#125;e[N];bool cmp(node x,node y)&#123; return x.w&gt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; sort(e+1,e+m+1,cmp); rep(i,1,n)f[i]=i;&#125;int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;void solve()&#123; readin(); int pre=-1; rep(i,1,m)if(un(e[i].u,e[i].v)&amp;&amp;pre!=e[i].w)ans++,pre=e[i].w; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯城市建设]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯城市建设 Description 栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮 助他。 C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个 地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。 栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。 市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。 Input 输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。 接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则 表示建设了道路后还可以赚钱（比如建设收费道路）。 接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设 码头。 输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。Output 输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一 个负数。Sample Input 5 5 1 2 4 1 3 -1 2 3 3 2 4 5 4 5 10 -1 10 10 1 1Sample Output 9题解 跑两遍最小生成树，一遍不带码头，一遍带 码头的处理：将所有码头和0点连起来形成通路 然后注意一点就是权值为负值的路一定要加，赚钱的(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=123456;int f[N],n,m,cnt;ll ans1,ans2;struct node&#123; int u,v,w; inline void init(int x,int y,int z)&#123; u=x;v=y;w=z; &#125;&#125;e[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=y;&#125; bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m;cnt=m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; rep(i,1,n)&#123; int x; cin&gt;&gt;x; e[i+m].init(0,i,x); if(e[i+m].w==-1)e[i+m].w=-0x3f3f3f3f; &#125; sort(e+1,e+n+m+1,cmp); rep(i,1,n)f[i]=i;&#125;void kruskal_first()&#123; readin(); rep(i,1,n+m)&#123; if(e[i].w==-0x3f3f3f3f)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans1+=e[i].w; &#125; &#125;&#125;void kruskal_second()&#123; rep(i,1,n)f[i]=i; rep(i,1,n+m)&#123; if(e[i].u==0)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans2+=e[i].w; &#125; &#125;&#125;int main()&#123; kruskal_first(); kruskal_second(); int sum=0; rep(i,1,n)if(f[i]==i)sum++; if(sum==1)cout&lt;&lt;min(ans1,ans2); else cout&lt;&lt;ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1195]]></title>
    <url>%2Flg1195%2F</url>
    <content type="text"><![CDATA[链接:lg1195 Description 小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 给你云朵的个数N，再给你M个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成K个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 Input 每组测试数据的 第一行有三个数N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=10000,1&lt;=K&lt;=10) 接下来M个数每行三个数X,Y,L，表示X云和Y云可以通过L的代价连在一起。(1&lt;=X,Y&lt;=N,0&lt;=L&lt;10000) 30%的数据N&lt;=100,M&lt;=1000Output 对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出K个棉花糖，请输出’No Answer’。Sample Input 3 1 2 1 2 1Sample Output 1题解 建一个包含n-k-1个节点的最小生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=1e5+10;struct node &#123; int u,v,w;&#125;e[N];int n,m,k,ans;int f[N];int cmp(const void *a,const void *b)&#123; return ((node*)a)-&gt;w-((node*)b)-&gt;w;&#125;int find(int x)&#123; return f[x]==x?f[x]:f[x]=find(f[x]);&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=f[y];&#125;void Kruskal()&#123; qsort(e,m,sizeof(e[0]),cmp); rep(i,1,n+1)f[i]=i; int cnt=0; rep(i,0,m)&#123; int x=e[i].u,y=e[i].v; if(find(x)!=find(y))&#123; un(x,y); ans+=e[i].w; cnt++; &#125; if(cnt==k)break; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; ans=0; rep(i,0,m)scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); k=n-k; if(k&lt;=m)Kruskal(); if(ans)printf("%d\n",ans); else printf("No Answer\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5586]]></title>
    <url>%2Fhdu5586%2F</url>
    <content type="text"><![CDATA[链接:hdu5586 Problem Description There is a number sequence {A}_{1},{A}_{2}….{A}_{n},you can select a interval [l,r] or not,all the numbers {A}_{i}(l \leq i \leq r) will become f({A}_{i}).f(x)=(1890x+143) mod 10007.After that,the sum of n numbers should be as much as possible.What is the maximum sum? Input There are multiple test cases. First line of each case contains a single integer n.(1\leq n\leq {10}^{5}) Next line contains n integers {A}_{1},{A}_{2}….{A}_{n}.(0\leq {A}_{i}\leq {10}^{4}) It’s guaranteed that \sum n\leq {10}^{6}. Output For each test case,output the answer in a line.Sample Input 2 10000 9999 5 1 9999 1 9999 1 Sample Output19999 22033 题解 最大子段和 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;const int mod=10007;ll a[N],b[N],c[N],ans;int n,m;int f(ll x)&#123; return (x%mod*1890+143)%mod;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; ans=0; rep(i,1,n)&#123; scanf("%lld",&amp;a[i]); b[i]=f(a[i])-a[i]; ans+=a[i]; &#125; int tp=0,k=0; rep(i,1,n)&#123; if(tp+b[i]&gt;0)tp+=b[i]; else tp=0; if(tp&gt;k)k=tp; &#125; printf("%lld\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相交弦统计]]></title>
    <url>%2F%E7%9B%B8%E4%BA%A4%E5%BC%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Description Kimi 最近得到了一个玩具，玩具由环和弦两个部分组成。环上有 2*N 个端 点，而 N 条弦，每条连接其中的两个，既不重复也不遗漏。Kimi 对这些弦产生 了浓厚的兴趣，他想数一数，一共有多少对弦是相交的呢？ Input 输入文件的第一行包含一个整数 N。 接下来 N 行，每行包含两个整数 a、b(1≤a，b≤2*N)，表示一条连接 a，b 的弦Output 输出文件中近包含一个整数，表示相交弦的对Sample Input 3 2 5 2 6 3Sample Output 1题解 两条弦相交只需要保证其中一条的一个点在另一条的两个端点之间 然后树状数组or线段树维护一下前n个数有多少个左or右端点就好 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;const int N=1e6;ll tr[N&lt;&lt;1],n;struct node&#123; int l,r;&#125;e[N];int cmp(node x,node y)&#123;return x.l&lt;y.l;&#125;void update(int x,int k)&#123;for(register int i=x;i&lt;=n&lt;&lt;1;i+=lowbit(i))tr[i]+=k;&#125;ll ask(int x)&#123;ll ans=0; for(register int i=x;i;i-=lowbit(i))ans+=tr[i];return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; rep(i,1,n)&#123; cin&gt;&gt;e[i].l&gt;&gt;e[i].r; if(e[i].l&gt;e[i].r)swap(e[i].l,e[i].r); &#125; sort(e+1,e+n+1,cmp); rep(i,1,n)&#123; ans+=ask(e[i].r-1)-ask(e[i].l); update(e[i].r,1); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468]]></title>
    <url>%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[链接:poj3468 Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. Input The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. “C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000. “Q a b” means querying the sum of Aa, Aa+1, … , Ab. Output You need to answer all Q commands in order. One answer in a line.Sample Input 10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4Sample Output 4 55 9 15题解 区间修改区间查询 维护个懒标记就好，具体看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;ll tr[N&lt;&lt;2],a[N],add[N];int n,m;void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1]; &#125;&#125;void pushdown(int o,int l,int r)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; //懒标记下放 add[o&lt;&lt;1|1]+=add[o]; int mid=l+r&gt;&gt;1; tr[o&lt;&lt;1]+=add[o]*(mid-l+1); tr[o&lt;&lt;1|1]+=add[o]*(r-mid); add[o]=0; &#125;&#125;void update(int o,int l,int r,int L,int R,ll k)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; add[o]+=k; tr[o]+=k*(r-l+1); return ; //做个标记，不下放 &#125; pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(o&lt;&lt;1,l,mid,L,R,k); if(R&gt;mid)update(o&lt;&lt;1|1,mid+1,r,L,R,k); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=ask(o&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1)ans+=ask(o&lt;&lt;1|1,mid+1,r,L,R); return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; char p; ll x,y; cin&gt;&gt;p&gt;&gt;x&gt;&gt;y; if(p=='C')&#123; ll k; cin&gt;&gt;k; update(1,1,n,x,y,k); &#125; else cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2299]]></title>
    <url>%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[链接:poj2299 Description In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence 9 1 0 5 4 , Ultra-QuickSort produces the output 0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. Input The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999, 999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.Output For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.Sample Input 5 9 1 0 5 4 3 1 2 3 0Sample Output 6 0题解 求逆序对数目 开一个大小为这些数的最大值的树状数组，并全部置0。从头到尾读入这些数，每读入一个数就更新树状数组，查看它前面比它小的已出现 过的有多少个数 sum，然后用当前位置减去该sum，就可以得到当前数导致的逆序对数了。把所有的加起来就是总的逆序对数。 然而问题来了，数据最大999999999，显然开不下 解决方法是离散化一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e6+100;struct node&#123; int val,pos;&#125;b[N];int a[N],tree[N],n;ll ans;bool cmp(node x,node y)&#123; return x.val&lt;y.val;&#125;void add(int x,int k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tree[i]+=k;&#125;int getsum(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=lowbit(i))ans+=tree[i]; return ans;&#125;void readin()&#123; rep(i,1,n)&#123; cin&gt;&gt;b[i].val; b[i].pos=i; &#125; memset(a,0,sizeof(a)); memset(tree,0,sizeof(tree)); sort(b+1,b+n+1,cmp); rep(i,1,n)&#123; add(b[i].pos,1); //离散化 ans+=i-getsum(b[i].pos); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; if(n==0)break; ans=0; readin(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1754]]></title>
    <url>%2Fhdu1754%2F</url>
    <content type="text"><![CDATA[链接:hdu1754 Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output 对于每一次询问操作，在一行里面输出最高成绩。Sample Input 5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5Sample Output 5 6 5 9题解 单点查询区间修改 线段树模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll tr[N&lt;&lt;2];int n,m,a[N];void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;void update(int o,int l,int r,int pos,int k)&#123; if(l==r)tr[o]=k; else &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)update(o&lt;&lt;1,l,mid,pos,k); else update(o&lt;&lt;1|1,mid+1,r,pos,k); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&gt;r||R&lt;l)return -1; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; int mid=l+r&gt;&gt;1; int p1=ask(o&lt;&lt;1,l,mid,L,R),p2=ask(o&lt;&lt;1|1,mid+1,r,L,R); return max(p1,p2);&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; int x,y; char c; cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c=='Q')cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; else update(1,1,n,x,y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
