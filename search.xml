<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spfa]]></title>
    <url>%2Fspfa%2F</url>
    <content type="text"><![CDATA[SPFA: Shortest Path Faster Algorithm看到名字不禁为之一颤，SPFA算法是西南交通大学段凡丁于1994年发表的。 SPFA 也是竞赛中最常见的算法之一，不仅仅用来解决带负权的单源最短路 而且是求解差分约束问题的专用算法，也常用它和最大流合作解决最小费问题 SPFA 算法的最坏复杂度为 O(2*E)。。 SPFA 和dijkstra 格式很接近，只是加了个队列或栈就变得无比神奇了。 这里用邻接表形式写下spfa 的模板 后面再介绍它的其它功能，这里只知道它处理最短路很快即可 优点可以处理负权，判负环，快 代码12345678910111213141516171819202122queue&lt;int&gt; q;int spfa(int s,int t)&#123; memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(vis)); //memset(c,0,sizeof(c)); q.push(s); in[s]=1; //c[s]=1; while(!q.empty())&#123; int k=q.front();q.pop(); in[k]=0; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i]&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])&#123; q.push(e[i].t); in[e[i].t]++; c[e[i].t]++; //if(c[e[i].t]&gt;n)return ok=0 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra优化]]></title>
    <url>%2Fdijkstra%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化dijkstra 注意到贪心的过程是每次选取最小的dis值出来，这里是O(n)的，我们可以用优先队列把他优化到O(logn) 12345678910111213141516171819typedef pair&lt;int,int&gt; l;priority_queue&lt;s,vector&lt;s&gt;,greater&lt;s&gt; &gt;q;int dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(0)); d[s]=0;in[s]=1; q.push(l(0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i].w&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])q.push(l(d[i],e[i].t)); &#125; &#125; return d[t]!=inf?d[t]:-1;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra算法详解]]></title>
    <url>%2Fdijkstra%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最短路从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径 解决算法： floyd dijkstra spfa dijktsra优化 spfa优化 dijkstra算法介绍 算法思路: 利用贪心的思想，维护一个dis数组，值为源点到各个顶点的最短距离，以及一个vis数组，表示该点已经算出最短路的点的集合 每次找到dis值最小的顶点（这个dis值就是改点到源点的最短距离），标记它，然后用它来松弛可以松弛的点， 时间复杂度： 很显然是O(n2)的 *缺点：无法处理负权代码int dijkstra(int s,int t){ rep(i,1,n+1){ d[i]=g[s][i]; vis[i]=0; } vis[s]=1; rep(i,2,n+1){ int mx=inf,k=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;d[j]&lt;mx){ mx=d[j]; k=j; } vis[k]=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;mx+g[k][j]&lt;d[j]){ d[j]=mx+g[k][j]; } } return d[t]!=inf?d[t]:-1; }]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3252]]></title>
    <url>%2Fpoj3252%2F</url>
    <content type="text"><![CDATA[链接:poj3252 DescriptionThe cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone&apos; (also known as &apos;Rock, Paper, Scissors&apos;, &apos;Ro, Sham, Bo&apos;, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can&apos;t even flip a coin because it&apos;s so hard to toss using hooves. They have thus resorted to &quot;round number&quot; matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both &quot;round numbers&quot;, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a &quot;round number&quot; if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many &quot;round numbers&quot; are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start &lt; Finish ≤ 2,000,000,000). InputLine 1: Two space-separated integers, respectively Start and Finish. OutputLine 1: A single integer that is the count of round numbers in the inclusive range Start..Finish Sample Input2 12 Sample Output6 题解模板题 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)const int N=66;int a[N],dp[N][N];//当前第i位，零的个数为j共有多少种情况 int dfs(int pos,int sta,int limit,int lead)&#123; if(pos==-1)return sta&gt;=32;; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:1; int tmp=0; rep(i,0,up+1)&#123; if(i==0&amp;&amp;lead)tmp+=dfs(pos-1,sta,limit&amp;&amp;i==a[pos],lead); else tmp+=dfs(pos-1,sta+(i==0?1:-1),i==a[pos]&amp;&amp;limit,lead&amp;&amp;i==0); &#125; if(!limit&amp;&amp;!lead)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x&amp;1; x&gt;&gt;=1; &#125; return dfs(cnt-1,32,1,1);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4734]]></title>
    <url>%2Fhdu4734%2F</url>
    <content type="text"><![CDATA[链接:hdu4734 DescriptionFor a decimal number x with n digits (AnAn-1An-2 ... A2A1), we define its weight as F(x) = An * 2n-1 + An-1 * 2n-2 + ... + A2 * 2 + A1 * 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). InputThe first line has a number T (T &lt;= 10000) , indicating the number of test cases. For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109) OutputFor every case,you should output &quot;Case #t: &quot; at first, without quotes. The t is the case number starting from 1. Then output the answer. Sample Input3 0 100 1 10 5 100 Sample OutputCase #1: 1 Case #2: 2 Case #3: 13 题解模板题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)using namespace std;const int N=4600;int a[10],dp[10][N];int n;int dfs(int pos,int limit,int sum)&#123; if(sum&lt;0)return 0; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sum]!=-1)return dp[pos][sum]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(pos-1,limit&amp;&amp;i==a[pos],sum-i*(1&lt;&lt;pos)); &#125; if(!limit)dp[pos][sum]=tmp; return tmp;&#125;int solve(int x,int y)&#123; int cnt=0,len=0,ans=0; while(y)&#123; ans+=y%10*(1&lt;&lt;len); len++; y/=10; &#125; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,1,ans);&#125;int main()&#123; scanf("%d",&amp;n); memset(dp,-1,sizeof(dp)); rep(i,0,n)&#123; int A,B; scanf("%d%d",&amp;A,&amp;B); printf("Case #%d: %d\n",i+1,solve(B,A)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3709]]></title>
    <url>%2Fhdu3709%2F</url>
    <content type="text"><![CDATA[链接:hdu3709 DescriptionA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 4*2 + 1*1 = 9 and 9*1 = 9, for left part and right part, respectively. It&apos;s your job to calculate the number of balanced numbers in a given range [x, y]. InputThe input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018). OutputFor each case, print the number of balanced numbers in the range [x, y] in a line. Sample Input2 0 9 7604 24324 Sample Output10 897 题解模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=22;ll dp[N][N][2000];//第i位，枢轴为j的时候和为k时共有多少种情况满足符合要求 int a[N];ll dfs(int len,int pos,int limit,int sta)&#123; if(len==-1)return sta?0:1; if(sta&lt;0)return 0; if(!limit&amp;&amp;dp[len][pos][sta]!=-1)return dp[len][pos][sta]; int up=limit?a[len]:9; ll tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(len-1,pos,limit&amp;&amp;i==a[len],sta+i*(len-pos)); &#125; if(!limit)dp[len][pos][sta]=tmp; return tmp;&#125;ll solve(ll x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; ll ans=0; rep(i,0,cnt)&#123; ans+=dfs(cnt-1,i,1,0); &#125; return ans-cnt+1;&#125;int main()&#123; ll l,r; int T; scanf("%d",&amp;T); memset(dp,-1,sizeof(dp)); while(T--)&#123; scanf("%lld%lld",&amp;l,&amp;r); printf("%lld\n",solve(r)-solve(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2089]]></title>
    <url>%2Fhdu2089%2F</url>
    <content type="text"><![CDATA[链接:hdu2089 Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别 的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input1 100 0 0 Sample Output80 题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define rep(i,l,n)for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=55;int a[N];ll dp[N][2];//当前第i位，前置有或没有6共有多少种情况 int dfs(int pos,int pre,int sta,int limit)&#123; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; if(pre==6&amp;&amp;i==2)continue; if(i==4)continue; tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;a[pos]==i); &#125; if(!limit)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,-1,0,true);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp));//不管l与r怎么给 已经计算出来的状态是不会改变的 while(~scanf("%d%d",&amp;l,&amp;r))&#123; if(l==0&amp;&amp;r==0)break; printf("%d\n",solve(r)-solve(l-1)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1352]]></title>
    <url>%2Flg1352%2F</url>
    <content type="text"><![CDATA[链接:lg1352 Description InputOutputSample InputSample Output题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)using namespace std;const int N=1e4;int fa[N],r[N],dp[N][2],vis[N];int n,root=1;template &lt;typename T&gt;inline void read(T&amp;x)&#123; x=0;char c;int sign=1; do&#123; c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123; x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void tdp(int node)&#123; vis[node]=1; rep(i,1,n)if(!vis[i]&amp;&amp;fa[i]==node)&#123; tdp(i); dp[node][1]+=dp[i][0]; dp[node][0]+=max(dp[i][1],dp[i][0]); &#125;&#125;int main()&#123; read(n); rep(i,1,n)read(dp[i][1]); rep(i,1,n-1)&#123; int x,y; read(x);read(y); fa[x]=y; &#125; rep(i,1,n)if(!fa[i])&#123; root=i;break; &#125; tdp(root); printf("%d",max(dp[root][1],dp[root][0])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5647]]></title>
    <url>%2Fhdu5647%2F</url>
    <content type="text"><![CDATA[链接:hdu5647 DescriptionDZY has an unrooted tree consisting of n nodes labeled from 1 to n. DZY likes connected sets on the tree. A connected set S is a set of nodes, such that every two nodes u,v in S can be connected by a path on the tree, and the path should only contain nodes from S. Obviously, a set consisting of a single node is also considered a connected set. The size of a connected set is defined by the number of nodes which it contains. DZY wants to know the sum of the sizes of all the connected sets. Can you help him count it? The answer may be large. Please output modulo 109+7. InputFirst line contains t denoting the number of testcases.t testcases follow. In each testcase, first line contains n. In lines 2∼n, ith line contains pi, meaning there is an edge between node i and node pi. (1≤pi≤i−1,2≤i≤n) (n≥1， sum of n in all testcases does not exceed 200000) OutputOutput one line for each testcase, modulo 109+7. Sample Input2 1 5 1 2 2 3 Sample Output1 42 题解ans[i]由两部分组成，这个节点做的贡献dp[u]*(sum[x]+1) 孩子做的贡献dp[x]*sum[u] 具体看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;const int mod=1e9+7;int T,n;ll dp[N],sum[N],head[N],cnt;ll ans;struct node&#123; int v,nxt;&#125;e[N];void readin()&#123; scanf("%d",&amp;n); rep(i,2,n)&#123; int x; scanf("%d",&amp;x); e[cnt].v=i; e[cnt].nxt=head[x]; head[x]=cnt++; &#125;&#125;void dfs(int u)&#123; sum[u]=1; dp[u]=1; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int x=e[i].v; dfs(x); dp[u]=(dp[u]*(sum[x]+1)%mod+dp[x]*sum[u]%mod)%mod;//新加的点做的贡献+这个孩子原来做的贡献 sum[u]=(sum[u]*(sum[x]+1))%mod; &#125; ans=(ans+dp[u])%mod;&#125;int main()&#123; //ios::sync_with_stdio(false); scanf("%d",&amp;T); while(T--)&#123; ans=0; cnt=0; memset(head,-1,sizeof(head)); readin(); dfs(1); //cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2196]]></title>
    <url>%2Fhdu2196%2F</url>
    <content type="text"><![CDATA[链接:hdu2196 DescriptionA school bought the first computer some time ago(so this computer&apos;s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. InputInput file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. OutputFor each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). Sample Input5 1 1 2 1 3 1 1 1 Sample Output3 2 3 4 4 题解对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点， 或者经过他父亲到达的一个节点。但是可能当前节点在根节点最远距离的路径上 父节点存的最大值可能正好是从该点过来的 1]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5627]]></title>
    <url>%2Fhdu5627%2F</url>
    <content type="text"><![CDATA[链接:hdu5627 DescriptionClarke is a patient with multiple personality disorder. One day he turned into a learner of graph theory. He learned some algorithms of minimum spanning tree. Then he had a good idea, he wanted to find the maximum spanning tree with bit operation AND. A spanning tree is composed by n−1 edges. Each two points of n points can reach each other. The size of a spanning tree is generated by bit operation AND with values of n−1 edges. Now he wants to figure out the maximum spanning tree. InputThe first line contains an integer T(1≤T≤5), the number of test cases. For each test case, the first line contains two integers n,m(2≤n≤300000,1≤m≤300000), denoting the number of points and the number of edge 、 respectively. Then mlines followed, each line contains three integers x,y,w(1≤x,y≤n,0≤w≤109), denoting an 、 edge between x,ywith value w. The number of test case with n,m&gt;100000 will not exceed 1. OutputFor each test case, print a line contained an integer represented the answer. If there is no any spanning tree, print 0. Sample Input1 4 5 1 2 5 1 3 3 1 4 2 2 3 1 3 4 7 Sample Output1 题解按位与最大生成树，从最高位贪心到最低位，看该位和其他已经获得的位能否构成生成树 能构成就加上这一位，不然就扔掉 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e6;int x[N],y[N],w[N],f[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x);y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); int ans=0; repd(i,20,0)&#123; ans+=(1&lt;&lt;i); rep(j,1,m)f[j]=j; int cnt=0; rep(j,1,m)if((w[j]&amp;ans)==ans&amp;&amp;un(x[j],y[j]))cnt++; //注意此处不是(w[j]&amp;(1&lt;&lt;i))==(1&lt;&lt;i) if(cnt!=n-1)ans-=(1&lt;&lt;i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5651]]></title>
    <url>%2Fhdu5651%2F</url>
    <content type="text"><![CDATA[链接:hdu5651 DescriptionAs we all known, xiaoxin is a brilliant coder. He knew **palindromic** strings when he was only a six grade student at elementry school. This summer he was working at Tencent as an intern. One day his leader came to ask xiaoxin for help. His leader gave him a string and he wanted xiaoxin to generate palindromic strings for him. Once xiaoxin generates a different palindromic string, his leader will give him a watermelon candy. The problem is how many candies xiaoxin&apos;s leader needs to buy? InputThis problem has multi test cases. First line contains a single integer T(T≤20) which represents the number of test cases. For each test case, there is a single line containing a string S(1≤length(S)≤1,000). OutputFor each test case, print an integer which is the number of watermelon candies xiaoxin&apos;s leader needs to buy after mod 1,000,000,007. Sample Input3 aa aabb a Sample Output1 2 1 题解如果奇数大于1肯定无解，然后所有字母出现次数除2，按照不相异的元素的全排列公式进行计算，然后用乘法逆元做一下， 乘法逆元用拓展欧几里得做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;const ll p=1000000007;char str[N];int a[30],T,len,cnt,flag;int exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0; d=a;&#125; else &#123;exgcd(b,a%b,d,x,y); ll t=x;x=y;y=t-a/b*x;&#125;&#125;ll inv(ll a,ll p)&#123; ll d,x,y; exgcd(a,p,d,x,y); return d==1?(x%p+p)%p:-1;&#125;void readin()&#123; cin&gt;&gt;str; len=strlen(str);cnt=flag=0; memset(a,0,sizeof(a)); rep(i,0,len-1)a[str[i]-'a']++; rep(i,0,29)&#123; if(a[i]&amp;1)flag++; if(a[i])&#123; a[i]&gt;&gt;=1; cnt+=a[i]; &#125; &#125;&#125;ll sum(ll X)&#123; ll tp=1; rep(i,2,X)tp=tp*i%p; return tp;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; readin(); if(flag&gt;1)&#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; rep(i,0,26)if(a[i]!=0)&#123; a[i]=sum(a[i]); a[i]=inv(a[i],p); &#125; ll ans=sum(cnt); rep(i,0,26)if(a[i])ans=ans*a[i]%p; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里得</category>
      </categories>
      <tags>
        <tag>拓展欧几里得</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2044]]></title>
    <url>%2Flg2044%2F</url>
    <content type="text"><![CDATA[链接:lg2044 Description栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随 机数列，这种方法需要设置四个非负整数参数m,a,c,X[0],按照下面的公式生成出一系列随机数{Xn}： X[n+1]=(aX[n]+c) mod m 其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。 用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的C++和Pascal的产生随机数的库函数使用的也是这 种方法。 栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道X[n]是多少。由于栋栋需要的随机数是0,1,...,g-1之间的， 他需要将X[n]除以g取余得到他想要的数，即X[n] mod g，你只需要告诉栋栋他想要的数X[n] mod g是多少就可以了。 Input输入包含6个用空格分割的整数m,a,c,X[0],n和g，其中a,c,X[0]是非负整数，m,n,g是正整数。 Output输出一个数，即X[n] mod g Sample Input11 8 7 1 5 3 Sample Output2 题解矩阵快速幂模板 注意要用快速乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;ll n,m,A,c,d,p; struct mat&#123; ll a[2][2];&#125;; mat T=&#123;1,1,0,1&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;m&gt;&gt;A&gt;&gt;c&gt;&gt;d&gt;&gt;n&gt;&gt;p;&#125;ll K(ll x,ll y)&#123; ll ans=0; x%=m;y%=m; while(y)&#123; if(y&amp;1)ans=(ans+x)%m; x=(x+x)%m; y&gt;&gt;=1; &#125; return ans;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; //cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"j="&lt;&lt;j&lt;&lt;' '&lt;&lt;x.a[i][k]*y.a[k][j]&lt;&lt;' '&lt;&lt;ans.a[i][j]&lt;&lt;endl; //cout&lt;&lt;K(x.a[i][k],y.a[k][j])&lt;&lt;endl; ans.a[i][j]=(ans.a[i][j]+K(x.a[i][k],y.a[k][j]))%m; &#125; return ans;&#125;void solve()&#123; readin(); T.a[0][0]=A; mat ans=&#123;0,d,0,c&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1]%p&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1962]]></title>
    <url>%2Flg1962%2F</url>
    <content type="text"><![CDATA[链接:lg1962 Description大家都知道，斐波那契数列是满足如下性质的一个数列： • f(1) = 1 • f(2) = 1 • f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数) 请你求出 f(n) mod 1000000007 的值。 Input第 1 行：一个整数 n Output第 1 行： f(n) mod 1000000007 的值 Sample Input1: 52: 10 Sample Output1: 52: 55 题解F(n)=F(n-1)+F(n-2) 构造T：{1,1 和A(n-1){F(n-1) 1,0} F(n-2)} 乘起来就得到F(n)，然后这就是个等比数列 然后就可以用快速幂了(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int p=1000000007;struct mat&#123; ll a[2][2];&#125;;ll n;mat T=&#123;1,1,1,0&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%p; &#125; return ans;&#125;void solve()&#123; n-=2; mat ans=&#123;0,1,0,1&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1];&#125;int main()&#123; readin(); if(n==1||n==2)cout&lt;&lt;1&lt;&lt;endl; else solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯国王的烦恼]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯国王的烦恼 DescriptionC国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛 互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。 Input输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。 Output输出一个整数，表示居民们会抗议的天数。 Sample Input4 4 1 2 2 1 3 2 2 3 1 3 4 3 Sample Output2 题解一道很简单的并查集，拆了就不连通，相当于加上才连通 然后并查集维护一下就ok了，然后要注意的是时间相同的点的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;int f[N],n,m,ans;struct node&#123; int u,v,w;&#125;e[N];bool cmp(node x,node y)&#123; return x.w&gt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; sort(e+1,e+m+1,cmp); rep(i,1,n)f[i]=i;&#125;int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;void solve()&#123; readin(); int pre=-1; rep(i,1,m)if(un(e[i].u,e[i].v)&amp;&amp;pre!=e[i].w)ans++,pre=e[i].w; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯城市建设]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯城市建设 Description栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。 C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个 地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。 栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。 市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。 Input输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。 接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则 表示建设了道路后还可以赚钱（比如建设收费道路）。 接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设 码头。 输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。 Output输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。 Sample Input5 5 1 2 4 1 3 -1 2 3 3 2 4 5 4 5 10 -1 10 10 1 1 Sample Output9 题解跑两遍最小生成树，一遍不带码头，一遍带 码头的处理：将所有码头和0点连起来形成通路 然后注意一点就是权值为负值的路一定要加，赚钱的(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=123456;int f[N],n,m,cnt;ll ans1,ans2;struct node&#123; int u,v,w; inline void init(int x,int y,int z)&#123; u=x;v=y;w=z; &#125;&#125;e[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=y;&#125; bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m;cnt=m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; rep(i,1,n)&#123; int x; cin&gt;&gt;x; e[i+m].init(0,i,x); if(e[i+m].w==-1)e[i+m].w=-0x3f3f3f3f; &#125; sort(e+1,e+n+m+1,cmp); rep(i,1,n)f[i]=i;&#125;void kruskal_first()&#123; readin(); rep(i,1,n+m)&#123; if(e[i].w==-0x3f3f3f3f)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans1+=e[i].w; &#125; &#125;&#125;void kruskal_second()&#123; rep(i,1,n)f[i]=i; rep(i,1,n+m)&#123; if(e[i].u==0)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans2+=e[i].w; &#125; &#125;&#125;int main()&#123; kruskal_first(); kruskal_second(); int sum=0; rep(i,1,n)if(f[i]==i)sum++; if(sum==1)cout&lt;&lt;min(ans1,ans2); else cout&lt;&lt;ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1195]]></title>
    <url>%2Flg1195%2F</url>
    <content type="text"><![CDATA[链接:lg1195 Description小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 给你云朵的个数N，再给你M个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成K个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 Input每组测试数据的 第一行有三个数N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=10000,1&lt;=K&lt;=10) 接下来M个数每行三个数X,Y,L，表示X云和Y云可以通过L的代价连在一起。(1&lt;=X,Y&lt;=N,0&lt;=L&lt;10000) 30%的数据N&lt;=100,M&lt;=1000 Output对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出K个棉花糖，请输出&apos;No Answer&apos;。 Sample Input3 1 2 1 2 1 Sample Output1 题解建一个包含n-k-1个节点的最小生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=1e5+10;struct node &#123; int u,v,w;&#125;e[N];int n,m,k,ans;int f[N];int cmp(const void *a,const void *b)&#123; return ((node*)a)-&gt;w-((node*)b)-&gt;w;&#125;int find(int x)&#123; return f[x]==x?f[x]:f[x]=find(f[x]);&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=f[y];&#125;void Kruskal()&#123; qsort(e,m,sizeof(e[0]),cmp); rep(i,1,n+1)f[i]=i; int cnt=0; rep(i,0,m)&#123; int x=e[i].u,y=e[i].v; if(find(x)!=find(y))&#123; un(x,y); ans+=e[i].w; cnt++; &#125; if(cnt==k)break; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; ans=0; rep(i,0,m)scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); k=n-k; if(k&lt;=m)Kruskal(); if(ans)printf("%d\n",ans); else printf("No Answer\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5586]]></title>
    <url>%2Fhdu5586%2F</url>
    <content type="text"><![CDATA[链接:hdu5586 Problem DescriptionThere is a number sequence {A}_{1},{A}_{2}....{A}_{n},you can select a interval [l,r] or not,all the numbers {A}_{i}(l \leq i \leq r) will become f({A}_{i}).f(x)=(1890x+143) mod 10007.After that,the sum of n numbers should be as much as possible.What is the maximum sum? InputThere are multiple test cases. First line of each case contains a single integer n.(1\leq n\leq {10}^{5}) Next line contains n integers {A}_{1},{A}_{2}....{A}_{n}.(0\leq {A}_{i}\leq {10}^{4}) It&apos;s guaranteed that \sum n\leq {10}^{6}. OutputFor each test case,output the answer in a line. Sample Input2 10000 9999 5 1 9999 1 9999 1 Sample Output19999 22033 题解最大子段和 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;const int mod=10007;ll a[N],b[N],c[N],ans;int n,m;int f(ll x)&#123; return (x%mod*1890+143)%mod;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; ans=0; rep(i,1,n)&#123; scanf("%lld",&amp;a[i]); b[i]=f(a[i])-a[i]; ans+=a[i]; &#125; int tp=0,k=0; rep(i,1,n)&#123; if(tp+b[i]&gt;0)tp+=b[i]; else tp=0; if(tp&gt;k)k=tp; &#125; printf("%lld\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相交弦统计]]></title>
    <url>%2F%E7%9B%B8%E4%BA%A4%E5%BC%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[DescriptionKimi 最近得到了一个玩具，玩具由环和弦两个部分组成。环上有 2*N 个端 点，而 N 条弦，每条连接其中的两个，既不重复也不遗漏。Kimi 对这些弦产生 了浓厚的兴趣，他想数一数，一共有多少对弦是相交的呢？ Input输入文件的第一行包含一个整数 N。 接下来 N 行，每行包含两个整数 a、b(1≤a，b≤2*N)，表示一条连接 a，b 的弦 Output输出文件中近包含一个整数，表示相交弦的对 Sample Input3 2 5 2 6 3 Sample Output1 题解两条弦相交只需要保证其中一条的一个点在另一条的两个端点之间 然后树状数组or线段树维护一下前n个数有多少个左or右端点就好 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;const int N=1e6;ll tr[N&lt;&lt;1],n;struct node&#123; int l,r;&#125;e[N];int cmp(node x,node y)&#123;return x.l&lt;y.l;&#125;void update(int x,int k)&#123;for(register int i=x;i&lt;=n&lt;&lt;1;i+=lowbit(i))tr[i]+=k;&#125;ll ask(int x)&#123;ll ans=0; for(register int i=x;i;i-=lowbit(i))ans+=tr[i];return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; rep(i,1,n)&#123; cin&gt;&gt;e[i].l&gt;&gt;e[i].r; if(e[i].l&gt;e[i].r)swap(e[i].l,e[i].r); &#125; sort(e+1,e+n+1,cmp); rep(i,1,n)&#123; ans+=ask(e[i].r-1)-ask(e[i].l); update(e[i].r,1); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468]]></title>
    <url>%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[链接:poj3468 DescriptionYou have N integers, A1, A2, ... , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, ... , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. &quot;C a b c&quot; means adding c to each of Aa, Aa+1, ... , Ab. -10000 ≤ c ≤ 10000. &quot;Q a b&quot; means querying the sum of Aa, Aa+1, ... , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15 #题解 区间修改区间查询 维护个懒标记就好，具体看代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;ll tr[N&lt;&lt;2],a[N],add[N];int n,m;void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1]; &#125;&#125;void pushdown(int o,int l,int r)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; //懒标记下放 add[o&lt;&lt;1|1]+=add[o]; int mid=l+r&gt;&gt;1; tr[o&lt;&lt;1]+=add[o]*(mid-l+1); tr[o&lt;&lt;1|1]+=add[o]*(r-mid); add[o]=0; &#125;&#125;void update(int o,int l,int r,int L,int R,ll k)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; add[o]+=k; tr[o]+=k*(r-l+1); return ; //做个标记，不下放 &#125; pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(o&lt;&lt;1,l,mid,L,R,k); if(R&gt;mid)update(o&lt;&lt;1|1,mid+1,r,L,R,k); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=ask(o&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1)ans+=ask(o&lt;&lt;1|1,mid+1,r,L,R); return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; char p; ll x,y; cin&gt;&gt;p&gt;&gt;x&gt;&gt;y; if(p=='C')&#123; ll k; cin&gt;&gt;k; update(1,1,n,x,y,k); &#125; else cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2299]]></title>
    <url>%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[链接:poj2299 DescriptionIn this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence 9 1 0 5 4 , Ultra-QuickSort produces the output 0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. InputThe input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 -- the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. OutputFor every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. Sample Input5 9 1 0 5 4 3 1 2 3 0 Sample Output6 0 题解求逆序对数目 开一个能大小为这些数的最大值的树状数组，并全部置0。从头到尾读入这些数，每读入一个数就更新树状数组，查看它前面比它小的已出现过的有多少个数 sum，然后用当前位置减去该sum，就可以得到当前数导致的逆序对数了。把所有的加起来就是总的逆序对数。 然而问题来了，数据最大999999999，显然开不下 解决方法是离散化一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e6+100;struct node&#123; int val,pos;&#125;b[N];int a[N],tree[N],n;ll ans;bool cmp(node x,node y)&#123; return x.val&lt;y.val;&#125;void add(int x,int k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tree[i]+=k;&#125;int getsum(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=lowbit(i))ans+=tree[i]; return ans;&#125;void readin()&#123; rep(i,1,n)&#123; cin&gt;&gt;b[i].val; b[i].pos=i; &#125; memset(a,0,sizeof(a)); memset(tree,0,sizeof(tree)); sort(b+1,b+n+1,cmp); rep(i,1,n)&#123; add(b[i].pos,1); //离散化 ans+=i-getsum(b[i].pos); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; if(n==0)break; ans=0; readin(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1754]]></title>
    <url>%2Fhdu1754%2F</url>
    <content type="text"><![CDATA[链接:hdu1754 Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取&apos;Q&apos;或&apos;U&apos;) ，和两个正整数A，B。 当C为&apos;Q&apos;的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为&apos;U&apos;的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output5 6 5 9 题解单点查询区间修改 线段树模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll tr[N&lt;&lt;2];int n,m,a[N];void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;void update(int o,int l,int r,int pos,int k)&#123; if(l==r)tr[o]=k; else &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)add(o&lt;&lt;1,l,mid,pos,k); else add(o&lt;&lt;1|1,mid+1,r,pos,k); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&gt;r||R&lt;l)return -1; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; int mid=l+r&gt;&gt;1; int p1=ask(o&lt;&lt;1,l,mid,L,R),p2=ask(o&lt;&lt;1|1,mid+1,r,L,R); return max(p1,p2);&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; int x,y; char c; cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c=='Q')cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; else update(1,1,n,x,y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
