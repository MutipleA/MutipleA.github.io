<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[lgP2746[USACO5.3]校园网]]></title>
    <url>%2FlgP2746-USACO5-3-%E6%A0%A1%E5%9B%AD%E7%BD%91%2F</url>
    <content type="text"><![CDATA[链接:lgP2746[USACO5.3]校园网 题解 显然分发学校向接受学校连一条边，然后缩点。 子任务A显然就是入度为零的缩点个数 子任务B则是入度为零和出度为零的缩点个数的最大值 有一个坑点，只有一个强连通分量的情况12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define rep(i,x,y) for(register int i=x;i&lt;=y;++i) #define repd(i,x,y) for(register int i=x;i&gt;=y;--i) #define ll long long using namespace std; const int N=1e5; struct node&#123; int v,nxt; inline void init(int x,int y)&#123;v=x; nxt=y;&#125; &#125;e[N]; int head[N],dfn[N],low[N],cnt,bl[N],du[N][2],n,m,in[N],stck[N],idx,tot,x,ans,res[2]; inline void adde(int x,int y)&#123;e[cnt].init(y,head[x]);head[x]=cnt++;&#125; void tarjan(int u)&#123; in[u]=1; stck[++idx]=u; dfn[u]=low[u]=++tot; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123;tarjan(v); low[u]=min(low[u],low[v]);&#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; cnt++; do&#123;in[stck[idx]]=0; bl[stck[idx--]]=cnt;&#125;while(u!=stck[idx+1]); &#125; &#125; int main()&#123; memset(head,-1,sizeof(head)); scanf("%d",&amp;n); rep(i,1,n)while(~scanf("%d",&amp;x)&amp;&amp;x)&#123; adde(i,x); &#125;cnt=0; rep(i,1,n)if(!dfn[i])tarjan(i); rep(u,1,n)for(int i=head[u],v;i!=-1;i=e[i].nxt)if(bl[v=e[i].v]!=bl[u])&#123; du[bl[u]][0]++; du[bl[v]][1]++; &#125; rep(i,1,cnt)&#123;ans+=(du[i][1]==0); res[0]+=(du[i][0]==0);res[1]+=(du[i][1]==0);&#125; printf("%d\n%d",ans,cnt!=1?max(res[0],res[1]):0); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>trajan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgP2341[HAOI2006]受欢迎的牛]]></title>
    <url>%2FlgP2341-HAOI2006-%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[链接:lgP2341[HAOI2006]受欢迎的牛 题解 爱慕可以传递，很自然想到缩点，所以只需要找到可以被所有缩点遍历到的那个缩点，自然想到出度为零的缩点就是我们要求的 但是如果有两个这样的缩点，自然无解，然后很迷人的操作WA 3发123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];int head[N],cnt,n,m,dfn[N],low[N],tot,ans[N],idx,stck[N],in[N],lg[N],du[N],tp;inline void adde(int x,int y)&#123;e[cnt].init(y,head[x]);head[x]=cnt++;&#125;void tarjan(int u)&#123; in[u]=1; stck[++idx]=u; dfn[u]=low[u]=++tot; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; int x; cnt++; do&#123;in[idx]=0;lg[stck[idx--]]=cnt;ans[cnt]++;&#125;while(stck[idx+1]!=u); &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)&#123;int x,y;scanf("%d%d",&amp;x,&amp;y);adde(x,y);&#125;cnt=0; rep(i,1,n)if(!dfn[i])tarjan(i); rep(i,1,n)for(int j=head[i];j!=-1;j=e[j].nxt)if(lg[e[j].v]!=lg[i])du[lg[i]]++; rep(i,1,cnt)if(!du[i])&#123;if(tp)&#123;puts("0");return 0;&#125; tp=i;&#125; printf("%d",ans[tp]); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgP1407[国家集训队]稳定婚姻]]></title>
    <url>%2FlgP1407-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E7%A8%B3%E5%AE%9A%E5%A9%9A%E5%A7%BB%2F</url>
    <content type="text"><![CDATA[链接:lgP1407[国家集训队]稳定婚姻 题解 尝试将所有丈夫和夫妻连起来，表示他们之间存在过关系，那么显然无论是之前还是现在，他们总有关系，所以这两种情况是一样的 那么怎么判断是否安全呢。 由于已经将所有存在过关系的丈夫和夫妻连起来了，那么显然如果如果丈夫和夫妻在一个环里，那么不安全 注意连接的时候一定要是男-&gt;女-&gt;男-&gt;女这样链接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];string a,b;map&lt;string,int&gt; id;int n,m,bl[N],head[N],cnt,in[N],dfn[N],low[N],tot,stck[N],idx;inline void adde(int x,int y)&#123;e[cnt].init(y,head[x]);head[x]=cnt++;&#125;void tarjan(int u)&#123; in[u]=1; low[u]=dfn[u]=++tot; stck[++idx]=u; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; cnt++; do&#123; bl[stck[idx--]]=cnt; in[stck[idx+1]]=0; &#125;while(stck[idx+1]!=u); &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf("%d",&amp;n); rep(i,1,n)&#123;cin&gt;&gt;a&gt;&gt;b;id[a]=i;id[b]=i+n;adde(i,i+n);&#125; scanf("%d",&amp;m); rep(i,1,m)&#123;cin&gt;&gt;a&gt;&gt;b;adde(id[b],id[a]);&#125; cnt=0; rep(i,1,2*n)if(!dfn[i])tarjan(i); rep(i,1,n)if(bl[i]==bl[i+n])puts("Unsafe");else puts("Safe"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2863[USACO06JAN]牛的舞会]]></title>
    <url>%2Flg2863-USACO06JAN-%E7%89%9B%E7%9A%84%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[链接:lg2863[USACO06JAN]牛的舞会 题解tarjan模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];int dfn[N],low[N],in[N],ans,cnt,head[N],n,m,stck[N],indx;inline void adde(int a,int b)&#123; e[cnt].init(b,head[a]); head[a]=cnt++;&#125;void tarjan(int u)&#123; in[u]=1; low[u]=dfn[u]=++cnt; stck[++indx]=u; for(int i=head[u],v;i!=-1;i=e[i].nxt)&#123; if(!dfn[v=e[i].v])&#123;tarjan(v); low[u]=min(low[u],low[v]);&#125; else if(in[v])low[u]=min(low[u],dfn[v]); &#125; if(low[u]==dfn[u])&#123; int k=0; do&#123; in[indx]=0; --indx; k++; &#125;while(stck[indx+1]!=u); if(k&gt;1)ans++; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(head,-1,sizeof(head)); rep(i,1,m)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); adde(x,y); //adde(y,x); &#125; cnt=0; rep(i,1,n)&#123; if(!dfn[i])tarjan(i); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1963[NOI2009]变换序列]]></title>
    <url>%2Flg1963-NOI2009-%E5%8F%98%E6%8D%A2%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[链接:lg1963[NOI2009]变换序列 题解这题难点在于要求字典序最小的匹配 首先建图的时候要先连大的点,因为处理的时候,是倒序 匈牙利算法是当前点无法匹配的时候尝试更改之前匹配的点,所以倒着匈牙利就可以保证小的点优先匹配小的点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a;nxt=b;&#125;&#125;e[N];int mark[N],n,vis[N],head[N],cnt,ans;inline int solve(int x)&#123;if(x&lt;0)x+=n; if(x&gt;n-1)x-=n; return x+n;&#125;void add(int u,int x)&#123; int v1=solve(u+x),v2=solve(u-x); if(v1&lt;v2)swap(v1,v2); e[++cnt].init(v1,head[u]);head[u]=cnt; e[++cnt].init(v2,head[u]);head[u]=cnt;&#125;int find(int x)&#123; vis[x]=1; for(int i=head[x],v;i;i=e[i].nxt)if(!vis[v=e[i].v])&#123; vis[v]=1; if(!mark[v]||find(mark[v]))&#123; mark[v]=x;mark[x]=v; return 1; &#125; &#125; return 0;&#125;int r()&#123; repd(i,n-1,0)if(!mark[i])&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; return ans==n;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,0,n-1)&#123;int x;scanf("%d",&amp;x); add(i,x);&#125; if(r())rep(i,0,n-1)printf("%d ",mark[i]-n); else puts("No Answer"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛13]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B13%2F</url>
    <content type="text"><![CDATA[链接:牛客练习赛13 A幸运数字1 幸运数字是只含4,7的数字,给一个字符串,求出现次数最多的且是幸运数字的子串 题解 没啥说的,答案只有4,7,-1三种可能B幸运数字2 next(x)表示比x大的第一个幸运数字,给定l,r,求出next(l)+…+next(r)题解 我的做法是跑出所有幸运数字，1-1e10中最多2^9个，然后二分l和r在数组中的位置，累加答案 实际上不需要二分,对于幸运数字i来说,满足next(x)==i的只有上一个幸运数字y的后一个数y+1到i的那些 不多说,上代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll c[N],len,ans,l,r;int main()&#123; rep(i,1,10)rep(j,0,(1&lt;&lt;i)-1)&#123; ll num=0; rep(k,0,i-1)if(j&gt;&gt;k&amp;1)num=num*10+4;else num=num*10+7; c[++len]=num; &#125; sort(c+1,c+len+1); scanf("%d%d",&amp;l,&amp;r); for(int i=1;l&lt;=r;++i)if(c[i]&gt;=l)ans+=(ll)(min(r,c[i])-l+1)*c[i],l=c[i]+1; printf("%lld",ans); return 0;&#125; C幸运数字3]]></content>
      <categories>
        <category>比赛</category>
        <category>牛客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[poj1988]]></title>
    <url>%2Fpoj1988%2F</url>
    <content type="text"><![CDATA[链接:poj1988 Description Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations: moves and counts. In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. Write a program that can verify the results of the game. Input Line 1: A single integer, P Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X. Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. Output Print the output from each of the count operations in the same order as the input file. Sample Input 6 M 1 6 C 1 M 2 4 M 2 6 C 3 C 4Sample Output 1 0 2题解 带权并查集，和lg1196差不多1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regiser int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e5+7;int f[N],rl[N],n,a,b,nm[N];char c;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]+=rl[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); f[b]=a; rl[b]=nm[a]; //更新x所在列头 nm[a]+=nm[b]; //更新b的长度 //nm[a]=0; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,1,30000)f[i]=i,nm[i]=1; rep(i,1,n)&#123; cin&gt;&gt;c&gt;&gt;a; if(c=='M')&#123;cin&gt;&gt;b;un(a,b);&#125; else cout&lt;&lt;nm[find(a)]-rl[a]-1&lt;&lt;endl; &#125; return 0;&#125; 更厉害的 看了大神的博客，发现，根本不需要多开一个rl数组保存列长度 果然是太弱了1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;int f[N],dis[N],n,a,b;char c;int find(int x)&#123; if(f[x]&lt;0)return x; int t=find(f[x]); dis[x]+=dis[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; dis[y]=(-f[x]); f[x]+=f[y]; f[y]=x; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; memset(f,-1,sizeof(f)); rep(i,1,n)&#123; cin&gt;&gt;c&gt;&gt;a; if(c=='M')&#123;cin&gt;&gt;b; un(a,b);&#125; else cout&lt;&lt;f[find(a)]*(-1)-dis[a]-1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1811]]></title>
    <url>%2Fhdu1811%2F</url>
    <content type="text"><![CDATA[链接:hdu1811 Description 自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。 为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还 响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。 终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。 同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是”A &gt; B”,”A = B”,”A &lt; B”，分别表示A的 Rating高于B,等于B,小于B。 现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出”OK”。否则就请你 判断出错的原因，到底是因为信息不完全（输出”UNCERTAIN”），还是因为这些信息中包含冲突（输出”CONFLICT”）。 注意，如果信息中同时包含冲突且信息不完全，就输出”CONFLICT”。 Input 本题目包含多组测试，请处理到文件结束。 每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),分别表示要排名的人数以及得到的关系数。 接下来有M行，分别表示这些关系Output 对于每组测试，在一行里按题目要求输出Sample Input 3 3 0 &gt; 1 1 &lt; 2 0 &gt; 2 4 4 1 = 2 1 &gt; 3 2 &gt; 0 0 &gt; 1 3 3 1 &gt; 0 1 &gt; 2 2 &lt; 1Sample Output OK CONFLICT UNCERTAIN题解 等于的话放在同一个集合，然后对集合建图。 入度等于0的点多于1个说明信息不完整 有环说明冲突1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];struct nd&#123; int a,b; char c;&#125;mes[N];int head[N],n,m,f[N],cnt,in[N],flag,sum;queue&lt;int&gt; q;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;inline int un(int x,int y)&#123;x=find(x); y=find(y); f[x]=y; return x!=y;&#125;inline void add(int a,int b)&#123; e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int top()&#123; rep(i,0,n-1)if(!in[i]&amp;&amp;find(i)==i)q.push(i); while(!q.empty())&#123; if(q.size()&gt;1)flag=1; int u=q.front(); q.pop();sum--; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int t=e[i].v; in[t]--; if(in[t]==0)q.push(t); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; flag=0;sum=n; cnt=0; rep(i,0,n)f[i]=i; memset(in,0,sizeof(in)); memset(head,-1,sizeof(head)); rep(i,1,m)&#123; cin&gt;&gt;mes[i].a&gt;&gt;mes[i].c&gt;&gt;mes[i].b; if(mes[i].c=='=')&#123;if(un(mes[i].a,mes[i].b))sum--;&#125; &#125; rep(i,1,m)if(mes[i].c!='=')&#123; int a=find(mes[i].a); int b=find(mes[i].b); if(mes[i].c=='&gt;')&#123;add(a,b);in[b]++;&#125; else &#123;add(b,a); in[a]++;&#125; &#125; top(); if(sum&gt;0)cout&lt;&lt;"CONFLICT"&lt;&lt;endl; else if(flag)cout&lt;&lt;"UNCERTAIN"&lt;&lt;endl; else cout&lt;&lt;"OK"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1196]]></title>
    <url>%2Flg1196%2F</url>
    <content type="text"><![CDATA[链接:lg1196 Description 公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。 宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山 河集团点名将杨威利组织麾下三万艘战舰迎敌。 杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成30000列，每列依次 编号为1, 2, …,30000。之后，他把自己的战舰也依次编号为1, 2, …, 30000，让第i号战舰处于第i列(i = 1, 2, …, 30000)，形成 “一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻 击。合并指令为M i j，含义为第i号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显 然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增 大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。 在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：C i j。该指令意思是， 询问电脑，杨威利的第i号战舰与第j号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。 作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。 最终的决战已经展开，银河的历史又翻过了一页…… Input 以下有T行，每行有一条指令。指令有两种格式： M i j ：i和j是两个整数（1&lt;=i , j&lt;=30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指 令，并且保证第i号战舰与第j号战舰不在同一列。 C i j ：i和j是两个整数（1&lt;=i , j&lt;=30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。Output 输出文件为galaxy.out。你的程序应当依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息； 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i 号战舰与第j 号战舰之间布置的战舰数 目。如果第i 号战舰与第j号战舰当前不在同一列上，则输出-1。Sample Input 4 M 2 3 C 1 2 M 2 4 C 4 2Sample Output -1 1题解 简单的并查集，维护一个队列长度，x所在列头1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regiser int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e5+7;int f[N],rl[N],n,a,b,nm[N];char c;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]+=rl[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); f[a]=b; rl[a]+=nm[b]; //更新x所在列头 nm[b]+=nm[a]; //更新b的长度 nm[a]=0; &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; rep(i,1,30000)f[i]=i,nm[i]=1; rep(i,1,n)&#123; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; if(c=='M')un(a,b); else &#123;if(find(a)!=find(b))cout&lt;&lt;-1&lt;&lt;endl;else cout&lt;&lt;abs(rl[a]-rl[b])-1&lt;&lt;endl;&#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3038]]></title>
    <url>%2Fhdu3038%2F</url>
    <content type="text"><![CDATA[链接:hdu3038 Description TT and FF are … friends. Uh… very very good friends -____-b FF is a bad boy, he is always wooing TT to play the following game with him. This is a very humdrum game. To begin with, TT should write down a sequence of integers-_-!!(bored). Then, FF can choose a continuous subsequence from it(for example the subsequence from the third to the fifth integer inclusively). After that, FF will ask TT what the sum of the subsequence he chose is. The next, TT will answer FF’s question. Then, FF can redo this process. In the end, FF must work out the entire sequence of integers. BoringBoringa very very boring game!!! TT doesn’t want to play with FF at all. To punish FF, she often tells FF the wrong answers on purpose. The bad boy is not a fool man. FF detects some answers are incompatible. Of course, these contradictions make it difficult to calculate the sequence. However, TT is a nice and lovely girl. She doesn’t have the heart to be hard on FF. To save time, she guarantees that the answers are all right if there is no logical mistakes indeed. What’s more, if FF finds an answer to be wrong, he will ignore it when judging next answers. But there will be so many questions that poor FF can’t make sure whether the current answer is right or wrong in a moment. So he decides to write a program to help him with this matter. The program will receive a series of questions from FF together with the answers FF has received from TT. The aim of this program is to find how many answers are wrong. Only by ignoring the wrong answers can FF work out the entire sequence of integers. Poor FF has no time to do this job. And now he is asking for your help~(Why asking trouble for himself~~Bad boy) Input Line 1: Two integers, N and M (1 &lt;= N &lt;= 200000, 1 &lt;= M &lt;= 40000). Means TT wrote N integers and FF asked her M questions. Line 2..M+1: Line i+1 contains three integer: Ai, Bi and Si. Means TT answered FF that the sum from Ai to Bi is Si. It’s guaranteed that 0 &lt; Ai &lt;= Bi &lt;= N. You can assume that any sum of subsequence is fit in 32-bit integer.Output A single line with a integer denotes how many answers are wrong.Sample Input 10 5 1 10 100 7 10 28 1 3 32 4 6 41 6 6 1Sample Output 1题解 带权并查集问题，一样的找向量偏移量 然后这题卡多组。。。123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;int f[N],rl[N],n,m,t,a,b,ans;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]+=rl[f[x]]; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b&amp;&amp;rl[y]-rl[x]!=t)&#123;ans++; return ;&#125; f[b]=a; rl[b]=rl[x]-rl[y]+t;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; rep(i,1,n)f[i]=i; rep(i,1,m)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;t); un(--a,b); &#125; printf("%d",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1829]]></title>
    <url>%2Fhdu1829%2F</url>
    <content type="text"><![CDATA[链接:hdu1829 Description Background Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs. Problem Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it. Input The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one.Output The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong.Sample Input 2 3 3 1 2 2 3 1 3 4 2 1 2 3 4Sample Output Scenario #1: Suspicious bugs found! Scenario #2: No suspicious bugs found! 题解 这题很好玩，找gay 也是带权并查集 算一下向量偏移量就好了 压缩路径的偏移量算错了wa了一发，输出标记错了又wa一发。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e4+7;int f[N],rl[N],T,a,b,cnt,ans,n,m;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]=(rl[x]+rl[f[x]])&amp;1; //rl[x] 表示x与f[x]的关系 return f[x]=t;&#125;inline int un(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b)if(rl[x]==rl[y])return ans=1; f[b]=a; rl[b]=(rl[x]-rl[y]+1)&amp;1; return 0;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; ans=0; scanf("%d%d",&amp;n,&amp;m); memset(rl,0,sizeof(rl)); rep(i,1,n)f[i]=i; printf("Scenario #%d:\n",++cnt); rep(i,1,m)&#123; scanf("%d%d",&amp;a,&amp;b); if(ans)continue; if(un(a,b))puts("Suspicious bugs found!\n"); &#125; if(!ans)puts("No suspicious bugs found!\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1182]]></title>
    <url>%2Fpoj1182%2F</url>
    <content type="text"><![CDATA[链接:poj1182 Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是”1 X Y”，表示X和Y是同类。 第二种说法是”2 X Y”，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就 是假话，否则就是真话。 1）当前的话与前面的某些真的话冲突，就是假话； 2）当前的话中X或Y比N大，就是假话； 3）当前的话表示X吃X，就是假话。 你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。Output 只有一个整数，表示假话的数目。Sample Input 100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5Sample Output 3题解 并查集高级操作，带权并查集 用向量的方式算一下偏移量就好12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+10;int f[N],rl[N],n,m,op,x,y,ans;int find(int x)&#123; if(f[x]==x)return x; int t=find(f[x]); rl[x]=(rl[x]+rl[f[x]])%3; return f[x]=t;&#125;inline void un(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b)&#123; if((3+rl[y]-rl[x])%3!=op)ans++; return ; &#125; f[b]=a; rl[b]=(3+op+rl[x]-rl[y])%3;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)f[i]=i; rep(i,1,m)&#123; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); op--; if(x&gt;n||y&gt;n||(op&amp;&amp;x==y))&#123;ans++; continue;&#125; un(x,y); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论小结]]></title>
    <url>%2F%E6%95%B0%E8%AE%BA%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[欧几里德算法(gcd) 辗转相除,求最小公因数 定理 gcd(a,b)=gcd(b,a%b); gcd(a,0)=0;证明(假设a&gt;b)充分性 将a写成 a=k*b+r; 设d为a,b的一个公因数,则d|a,d|b 而r=a-k*b r/d=a/d-k*b/d 由假设可知右侧为正整数 显然d|r 得证必要性 设d|a,d|(a%b) 显然d|(a-k*b) (k为整数) 显然d|a 得证拓展欧几里德算法 在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a,b) = d（解一定存在，根据数论中的相关定理）。扩展欧几里德常 用在求解模线性方程及方程组中。(依赖于欧几里德算法)贝祖等式 在数论中，裴蜀等式（英语：Bézout’s identity）或贝祖定理（Bézout’s lemma）是一个关于最大公约数（或最大公约式）的定理。 裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程（称为裴蜀等 式）： ax + by = gcd(a,b) = d 有整数解时当且仅当m是d的倍数。 裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数，可用扩展欧几里得算法(Extended Euclidean algorithm)求得。 特别来说，方程 ax+by=1 有整数解当且仅当整数a和b互素。 裴蜀等式也可以用来给最大公约数定义： d其实就是最小的可以写成ax+by形式的正整数。(这个定义的本质是整环中“理想”的概念。因 此对于多项式整环也有相应的裴蜀定理。)证明: 如果 a 和 b 中有一个是 0，比如 a=0，那么它们两个的最大公约数是 b。这时裴蜀等式变成 by=d，它有整数解 (x,y) 当且仅当 d 是 b 的倍数，而且有解时必然有无穷多个解，因为 x 可以是任何整数。定理成立。 以下设 a和 b 都不为0。 设 A={xa+yb;(x,y)∈Z2} ，下面证明A中的最小正元素是 a 与 b 的最大公约数。 首先，A∩N∗ 不是空集（至少包含|a| 和|b|），因此由于自然数集合是良序的， A 中存在最小正元素d0=x0a+y0b。考虑A中任意一个正 元素p（=x1a+y1b）对 d0 的带余除法：设p=qd0+r，其中 q 为正整数，0≤r&lt;d0。但是 r=p−qd0=x1a+y1b−q(x0a+y0b)∈A 而d0 已经是集合 A 中最小的正元素了，又 0≤r&lt;d0,所以 r=0。 因此 d0 | p。也就是说，A中任意一个正元素p都是 d0 的倍数，特别地：d0 | a、d0 | b。因此 d0 是 a 和 b 的公约数。 另一方面，对 a 和 b 的任意正公约数d，设 a=kd、b=ld，那么 d0=x0a+y0b=(x0k+y0l)d x0k+y0l≥1 ,因此 d | d0。所以 d0 是 a 和 b 的最大公约数。 在方程ax+by=m中，如果 m=m0d0，那么方程显然有无穷多个解 相反的，如果ax+by=m有整数解，那么 |m|∈A，于是由前可知 d0 | |m|（即 d0 | m）。 m=1时，方程有解当且仅当a、b互质。拓展欧几里德算法 扩展欧几里德算法就是在求 a,b 的最大公约数 m=gcd(a,b) 的同时，求出贝祖等式ax + by = m的一个解 (x,y)。 有两个数 a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以 得到 ax+by=gcd(a,b)的整数解。 先来看下这个几乎所有总结扩展欧几里德算法的帖子中都会用到的例子 123456789101112131415161718192021用类似辗转相除法，求二元一次不定方程47x+30y=1的整数解。47=30*1+1730=17*1+1317=13*1+413=4*3+1然后把它们改写成“余数等于”的形式17=47*1+30*(-1) //式113=30*1+17*(-1) //式24=17*1+13*(-1) //式31=13*1+4*(-3)然后把它们“倒回去”1=13*1+4*(-3) //应用式31=13*1+[17*1+13*(-1)]*(-3)1=13*4+17*(-3) //应用式21=[30*1+17*(-1)]*4+17*(-3)1=30*4+17*(-7) //应用式11=30*4+[47*1+30*(-1)]*(-7)1=30*11+47*(-7)得解x=-7, y=11。 现在的问题就是找到这个倒推回去的递推式 12345678910111213 设：a&gt;b。 推理1，显然当 b=0，gcd（a，b）=a。 此时 x=1，y=0;//推理1 推理2，ab!=0 时 设 ax1+by1=gcd(a,b); bx2+(a mod b)y2=gcd(b,a mod b); 根据朴素的欧几里德原理有 gcd(a,b)=gcd(b,a mod b); 则:ax1+by1=bx2+(a mod b)y2; 即:ax1+by1=bx2+(a-(a/b)*b)y2=ay2+bx2-(a/b)*by2; 根据恒等定理得：x1=y2 ,y1=x2-(a/b)*y2;//推理2 这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.上面的思想是以递归定义的因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。 然后我们就找到了递推式 x1=y2; y1=x2−(a/b)∗y2; 当b=0，gcd（a，b）=a。此时x=1，y=0;(终止条件) 于是我们得到了拓展欧几里德算法的代码 1234567inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0;&#125; else &#123; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*x; &#125;&#125; 乘法逆元 若ax≡1 mod m, 则称a关于1模m的乘法逆元为x。也可表示为ax≡1(mod m)。 如果a,m不互质，则无解。如果m为质数，则从1到m−1的任意数都与m互质，即在1到m−1之间都恰好有一个关于模m的乘法逆元。求法 欧拉定理 欧拉定理：aφ(m)≡1(mod m) (φ(m)是小于m且与m互质的数的个数。) 变形得: a⋅aφ(m)−1≡1(mod m) 故aφ(m)−1为a在模m下的逆元。(aφ(m)−1用快速幂求解即可)费马小定理 假如p是质数，且gcd(a,p)=1，那么 a(p-1)≡1（mod p），例如：假如a是整数，p是质数，则a,p显然互质(即两者只有一个公约数1)， 那么我们可以得到费马小定理的一个特例，即当p为质数时候， a^(p-1)≡1(mod p)。 则a*a^(p-2)≡1(mod p) 显然a^(p-2)就是a关于%p的逆元 费马小定理实质上是欧拉定理的一个特殊情况拓展欧几里德 详情看上面，但是注意求出来的逆元可能为负数，只需要加上p再%p就好斯特林公式 斯特林公式是一条用来取n的阶乘的近似值的数学公式。一般来说，当n很大的时候，n阶乘的计算量十分大，所以斯特林公式十分好用， 而且，即使在n很小的时候，斯特林公式的取值已经十分准确。n!\approx\sqrt{2\pi n}(\frac{n}{e})^n lucas定理 Lucas定理是用来求 C(n,m)mod p，p为素数的值。 适用领域范围：大组合数求模,n,m&gt;pC(n,m)%p=lucas(n,m)=lucas(n/p,m/p)*C(n%p,n%m)%p 线性求逆元 有时我们需要1~p所有元素的逆元，当p很大的时候常规的求逆元方式的时间复杂度都比较高最快也是O(p*log(p)) 只需要一点简单的推倒，我们就可以O(p)地求解 先给出递推式inv[i]=(p-p/i)*inv[p%i]%p 推导 设 t=p/i,k=p%i,那么 t*i+k≡0(mod p) -ti≡k(mod p) 两边同除ik 得到 -t*inv[k]≡invi 替换回去可以得到 inv[i]=(p-p/i)*inv[p%i]%p 初始化inv[1]=1 就可以递推地求解了]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1999高维正方体]]></title>
    <url>%2Flg1999%E9%AB%98%E7%BB%B4%E6%AD%A3%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[链接:lg1999高维正方体 Description 0维空间的元素是点，这个毋庸置疑。 2个0维空间的元素可以围成一个1维空间的元素，线段。 4个1维空间的元素可以围成一个2维空间的元素，正方形。 6个2维空间的元素可以围成一个3维空间的元素，正方体。 8个3维空间的元素可以围成一个4维空间的元素，超正方体。 …… 一个正方形中，有4个（顶）点，4条线段（边），1个正方形。 一个正方体中，有8个（顶）点，12条线段（棱），6个正方形（面），1个正方体。 …… 我们的问题是：给出a与b，请求出：在a维空间的元素中，包含着多少个b维空间的元素。答案可能很大，只需要输出它除以1000000007 的余数。 Input 两个整数a,b，以空格隔开。Output 一个整数，即答案。Sample Input 3 1Sample Output 12题解 找规律,答案等于C(a,b)*pow(2,(a-b)) a,b很大，组合数直接做肯定爆ll 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const ll mod=1000000007;const int N=1e6+7;ll n,m,inv[N];inline void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0;&#125; else &#123; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*x; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=(ans*a)%mod; a=(a*a)%mod;b&gt;&gt;=1; &#125; return ans;&#125;ll cal()&#123; ll t,ans=1; rep(i,1,m)&#123;exgcd(i,mod,inv[i],t); inv[i]=inv[i]&lt;=0?(inv[i]+mod)%mod:inv[i];&#125; rep(i,1,m)ans=(ans%mod*inv[i]%mod*(n-m+i))%mod; return ans;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); if(n&lt;m)printf("0\n"); else printf("%lld\n",cal()*qpow(2,n-m)%mod); //cout&lt;&lt;cal()&lt;&lt;' '&lt;&lt;qpow(2,n-m)%mod; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里德</category>
      </categories>
      <tags>
        <tag>拓展欧几里德</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1433:[ZJOI2009]假期的宿舍]]></title>
    <url>%2Fbzoj1433-ZJOI2009-%E5%81%87%E6%9C%9F%E7%9A%84%E5%AE%BF%E8%88%8D%2F</url>
    <content type="text"><![CDATA[链接:bzoj1433:[ZJOI2009]假期的宿舍 Description 学校放假了······有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。比如A 和B都是学校的学生，A要回家，而C来看B，C与A不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一 个解决方案就是B睡A的床而C睡B的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也 不一定都互相认识。我们已知一共有n个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家 。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。 Input 第一行一个数T表示数据组数。接下来T组数据， 每组数据第一行一个数n表示涉及到的总人数。 接下来一行n个数，第i个数表示第i个人是否是在校学生(0表示不是，1表示是)。 再接下来一行n个数，第i个数表示第i个人是否回家 (0表示不回家，1表示回家，注意如果第i个人不是在校学生，那么这个位置上的数是一个随机的数， 你应该在读入以后忽略它)。 接下来n行每行n个数， 第i行第j个数表示i和j是否认识 (1表示认识，0表示不认识，第i行i个的值为0，但是显然自己还是可以睡自己的床)， 认识的关系是相互的。 1 ≤ n ≤ 50,1 ≤ T ≤ 20Output 对于每组数据，如果存在一个方案则输出“^_^”(不含引号)否则输出“T_T”(不含引号)。 (注意输出的都是半角字符，即三个符号的ASCII码分别为94,84,95)Sample Input 1 3 1 1 0 0 1 0 0 1 1 1 0 0 1 0 0Sample Output ˆ ˆ题解 人和床匹配，没什么多说的。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=55;int sc[N],bed[N],mark[N],l[N][N],vis[N],people[N],cnt2,cnt1,n,ans;int find(int x)&#123; rep(i,1,cnt1)if(!vis[bed[i]]&amp;&amp;l[x][bed[i]])&#123; vis[bed[i]]=1; if(!mark[bed[i]]||find(mark[bed[i]]))&#123; mark[bed[i]]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;n); while(~scanf("%d",&amp;n))&#123; cnt1=ans=cnt2=0; memset(mark,0,sizeof(mark)); rep(i,1,n)scanf("%d",&amp;sc[i]); rep(i,1,n)&#123; int x;scanf("%d",&amp;x); if(sc[i])if(x)bed[++cnt1]=i;else bed[++cnt1]=people[++cnt2]=i; else people[++cnt2]=i; &#125; rep(i,1,n)rep(j,1,n)scanf("%d",&amp;l[i][j]); rep(i,1,n)if(sc[i])l[i][i]=1; rep(i,1,cnt2)&#123;memset(vis,0,sizeof(vis)); ans+=find(people[i]);&#125; if(cnt1&lt;cnt2||ans!=cnt2)puts("T_T"); else if(ans==cnt2)puts("^_^"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lightoj1042]]></title>
    <url>%2Flightoj1042%2F</url>
    <content type="text"><![CDATA[链接:lightoj1042 Description This is the tale of Zephyr, the greatest time traveler the world will never know. Even those who are aware of Zephyr’s existence know very little about her. For example, no one has any clue as to which time period she is originally from. But we do know the story of the first time she set out to chart her own path in the time stream. Zephyr had just finished building her time machine which she named - “Dokhina Batash”. She was making the final adjustments for her first trip when she noticed that a vital program was not working correctly. The program was supposed to take a number N, and find what Zephyr called its Onoroy value. The Onoroy value of an integer N is the number of ones in its binary representation. For example, the number 13 (11012) has an Onoroy value of 3. Needless to say, this was an easy problem for the great mind of Zephyr. She solved it quickly, and was on her way. You are now given a similar task. Find the first number after N which has the same Onoroy value as N. Input Input starts with an integer T (≤ 65), denoting the number of test cases. Each case begins with an integer N (1 ≤ N ≤ 109).Output For each case of input you have to print the case number and the desired result.Sample Input 5 23 14232 391 7 8Sample Output Case 1: 27 Case 2: 14241 Case 3: 395 Case 4: 11 Case 5: 16题解 思路还行，代码实现有点困难，太弱了 把n最右边的连续的1向右移动直到个数-1，把n最左边连续的1的末尾的相邻0改为1就是答案了 以下是我的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;int pre,T,n,ct,now,bit[40],id;int get(int x)&#123; int cnt=0; while(x)&#123; if(x&amp;1)cnt++; x&gt;&gt;=1; &#125; return cnt;&#125;int getbit(int x)&#123; rep(i,0,30)&#123; if(x&amp;1)bit[i]=1; else bit[i]=0; x&gt;&gt;=1; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); ct=get(n); n+=lowbit(n);getbit(n);now=get(n); while(ct!=now)&#123; rep(i,0,30)if(!bit[i])&#123; now++;bit[i]=1; n|=(1&lt;&lt;i);break; &#125; &#125; printf("Case %d: %d\n",++id,n); &#125; return 0;&#125; 以下是大佬的代码，我只想说。。差距好大12345678910111213141516171819#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; int main() &#123; ll t; scanf("%lld",&amp;t); for(ll k=1;k&lt;=t;++k) &#123; ll n; scanf("%lld",&amp;n); ll x=n&amp;-n,y=n+x; n=((n&amp;~y)/x&gt;&gt;1)|y; printf("Case %lld: %lld\n",k,n); &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2825[HEOI2016/TJOI2016]]]></title>
    <url>%2FP2825-HEOI2016-TJOI2016%2F</url>
    <content type="text"><![CDATA[链接:P2825[HEOI2016/TJOI2016] Description 在2016年，佳缘姐姐喜欢上了一款游戏，叫做泡泡堂。简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者 躲开对手的炸弹。在玩游戏的过程中，小H想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个 炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。给定一张 nm的网格地图:其中代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。x代表软石头，炸弹的威力可以穿透，不能在此放置 炸弹。#代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出14的网格地图xx*，这个地图上最多只能放置一个炸 弹。给出另一个14的网格地图x#，这个地图最多能放置两个炸弹。现在小H任意给出一张nm的网格地图，问你最多能放置多少炸弹。 Input 第一行输入两个正整数n,m,n表示地图的行数，m表示地图的列数。1≤n,m≤50。接下来输入n行m列个字符，代表网格地图。*的个数不超过 n*m个。Output 输出一个整数a，表示最多能放置炸弹的个数Sample Input 4 4* # # xxx#Sample Output 5题解 提取出每一行和每一列的极长连续不含#的非空字串 显然，炸弹只能放在*上，而放一个就会把它周围清空，这样显然就是二分图最大匹配了 以他们为节点，每一行和每一列连边。跑一个匈牙利就出来了。 zz地弄了个骚操作加边，然后WA一万次。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=55;const int M=3e3;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[M];int head[M],cnt,tol,col[N][N],row[N][N],n,m,vis[M],mark[M],ans;char str[N][N];inline void add(int a,int b)&#123; e[++cnt].init(b,head[a]); head[a]=cnt;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,1,m)cin&gt;&gt;str[i][j]; rep(i,1,n)rep(j,1,m)if(str[i][j]!='#')&#123; if(j==1||str[i][j-1]=='#')tol++; row[i][j]=tol; &#125; rep(j,1,m)rep(i,1,n)if(str[i][j]!='#')&#123; if(i==1||str[i-1][j]=='#')tol++; col[i][j]=tol; &#125; rep(i,1,n)rep(j,1,m)if(str[i][j]=='*')add(row[i][j],col[i][j]); rep(i,1,tol)&#123;memset(vis,0,sizeof(vis));ans+=find(i);&#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1640]]></title>
    <url>%2Flg1640%2F</url>
    <content type="text"><![CDATA[链接:lg1640 Description lxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使 用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。游戏进行到最后，lxhgww遇到了终极boss，这个终 极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能 使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此 类推。现在lxhgww想知道他最多能连续攻击boss多少次？ Input 输入的第一行是一个整数N，表示lxhgww拥有N种装备接下来N行，是对这N种装备的描述，每行2个数字，表示第i种装备的2个属性值Output 输出一行，包括1个数字，表示lxhgww最多能连续攻击的次数。Sample Input 3 1 2 3 2 4 5Sample Output 2题解 mdzz 因为标记方式不同，各种RE TLE 思路很简单，但是不好想，用伤害匹配装备123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1000070;const int M=10070;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N&lt;&lt;1];int head[M],mark[N],cnt,n,vis[M],ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void add(int a,int b)&#123; e[++cnt].init(b,head[a]); head[a]=cnt;&#125;int find(int u)&#123; if(vis[u])return 0; vis[u]=1; for(int i=head[u];i;i=e[i].nxt)if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; return 0;&#125;int main()&#123; read(n); rep(i,1,n)&#123;int x; read(x); add(x,i); read(x); add(x,i);&#125; rep(i,1,10000)&#123;memset(vis,0,sizeof(vis)); if(find(i))ans++;else break;&#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1402]]></title>
    <url>%2Flg1402%2F</url>
    <content type="text"><![CDATA[链接:lg1402 Description XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也 有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。 有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜 欢的房间，吃到喜欢的菜）。 这里要怎么分配，能使最多顾客满意呢？ Input 第一行给出三个正整数表示n,p,q(&lt;=100)。 之后n行，每行p个数包含0或1，第i个数表示喜不喜欢第i个房间（1表示喜欢，0表示不喜欢）。 之后n行，每行q个数，表示喜不喜欢第i道菜。Output 顾客最大满意数Sample Input 2 2 2 1 0 1 0 1 1 1 1Sample Output 1题解 做两个最大匹配，如果都匹配上了，答案+1，否则返回上次状态123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define abs(x) x=x&gt;0?x:(-x)using namespace std;const int N=300;int l[N][N][2],m[N][2],vis[N][2],n,p,q,tp[N][2];template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x,int op)&#123; rep(i,1,n)if(l[x][i][op]&amp;&amp;!vis[i][op])&#123; vis[i][op]=1; if(!m[i][op]||find(m[i][op],op))&#123; m[i][op]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; int ans=0; read(n);read(p);read(q); rep(i,1,n)rep(j,1,p)read(l[i][j][0]); rep(i,1,n)rep(j,1,q)read(l[i][j][1]); rep(i,1,n)&#123; rep(j,0,1)rep(k,1,n)tp[k][j]=m[k][j]; memset(vis,0,sizeof(vis)); if(find(i,0)&amp;&amp;find(i,1))ans++; else rep(j,0,1)rep(k,1,n)m[k][j]=tp[k][j]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1129]]></title>
    <url>%2Flg1129%2F</url>
    <content type="text"><![CDATA[链接:lg1129 Description 小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个N*N黑白方阵进行（如同国际象 棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作： 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色） 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色） 游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。 对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有 解。 Input 第一行包含一个整数T，表示数据的组数。 接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。Output 包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。Sample Input 2 2 0 0 0 1 3 0 0 1 0 1 0 1 0 0Sample Output No Yes题解 N行和N列都能匹配且值为N的话，一定会有解 所以建个二分图，跑个最大匹配12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=500;int l[N][N],mark[N],vis[N],n,ans,T;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x)&#123; rep(i,1,n)if(l[x][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!mark[i]||find(mark[i]))&#123; mark[i]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; read(T); while(T--)&#123; ans=0; memset(mark,0,sizeof(mark)); read(n); rep(i,1,n)rep(j,1,n)read(l[i][j]); rep(i,1,n)&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; if(ans==n)printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3041]]></title>
    <url>%2Fhdu3041%2F</url>
    <content type="text"><![CDATA[链接:hdu3041 Description Bessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 &lt;= N &lt;= 500). The grid contains K asteroids (1 &lt;= K &lt;= 10,000), which are conveniently located at the lattice points of the grid. Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids. Input Line 1: Two integers N and K, separated by a single space. Lines 2..K+1: Each line contains two space-separated integers R and C (1 &lt;= R, C &lt;= N) denoting the row and column coordinates of an asteroid, respectively.Output Line 1: The integer representing the minimum number of times Bessie must shoot.Sample Input 3 4 1 1 1 3 2 2 3 2Sample Output 2题解 二分图最小点覆盖 其实就等于二分图最大匹配 数组忘了清零，WA一发，数组开大十倍，TLE一发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],cnt=1,vis[N],mark[N],n,m,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void reade(int a,int b)&#123;e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; ans=0; memset(head,0,sizeof(head)); memset(mark,0,sizeof(mark)); rep(i,1,m)&#123; int x,y; read(x);read(y); reade(x,y); &#125; rep(i,1,n)&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2071]]></title>
    <url>%2Flg2071%2F</url>
    <content type="text"><![CDATA[链接:lg2071 Description 已知车上有N排座位，有N*2个人参加省赛，每排座位只能坐两人，且每个人都有自己想坐的排数，问最多使多少人坐到自己想坐的位置。 Input 第一行，一个正整数Ｎ。 第二行至第Ｎ*2+1行，每行两个正整数Si1，Si2，为每个人想坐的排数。Output 一个非负整数，为最多使得多少人满意。Sample Input 4 1 2 1 3 1 2 1 3 1 3 2 4 1 3 2 3Sample Output 7题解 二分图匹配，每个人加4次边就好了 mdzz 数组开大10倍，TLE无限次。。。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],cnt=1,vis[N],mark[N],n,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void reade(int a,int b)&#123;e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n*2)&#123; int x; scanf("%d",&amp;x); reade(i,x); reade(i,x+n); scanf("%d",&amp;x); reade(i,x); reade(i,n+x); &#125; ans=0; rep(i,1,n*2)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2063]]></title>
    <url>%2Fhdu2063%2F</url>
    <content type="text"><![CDATA[链接:hdu2063 Description RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的 规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做 partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只 让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山 车吗？ Input 输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000 1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。Sample Input 6 3 3 1 1 1 2 1 3 2 1 2 3 3 1 0Sample Output 3题解 二分图最优匹配模板题 用的匈牙利算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],mark[N],vis[N],cnt=1,k,n,m,ans;int find(int u)&#123; for(int i=head[u];i!=-1;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;k)&amp;&amp;k)&#123; memset(head,-1,sizeof(head)); memset(mark,0,sizeof(mark)); read(m);read(n); rep(i,1,k)&#123; int x,y; read(x);read(y); e[i].init(y,head[x]); head[x]=i; &#125; ans=0; rep(i,1,m)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1233]]></title>
    <url>%2Fhdu1233%2F</url>
    <content type="text"><![CDATA[链接:hdu1233 Description 某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路 交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正 整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。 当N为0时，输入结束，该用例不被处理。Output 对每个测试用例，在1行里输出最小的公路总长度。Sample Input 3 1 2 1 1 3 2 2 3 4 4 1 2 1 1 3 4 1 4 1 2 3 3 2 4 2 3 4 5 0Sample Output 3 5题解 模板题 写的kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define abs(x) x=x&gt;0?x:(-x)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int u,v,w; bool operator &lt;(const node y)&#123;return w&lt;y.w;&#125; inline void init(int a,int b,int c)&#123;u=a; v=b; w=c;&#125;&#125;e[N];int f[N],n,m;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123;x=find(x); y=find(y); return x==y?0:f[x]=y;&#125;int kruskal()&#123; rep(i,1,n)f[i]=i; int ans=0,cnt=0; rep(i,1,m)&#123; int x=find(e[i].u); int y=find(e[i].v); if(un(x,y))ans+=e[i].w,cnt++; if(cnt==n-1)return ans; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; m=n*(n-1)/2; rep(i,1,m)&#123; int a,b,c; read(a);read(b);read(c); e[i].init(a,b,c); e[m+i].init(b,a,c); &#125; m&lt;&lt;=1; sort(e+1,e+m+1); printf("%d\n",kruskal()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1875]]></title>
    <url>%2Fhdu1875%2F</url>
    <content type="text"><![CDATA[链接:hdu1875 Description 相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府 决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分 了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省 资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 Input 输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。 每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000 的整数。Output 每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.Sample Input 2 2 10 10 20 20 3 1 1 2 2 1000 1000Sample Output 1414.2 oh!题解 模板题 用kruskal做的，智障地答案不清零，wa了一发1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;struct node&#123; int u,v; double w; inline void init(int a,int b,double c)&#123;u=a; v=b; w=c;&#125;&#125;e[N];int x[N],y[N],f[N],ct,n,T;double ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;x=0;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;double dis(int a,int b)&#123;return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;int find(int a)&#123;return f[a]==a?a:f[a]=find(f[a]);&#125;void un(int a,int b)&#123;a=find(a); b=find(b); if(a!=b)f[a]=b;&#125; bool cmp(node a,node b)&#123;return a.w&lt;b.w;&#125;int kruskal()&#123; rep(i,1,n)f[i]=i; int cnt=0; rep(i,0,ct-1)&#123; int a=find(e[i].u),b=find(e[i].v); if(a!=b)&#123; un(a,b); cnt++; ans+=e[i].w; &#125; if(cnt==n-1)return 1; &#125; if(cnt!=n-1)return 0;&#125;int main()&#123; read(T); while(T--)&#123; ct=0; ans=0; read(n); rep(i,1,n)read(x[i]),read(y[i]); rep(i,1,n)rep(j,i+1,n)&#123; double a=dis(i,j); if(a&lt;10||a&gt;1000)continue; e[ct++].init(i,j,a); e[ct++].init(j,i,a); &#125; sort(e,e+ct,cmp); if(kruskal())printf("%.1lf\n",ans*100); else puts("oh!"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf#469]]></title>
    <url>%2Fcf-469%2F</url>
    <content type="text"><![CDATA[链接:cf#469 C题目大意 给你一个01串，将他分成k个子串，每个子串由0开始0结尾，01交替出现 题解 两个数组分别存以0结尾，以1结尾的串的序号，当当前字符为1的时候，如果以0结尾的串为空，输出-1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=200010; char s[N];vector&lt;int&gt; ans[N],z1,z0;int main()&#123; scanf("%s",s+1); int len=strlen(s+1); rep(i,1,len)&#123; if(s[i]=='1')&#123; if(!z0.size())&#123; puts("-1");return 0; &#125; int t=z0.back();z0.pop_back(); ans[t].push_back(i);z1.push_back(t); &#125; else &#123; if(!z1.size())&#123; z0.push_back(i);ans[i].push_back(i); &#125; else &#123; int t=z1.back();z1.pop_back(); ans[t].push_back(i);z0.push_back(t); &#125; &#125; &#125; if(z1.size())&#123; puts("-1");return 0; &#125; printf("%d\n",z0.size()); len=z0.size(); rep(i,0,len-1)&#123; int tp=ans[z0[i]].size(); printf("%d",tp); rep(j,0,tp-1)printf(" %d",ans[z0[i]][j]); printf("\n"); &#125; return 0;&#125; D题目大意 n个数字，每两个数字中间插一个空，每次将最右边的数移动到最右边的空格处，q个询问，问最后在xi位置的元素题解 数据范围是1e18次方，显然需要找规律，显然n/2左边的数字都是不动的，对于第x(i)个位置的元素，他会转移到2*(x(i)-n)的位置 上去，即是P(x)=n+x/2 (x位置上的元素由P(x)转移过来)12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;ll n,q,x;int main()&#123; while(~scanf("%I64d%I64d",&amp;n,&amp;q))&#123; while(q--)&#123; scanf("%I64d",&amp;x); while(!(x&amp;1))x+=n-x/2; printf("%I64d\n",(x+1)/2); &#125; &#125; return 0;&#125; 总结 考场上两道题都没做出来，没状态，code能力太弱。 再弱小也还是要努力地活下去。]]></content>
      <categories>
        <category>比赛</category>
        <category>cf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ccf认证2017-12-4行车路线]]></title>
    <url>%2Fccf%E8%AE%A4%E8%AF%812017-12-4%E8%A1%8C%E8%BD%A6%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[链接:ccf认证2017-12-4行车路线 Description 小明和小芳出去乡村玩，小明负责开车，小芳来导航。 小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快 速增加，连续走s公里小明会增加s2的疲劳度。 例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路 口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。 现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。 Input 输入的第一行包含两个整数n, m，分别表示路口的数量和道路的数量。路口由1至n编号，小明需要开车从1号路口到n号路口。 接下来m行描述道路，每行包含四个整数t, a, b, c，表示一条类型为t，连接a与b两个路口，长度为c公里的双向道路。其中t为0表示大 道，t为1表示小道。保证1号路口和n号路口是连通的。Output 输出一个整数，表示最优路线下小明的疲劳度。Sample Input 6 7 1 1 2 3 1 2 3 2 0 1 3 30 0 3 4 20 0 4 5 30 1 3 5 6 1 5 6 1Sample Output 76题解 最短路，小路和大路分开来计算，注意中间结果可能爆int，并且可能给出重复的路，需要取最优值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+10;const ll inf=1e18+7;ll dis[N],dis0[N],n,m,in[N],g[N][N],g0[N][N];queue&lt;int&gt; q;void spfa(int s,int t)&#123; q.push(s); dis[s]=dis0[s]=0; in[s]=1; rep(i,1,n)if(i!=s)dis[i]=dis0[i]=inf; while(!q.empty())&#123; int k=q.front(); q.pop(); in[k]=0; rep(i,1,n)&#123; ll tp=g[k][i]; if(dis[i]&gt;dis[k]+tp)&#123; //前一次走的大路 dis[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(dis[i]&gt;dis0[k]+tp)&#123; //前一次走的小路 dis[i]=dis0[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(g0[k][i]!=inf)&#123; //现在走小路 tp=g0[k][i]*g0[k][i]; if(dis0[i]&gt;dis[k]+tp)&#123; dis0[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,i,n)g[i][j]=g[j][i]=g0[i][j]=g0[j][i]=inf; rep(i,1,m)&#123; int a,b,c,d; scanf("%d%d%d%d",&amp;d,&amp;a,&amp;b,&amp;c); if(d==0)g[a][b]=g[b][a]=min(g[a][b],(ll)c); else g0[a][b]=g0[b][a]=min(g0[a][b],(ll)c); &#125; rep(k,1,n)rep(i,1,n)rep(j,i+1,n)g0[i][j]=min(g0[i][k]+g0[k][j],g0[i][j]); //floyd先求出两点间最小的小路 spfa(1,n); printf("%lld\n",min(dis[n],dis0[n])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>spfa</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青出于蓝胜于蓝]]></title>
    <url>%2F%E9%9D%92%E5%87%BA%E4%BA%8E%E8%93%9D%E8%83%9C%E4%BA%8E%E8%93%9D%2F</url>
    <content type="text"><![CDATA[链接:青出于蓝胜于蓝 Description 武当派一共有 n 人，门派内 n 人按照武功高低进行排名，武功最高的人排名第 1，次高的人排名第 2，…武功最低的人排名第 n。现 在我们用武功的排名来给每个人标号，除了祖师爷，每个人都有一个师父，每个人可能有多个徒弟。 我们知道，武当派人才辈出，连祖师爷的武功都只能排行到 p。也就是说徒弟的武功是可能超过师父的，所谓的青出于蓝胜于蓝。 请你帮忙计算每个人的所有子弟（包括徒弟的徒弟，徒弟的徒弟的徒弟….）中，有多少人的武功超过了他自己。 Input 输入第一行两个整数 n,p(1≤n≤100000,1≤p≤n)。 接下来 n−1 行，每行输入两个整数u,v(1≤u,v≤n)，表示 u 和 v 之间存在师徒关系。Output 输出一行 n 个整数，第 i 个整数表示武功排行为 i 的人的子弟有多少人超过了他。行末不要输出多余的空格。Sample Input 10 5 5 3 5 8 3 4 3 1 2 1 6 7 8 7 9 8 8 10Sample Output 0 0 2 0 4 0 1 2 0 0题解 树状数组维护dfs的时间戳，每访问一个点，in数组标记他，标记完所有子树的节点后，out数组取消标记 然后这个点的答案就是out[u]到in[u]区间内的和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=100070;int f[N],tr[N&lt;&lt;2],p,n,cnt,in[N],out[N ];vector&lt;int&gt;e[N];void add(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;int ask(int x)&#123; int tp=0; for(int i=x;i;i-=lowbit(i))tp+=tr[i]; return tp;&#125;void dfs(int u,int fa)&#123; in[u]=++cnt; int len=e[u].size(); rep(i,0,len-1)if(e[u][i]!=fa)dfs(e[u][i],u); out[u]=cnt;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;p; rep(i,2,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; e[x].push_back(y); e[y].push_back(x); &#125; dfs(p,-1); rep(i,1,n)&#123; cout&lt;&lt;ask(out[i])-ask(in[i]); if(i!=n)cout&lt;&lt;' '; add(in[i],1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数列求值]]></title>
    <url>%2F%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[链接:数列求值 Description 对于一个含有 n+2个元素的数列A0, A1, … , An，满足这样的递归公式: Ai = (Ai-1 + Ai+1) /2 - Ci 1≤i≤n 现在我们知道A0, An+1和C1, C2, … , Cn 现在请你帮忙计算A1的值。 Input 第一行输入一个整数n(1≤n≤1000)。 第二行输入两个数A0, An+1，接着是 n个数据分别是C1, C2, … , Cn。所有的数据均是两位小数的浮点数。Output 输出A1的值，结果保留两位小数。Sample Input 1 50.50 25.50 10.15 2 -756.89 52.52 172.22 67.17 Sample Output27.85 -761.49 题解 根据公式可以推导出 A(2)==2A(1)-A(0)+2C(1) 先不看后面的C A(3)==2A(2)-A(1)==3A(1)-2*A(0) . . . A(n+1)==(n+1)A(1)-(n)A(0) 由于我们已知A(n+1) 看起来好像只需要这个公式就可以求出A(1) 然而还有我们忽略的C 由于未知A(1) 先将A(1)看成0 然后根据这个式子地推出A(n+1)暂时命名为tp,跟正确的A(n+1)相差的只有(n+1)*A(1) 剩下的就不用说了吧。。。123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+11;int n;double tp,f[N],c;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;f[0]&gt;&gt;tp; rep(i,2,n+1)&#123; cin&gt;&gt;c; f[i]=2*f[i-1]-f[i-2]+2*c; &#125; printf("%.2lf\n",(tp-f[n+1])/(n+1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天上的星星]]></title>
    <url>%2F%E5%A4%A9%E4%B8%8A%E7%9A%84%E6%98%9F%E6%98%9F%2F</url>
    <content type="text"><![CDATA[链接:天上的星星 Description 在一个星光摧残的夜晚，蒜头君一颗一颗的数这天上的星星。 蒜头君给在天上巧妙的画了一个直角坐标系，让所有的星星都分布在第一象。天上有 n 颗星星，他能知道每一颗星星的坐标和亮度。 现在，蒜头君问自己 q 次，每次他问自己每个矩形区域的星星的亮度和是多少（包含边界上的星星）。 Input 第一行输入一个整数n(1≤n≤50000)，表示星星的数量。 接下来n行，每行输入三个整数x,y,w(0≤x,y,w≤2000)，表示在坐标(x,y)有一颗亮度为w的星星。注意一个点可能有多个星星。 接下来一行输入一个整数q(1≤q≤50000)，表示查询的次数。 接下来q行，每行输入四个整数x1,y1,x2,y2，其中(x1,y1)表示查询的矩形的左下角的坐标，(x2,y2)表示查询的矩形的右上角的坐标， 0≤x1≤x2≤2000，0≤y1≤y2≤2000。Output 对于每一次查询，输出一行一个整数，表示查询的矩形区域内的星星的亮度总和。Sample Input 5 5 0 6 7 9 7 8 6 13 9 7 1 3 0 19 4 0 8 7 9 0 0 7 10 2 7 10 9 5 4 7 5Sample Output 7 32 8 0题解 容斥原理加前缀和，水题，傻逼地写了个n颗线段树维护。。。 答案是dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1] 计算dp的时候，维护每行的前缀和，然后dp[i][j]=dp[i-1][j]+tp[i][j];123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=3000;int dp[N][N],tp[N][N],g[N][N],q,n;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); g[x+1][y+1]+=w; //注意这里是+= 有可能给出重复的点 &#125; rep(i,1,2001)rep(j,1,2001)&#123; tp[i][j]=tp[i][j-1]+g[i][j]; //第i行1-j列的和 dp[i][j]=dp[i-1][j]+tp[i][j]; &#125; scanf("%d",&amp;q); while(q--)&#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); x1++;y1++;x2++;y2++; printf("%d\n",dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2253]]></title>
    <url>%2Fpoj2253%2F</url>
    <content type="text"><![CDATA[链接:poj2253 Description Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping. Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps. To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence. The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone. Input The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n. Output For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. Sample Input 2 0 0 3 4 3 17 4 19 4 18 5 0 Sample Output Scenario #1 Frog Distance = 5.000 Scenario #2 Frog Distance = 1.414题解 最短路变形，松弛及松弛条件改为max(dis[k],g[k][i])&lt;dis[i],12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;typedef pair&lt;double,int&gt; l;const int N=507;double g[N][N],dis[N];int vis[N],x[N],y[N],n,cnt;priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;double dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(vis,0,sizeof(vis)); rep(i,1,n)dis[i]=0x3f3f3f3f; q.push(l(dis[s]=0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); vis[k]=1; rep(i,1,n)if(max(dis[k],g[k][i])&lt;dis[i])&#123; dis[i]=max(dis[k],g[k][i]); if(!vis[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t];&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,i-1)g[i][j]=g[j][i]=len(i,j); printf("Scenario #%d\nFrog Distance = %.3lf\n\n",++cnt,dijkstra(1,2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1491]]></title>
    <url>%2Flg1491%2F</url>
    <content type="text"><![CDATA[链接:lg1491 Description 每次有大的活动，大家都要在一起“聚一聚”，不管是去好乐迪，还是避风塘，或者汤姆熊，大家都要玩的痛快。还记得心语和花儿在跳舞 机上的激情与释放，还记得草草的投篮技艺是如此的高超，还记得狗狗的枪法永远是’S’……还有不能忘了，胖子的歌声永远是让我们惊叫 的！！ 今天是野猫的生日，所以想到这些也正常，只是因为是上学日，没法一起去玩了。但回忆一下那时的甜蜜总是一种幸福嘛。。。 但是每次集合的时候都会出现问题！野猫是公认的“路盲”，野猫自己心里也很清楚，每次都提前出门，但还是经常迟到，这点让大家很是 无奈。后来，野猫在每次出门前，都会向花儿咨询一下路径，根据已知的路径中，总算能按时到了。 现在提出这样的一个问题：给出n个点的坐标，其中第一个为野猫的出发位置，最后一个为大家的集合位置，并给出哪些位置点是相连 的。野猫从出发点到达集合点，总会挑一条最近的路走，如果野猫没找到最近的路，他就会走第二近的路。请帮野猫求一下这条第二最短 路径长度。 Input 第一行是两个整数n(1&lt;=n&lt;=200)和m，表示一共有n个点和m条路，以下n行每行两个数xi，yi，(-500&lt;=xi,yi&lt;=500),代表第i个点的坐 标，再往下的m行每行两个整数pj，qj,(1&lt;=pj,qj&lt;=n)，表示两个点相通。Output 只有一行包含一个数，为第二最短路线的距离（保留两位小数），如果存在多条第一短路径，则答案就是第一最短路径的长度；如果不存 在第二最短路径，输出－1。Sample Input 3 3 0 0 1 1 0 2 1 2 1 3 2 3Sample Output 2.83题解 求次短路，只需要把最长路求出来记录路劲，然后所有第二短路求最小值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;typedef pair&lt;double,int&gt; l;const int N=507;int pre[N],head[N],in[N],n,m,x[N],y[N],cnt;double dis[N],g[N][N],tp[N];priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow(x[a]-x[b],2)+pow(y[a]-y[b],2));&#125;double dijkstra(int s,int t,int op)&#123; while(!q.empty())q.pop(); rep(i,1,n)dis[i]=0x3f3f3f3f; memset(in,0,sizeof(in)); q.push(l(0,s)); dis[s]=0; while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; rep(i,1,n)&#123; if(dis[k]+g[k][i]&gt;=dis[i])continue; dis[i]=dis[k]+g[k][i]; if(op)pre[i]=k; if(!in[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t]==0x3f3f3f3f?-1:dis[t];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,n)if(i!=j)g[i][j]=0x3f3f3f3f; rep(i,1,m)&#123; int a,b,c; scanf("%d%d",&amp;a,&amp;b); g[a][b]=g[b][a]=len(a,b); &#125; if(dijkstra(1,n,1)==-1)printf("-1\n"); else &#123; for(int i=n;i!=1;i=pre[i])&#123; double k=g[i][pre[i]]; g[i][pre[i]]=g[pre[i]][i]=0x3f3f3f3f; tp[cnt++]=dijkstra(1,n,0); g[i][pre[i]]=g[pre[i]][i]=k; &#125; double ans=0x3f3f3f3f; rep(i,0,cnt-1)if(tp[i]!=-1)ans=min(ans,tp[i]); printf("%.2lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1119]]></title>
    <url>%2Flg1119%2F</url>
    <content type="text"><![CDATA[链接:lg1119 Description B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村 庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 给出B地区的村庄数N，村庄编号从0到N-1，和所有M条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间t[i]，你可以认为 是同时开始重建并在第t[i]天重建完成，并且在当天即可通车。若t[i]为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有 Q个询问(x, y, t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经 过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回-1。 Input 输入文件rebuild.in的第一行包含两个正整数N，M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数t[0], t[1], …, t[N – 1]，表示了每个村庄重建完成的时间，数据保证了t[0] ≤ t[1] ≤ … ≤ t[N – 1]。 接下来M行，每行3个非负整数i, j, w，w为不超过10000的正整数，表示了有一条连接村庄i与村庄j的道路，长度为w，保证i≠j，且对 于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。 接下来Q行，每行3个非负整数x, y, t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。Output 输出文件rebuild.out包含Q行，对每一个询问(x, y, t)输出对应的答案，即在第t天，从村庄x到村庄y的最短路径长度为多少。如果在 第t天无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未修复完成，则输出-1。Sample Input 4 5 1 2 3 4 0 2 1 2 3 1 3 1 2 2 1 4 0 3 5 4 2 0 2 0 1 2 0 1 3 0 1 4Sample Output -1 -1 5 4题解 n&lt;=200 floyd就可以了，每次提问，枚举中间的k 如果k这个点重建完成或者没访问过就用它松弛其他路径12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=307;int t[N],dis[N][N],vis[N];int n,m,q;int main()&#123; ios::sync_with_stdio(false); memset(dis,0x3f,sizeof(dis)); cin&gt;&gt;n&gt;&gt;m; rep(i,0,n-1)cin&gt;&gt;t[i]; rep(i,1,m)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dis[a][b]=dis[b][a]=c; &#125; cin&gt;&gt;q; while(q--)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; rep(k,0,n-1)&#123; if(t[k]&gt;c||vis[k])continue; rep(i,0,n-1)if(i!=k)rep(j,0,n-1)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); vis[k]=1; &#125; if(dis[a][b]==0x3f3f3f3f||!vis[a]||!vis[b])cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;dis[a][b]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>floyd</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spfa]]></title>
    <url>%2Fspfa%2F</url>
    <content type="text"><![CDATA[SPFA: Shortest Path Faster Algorithm 看到名字不禁为之一颤，SPFA算法是西南交通大学段凡丁于1994年发表的。 SPFA 也是竞赛中最常见的算法之一，不仅仅用来解决带负权的单源最短路 而且是求解差分约束问题的专用算法，也常用它和最大流合作解决最小费问题 SPFA 算法的最坏复杂度为 O(2*E)。。 SPFA 和dijkstra 格式很接近，只是加了个队列或栈就变得无比神奇了。 这里用邻接表形式写下spfa 的模板 后面再介绍它的其它功能，这里只知道它处理最短路很快即可 优点 可以处理负权，判负环，快代码12345678910111213141516171819202122queue&lt;int&gt; q;int spfa(int s,int t)&#123; memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(vis)); //memset(c,0,sizeof(c)); q.push(s); in[s]=1; //c[s]=1; while(!q.empty())&#123; int k=q.front();q.pop(); in[k]=0; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i]&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])&#123; q.push(e[i].t); in[e[i].t]++; c[e[i].t]++; //if(c[e[i].t]&gt;n)return ok=0 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra优化]]></title>
    <url>%2Fdijkstra%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化 dijkstra 注意到贪心的过程是每次选取最小的dis值出来，这里是O(n)的，我们可以用优先队列把他优化到O(logn) 12345678910111213141516171819typedef pair&lt;int,int&gt; l;priority_queue&lt;s,vector&lt;s&gt;,greater&lt;s&gt; &gt;q;int dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(0)); d[s]=0;in[s]=1; q.push(l(0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i].w&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])q.push(l(d[i],e[i].t)); &#125; &#125; return d[t]!=inf?d[t]:-1;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra算法详解]]></title>
    <url>%2Fdijkstra%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最短路 从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径解决算法： floyd dijkstra spfa dijktsra优化 spfa优化 dijkstra算法介绍 算法思路: 利用贪心的思想，维护一个dis数组，值为源点到各个顶点的最短距离，以及一个vis数组，表示该点已经算出最短路的点的集合 每次找到dis值最小的顶点（这个dis值就是改点到源点的最短距离），标记它，然后用它来松弛可以松弛的点， 时间复杂度： 很显然是O(n2)的 缺点：无法处理负权代码 int dijkstra(int s,int t){ rep(i,1,n+1){ d[i]=g[s][i]; vis[i]=0; } vis[s]=1; rep(i,2,n+1){ int mx=inf,k=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;d[j]&lt;mx){ mx=d[j]; k=j; } vis[k]=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;mx+g[k][j]&lt;d[j]){ d[j]=mx+g[k][j]; } } return d[t]!=inf?d[t]:-1; }]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3252]]></title>
    <url>%2Fpoj3252%2F</url>
    <content type="text"><![CDATA[链接:poj3252 Description The cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone’ (also known as ‘Rock, Paper, Scissors’, ‘Ro, Sham, Bo’, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can’t even flip a coin because it’s so hard to toss using hooves. They have thus resorted to “round number” matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both “round numbers”, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a “round number” if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many “round numbers” are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start &lt; Finish ≤ 2,000,000,000). Input Line 1: Two space-separated integers, respectively Start and Finish.Output Line 1: A single integer that is the count of round numbers in the inclusive range Start..FinishSample Input 2 12Sample Output 6题解 模板题1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)const int N=66;int a[N],dp[N][N];//当前第i位，零的个数为j共有多少种情况 int dfs(int pos,int sta,int limit,int lead)&#123; if(pos==-1)return sta&gt;=32;; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:1; int tmp=0; rep(i,0,up+1)&#123; if(i==0&amp;&amp;lead)tmp+=dfs(pos-1,sta,limit&amp;&amp;i==a[pos],lead); else tmp+=dfs(pos-1,sta+(i==0?1:-1),i==a[pos]&amp;&amp;limit,lead&amp;&amp;i==0); &#125; if(!limit&amp;&amp;!lead)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x&amp;1; x&gt;&gt;=1; &#125; return dfs(cnt-1,32,1,1);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4734]]></title>
    <url>%2Fhdu4734%2F</url>
    <content type="text"><![CDATA[链接:hdu4734 Description For a decimal number x with n digits (AnAn-1An-2 … A2A1), we define its weight as F(x) = An 2n-1 + An-1 2n-2 + … + A2 2 + A1 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). Input The first line has a number T (T &lt;= 10000) , indicating the number of test cases. For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109)Output For every case,you should output “Case #t: “ at first, without quotes. The t is the case number starting from Then output the answer.Sample Input30 1001 105 100Sample OutputCase #1: 1Case #2: 2Case #3: 13题解 模板题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)using namespace std;const int N=4600;int a[10],dp[10][N];int n;int dfs(int pos,int limit,int sum)&#123; if(sum&lt;0)return 0; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sum]!=-1)return dp[pos][sum]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(pos-1,limit&amp;&amp;i==a[pos],sum-i*(1&lt;&lt;pos)); &#125; if(!limit)dp[pos][sum]=tmp; return tmp;&#125;int solve(int x,int y)&#123; int cnt=0,len=0,ans=0; while(y)&#123; ans+=y%10*(1&lt;&lt;len); len++; y/=10; &#125; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,1,ans);&#125;int main()&#123; scanf("%d",&amp;n); memset(dp,-1,sizeof(dp)); rep(i,0,n)&#123; int A,B; scanf("%d%d",&amp;A,&amp;B); printf("Case #%d: %d\n",i+1,solve(B,A)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3709]]></title>
    <url>%2Fhdu3709%2F</url>
    <content type="text"><![CDATA[链接:hdu3709 Description A balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 42 + 11 = 9 and 9*1 = 9, for left part and right part, respectively. It’s your job to calculate the number of balanced numbers in a given range [x, y]. Input The input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018).Output For each case, print the number of balanced numbers in the range [x, y] in a line.Sample Input 2 0 9 7604 24324Sample Output 10 897题解 模板题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=22;ll dp[N][N][2000];//第i位，枢轴为j的时候和为k时共有多少种情况满足符合要求 int a[N];ll dfs(int len,int pos,int limit,int sta)&#123; if(len==-1)return sta?0:1; if(sta&lt;0)return 0; if(!limit&amp;&amp;dp[len][pos][sta]!=-1)return dp[len][pos][sta]; int up=limit?a[len]:9; ll tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(len-1,pos,limit&amp;&amp;i==a[len],sta+i*(len-pos)); &#125; if(!limit)dp[len][pos][sta]=tmp; return tmp;&#125;ll solve(ll x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; ll ans=0; rep(i,0,cnt)&#123; ans+=dfs(cnt-1,i,1,0); &#125; return ans-cnt+1;&#125;int main()&#123; ll l,r; int T; scanf("%d",&amp;T); memset(dp,-1,sizeof(dp)); while(T--)&#123; scanf("%lld%lld",&amp;l,&amp;r); printf("%lld\n",solve(r)-solve(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2089]]></title>
    <url>%2Fhdu2089%2F</url>
    <content type="text"><![CDATA[链接:hdu2089 Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别 的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。Sample Input 1 100 0 0Sample Output 80题解 模板题1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define rep(i,l,n)for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=55;int a[N];ll dp[N][2];//当前第i位，前置有或没有6共有多少种情况 int dfs(int pos,int pre,int sta,int limit)&#123; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; if(pre==6&amp;&amp;i==2)continue; if(i==4)continue; tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;a[pos]==i); &#125; if(!limit)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,-1,0,true);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp));//不管l与r怎么给 已经计算出来的状态是不会改变的 while(~scanf("%d%d",&amp;l,&amp;r))&#123; if(l==0&amp;&amp;r==0)break; printf("%d\n",solve(r)-solve(l-1)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1352]]></title>
    <url>%2Flg1352%2F</url>
    <content type="text"><![CDATA[链接:lg1352 Description InputOutputSample InputSample Output题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)using namespace std;const int N=1e4;int fa[N],r[N],dp[N][2],vis[N];int n,root=1;template &lt;typename T&gt;inline void read(T&amp;x)&#123; x=0;char c;int sign=1; do&#123; c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123; x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void tdp(int node)&#123; vis[node]=1; rep(i,1,n)if(!vis[i]&amp;&amp;fa[i]==node)&#123; tdp(i); dp[node][1]+=dp[i][0]; dp[node][0]+=max(dp[i][1],dp[i][0]); &#125;&#125;int main()&#123; read(n); rep(i,1,n)read(dp[i][1]); rep(i,1,n-1)&#123; int x,y; read(x);read(y); fa[x]=y; &#125; rep(i,1,n)if(!fa[i])&#123; root=i;break; &#125; tdp(root); printf("%d",max(dp[root][1],dp[root][0])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5647]]></title>
    <url>%2Fhdu5647%2F</url>
    <content type="text"><![CDATA[链接:hdu5647 Description DZY has an unrooted tree consisting of n nodes labeled from 1 to n. DZY likes connected sets on the tree. A connected set S is a set of nodes, such that every two nodes u,v in S can be connected by a path on the tree, and the path should only contain nodes from S. Obviously, a set consisting of a single node is also considered a connected set. The size of a connected set is defined by the number of nodes which it contains. DZY wants to know the sum of the sizes of all the connected sets. Can you help him count it? The answer may be large. Please output modulo 109+7. Input First line contains t denoting the number of testcases.t testcases follow. In each testcase, first line contains n. In lines 2∼n, ith line contains pi, meaning there is an edge between node i and node pi. (1≤pi≤i−1,2≤i≤n) (n≥1， sum of n in all testcases does not exceed 200000)Output Output one line for each testcase, modulo 109+7.Sample Input 2 1 5 1 2 2 3Sample Output 1 42题解 ans[i]由两部分组成，这个节点做的贡献dp[u](sum[x]+1) 孩子做的贡献dp[x]sum[u] 具体看代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;const int mod=1e9+7;int T,n;ll dp[N],sum[N],head[N],cnt;ll ans;struct node&#123; int v,nxt;&#125;e[N];void readin()&#123; scanf("%d",&amp;n); rep(i,2,n)&#123; int x; scanf("%d",&amp;x); e[cnt].v=i; e[cnt].nxt=head[x]; head[x]=cnt++; &#125;&#125;void dfs(int u)&#123; sum[u]=1; dp[u]=1; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int x=e[i].v; dfs(x); dp[u]=(dp[u]*(sum[x]+1)%mod+dp[x]*sum[u]%mod)%mod;//新加的点做的贡献+这个孩子原来做的贡献 sum[u]=(sum[u]*(sum[x]+1))%mod; &#125; ans=(ans+dp[u])%mod;&#125;int main()&#123; //ios::sync_with_stdio(false); scanf("%d",&amp;T); while(T--)&#123; ans=0; cnt=0; memset(head,-1,sizeof(head)); readin(); dfs(1); //cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2196]]></title>
    <url>%2Fhdu2196%2F</url>
    <content type="text"><![CDATA[链接:hdu2196 Description A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. Input Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. Output For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).Sample Input 5 1 1 2 1 3 1 1 1Sample Output 3 2 3 4 4题解 对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点， 或者经过他父亲到达的一个节点。但是可能当前节点在根节点最远距离的路径上 父节点存的最大值可能正好是从该点过来的 1]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5627]]></title>
    <url>%2Fhdu5627%2F</url>
    <content type="text"><![CDATA[链接:hdu5627 Description Clarke is a patient with multiple personality disorder. One day he turned into a learner of graph theory. He learned some algorithms of minimum spanning tree. Then he had a good idea, he wanted to find the maximum spanning tree with bit operation AND. A spanning tree is composed by n−1 edges. Each two points of n points can reach each other. The size of a spanning tree is generated by bit operation AND with values of n−1 edges. Now he wants to figure out the maximum spanning tree. Input The first line contains an integer T(1≤T≤5), the number of test cases. For each test case, the first line contains two integers n,m(2≤n≤300000,1≤m≤300000), denoting the number of points and the number of edge 、 respectively. Then mlines followed, each line contains three integers x,y,w(1≤x,y≤n,0≤w≤109), denoting an 、 edge between x,ywith value w. The number of test case with n,m&gt;100000 will not exceed 1. Output For each test case, print a line contained an integer represented the answer. If there is no any spanning tree, print 0.Sample Input 1 4 5 1 2 5 1 3 3 1 4 2 2 3 1 3 4 7Sample Output 1题解 按位与最大生成树，从最高位贪心到最低位，看该位和其他已经获得的位能否构成生成树 能构成就加上这一位，不然就扔掉 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e6;int x[N],y[N],w[N],f[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x);y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); int ans=0; repd(i,20,0)&#123; ans+=(1&lt;&lt;i); rep(j,1,m)f[j]=j; int cnt=0; rep(j,1,m)if((w[j]&amp;ans)==ans&amp;&amp;un(x[j],y[j]))cnt++; //注意此处不是(w[j]&amp;(1&lt;&lt;i))==(1&lt;&lt;i) if(cnt!=n-1)ans-=(1&lt;&lt;i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5651]]></title>
    <url>%2Fhdu5651%2F</url>
    <content type="text"><![CDATA[链接:hdu5651 Description As we all known, xiaoxin is a brilliant coder. He knew palindromic strings when he was only a six grade student at elementry school. This summer he was working at Tencent as an intern. One day his leader came to ask xiaoxin for help. His leader gave him a string and he wanted xiaoxin to generate palindromic strings for him. Once xiaoxin generates a different palindromic string, his leader will give him a watermelon candy. The problem is how many candies xiaoxin’s leader needs to buy? Input This problem has multi test cases. First line contains a single integer T(T≤20) which represents the number of test cases. For each test case, there is a single line containing a string S(1≤length(S)≤1,000).Output For each test case, print an integer which is the number of watermelon candies xiaoxin’s leader needs to buy after mod 1,000,000,007.Sample Input 3 aa aabb aSample Output 1 2 1题解 如果奇数大于1肯定无解，然后所有字母出现次数除2，按照不相异的元素的全排列公式进行计算，然后用乘法逆元做一下， 乘法逆元用拓展欧几里得做12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;const ll p=1000000007;char str[N];int a[30],T,len,cnt,flag;int exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0; d=a;&#125; else &#123;exgcd(b,a%b,d,x,y); ll t=x;x=y;y=t-a/b*x;&#125;&#125;ll inv(ll a,ll p)&#123; ll d,x,y; exgcd(a,p,d,x,y); return d==1?(x%p+p)%p:-1;&#125;void readin()&#123; cin&gt;&gt;str; len=strlen(str);cnt=flag=0; memset(a,0,sizeof(a)); rep(i,0,len-1)a[str[i]-'a']++; rep(i,0,29)&#123; if(a[i]&amp;1)flag++; if(a[i])&#123; a[i]&gt;&gt;=1; cnt+=a[i]; &#125; &#125;&#125;ll sum(ll X)&#123; ll tp=1; rep(i,2,X)tp=tp*i%p; return tp;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; readin(); if(flag&gt;1)&#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; rep(i,0,26)if(a[i]!=0)&#123; a[i]=sum(a[i]); a[i]=inv(a[i],p); &#125; ll ans=sum(cnt); rep(i,0,26)if(a[i])ans=ans*a[i]%p; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里德</category>
      </categories>
      <tags>
        <tag>拓展欧几里德</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2044]]></title>
    <url>%2Flg2044%2F</url>
    <content type="text"><![CDATA[链接:lg2044 Description 栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随 机数列，这种方法需要设置四个非负整数参数m,a,c,X[0],按照下面的公式生成出一系列随机数{Xn}： X[n+1]=(aX[n]+c) mod m 其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。 用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的C++和Pascal的产生随机数的库函数使用的也是这 种方法。 栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道X[n]是多少。由于栋栋需要的随机数是0,1,…,g-1之间的， 他需要将X[n]除以g取余得到他想要的数，即X[n] mod g，你只需要告诉栋栋他想要的数X[n] mod g是多少就可以了。 Input 输入包含6个用空格分割的整数m,a,c,X[0],n和g，其中a,c,X[0]是非负整数，m,n,g是正整数。Output 输出一个数，即X[n] mod gSample Input 11 8 7 1 5 3Sample Output 2题解 矩阵快速幂模板 注意要用快速乘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;ll n,m,A,c,d,p; struct mat&#123; ll a[2][2];&#125;; mat T=&#123;1,1,0,1&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;m&gt;&gt;A&gt;&gt;c&gt;&gt;d&gt;&gt;n&gt;&gt;p;&#125;ll K(ll x,ll y)&#123; ll ans=0; x%=m;y%=m; while(y)&#123; if(y&amp;1)ans=(ans+x)%m; x=(x+x)%m; y&gt;&gt;=1; &#125; return ans;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; //cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"j="&lt;&lt;j&lt;&lt;' '&lt;&lt;x.a[i][k]*y.a[k][j]&lt;&lt;' '&lt;&lt;ans.a[i][j]&lt;&lt;endl; //cout&lt;&lt;K(x.a[i][k],y.a[k][j])&lt;&lt;endl; ans.a[i][j]=(ans.a[i][j]+K(x.a[i][k],y.a[k][j]))%m; &#125; return ans;&#125;void solve()&#123; readin(); T.a[0][0]=A; mat ans=&#123;0,d,0,c&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1]%p&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1962]]></title>
    <url>%2Flg1962%2F</url>
    <content type="text"><![CDATA[链接:lg1962 Description 大家都知道，斐波那契数列是满足如下性质的一个数列：• f(1) = 1• f(2) = 1• f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数) 请你求出 f(n) mod 1000000007 的值。 Input 第 1 行：一个整数 nOutput 第 1 行： f(n) mod 1000000007 的值Sample Input1: 52: 10Sample Output1: 52: 55 题解 F(n)=F(n-1)+F(n-2) 构造T：{1,1 和A(n-1){F(n-1) 1,0} F(n-2)} 乘起来就得到F(n)，然后这就是个等比数列 然后就可以用快速幂了(手动滑稽)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int p=1000000007;struct mat&#123; ll a[2][2];&#125;;ll n;mat T=&#123;1,1,1,0&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%p; &#125; return ans;&#125;void solve()&#123; n-=2; mat ans=&#123;0,1,0,1&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1];&#125;int main()&#123; readin(); if(n==1||n==2)cout&lt;&lt;1&lt;&lt;endl; else solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯国王的烦恼]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯国王的烦恼 Description C国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然 而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛 互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。 Input 输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。Output 输出一个整数，表示居民们会抗议的天数。Sample Input 4 4 1 2 2 1 3 2 2 3 1 3 4 3Sample Output 2题解 一道很简单的并查集，拆了就不连通，相当于加上才连通 然后并查集维护一下就ok了，然后要注意的是时间相同的点的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;int f[N],n,m,ans;struct node&#123; int u,v,w;&#125;e[N];bool cmp(node x,node y)&#123; return x.w&gt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; sort(e+1,e+m+1,cmp); rep(i,1,n)f[i]=i;&#125;int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;void solve()&#123; readin(); int pre=-1; rep(i,1,m)if(un(e[i].u,e[i].v)&amp;&amp;pre!=e[i].w)ans++,pre=e[i].w; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯城市建设]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯城市建设 Description 栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮 助他。 C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个 地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。 栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。 市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。 Input 输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。 接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则 表示建设了道路后还可以赚钱（比如建设收费道路）。 接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设 码头。 输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。Output 输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一 个负数。Sample Input 5 5 1 2 4 1 3 -1 2 3 3 2 4 5 4 5 10 -1 10 10 1 1Sample Output 9题解 跑两遍最小生成树，一遍不带码头，一遍带 码头的处理：将所有码头和0点连起来形成通路 然后注意一点就是权值为负值的路一定要加，赚钱的(手动滑稽)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=123456;int f[N],n,m,cnt;ll ans1,ans2;struct node&#123; int u,v,w; inline void init(int x,int y,int z)&#123; u=x;v=y;w=z; &#125;&#125;e[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=y;&#125; bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m;cnt=m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; rep(i,1,n)&#123; int x; cin&gt;&gt;x; e[i+m].init(0,i,x); if(e[i+m].w==-1)e[i+m].w=-0x3f3f3f3f; &#125; sort(e+1,e+n+m+1,cmp); rep(i,1,n)f[i]=i;&#125;void kruskal_first()&#123; readin(); rep(i,1,n+m)&#123; if(e[i].w==-0x3f3f3f3f)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans1+=e[i].w; &#125; &#125;&#125;void kruskal_second()&#123; rep(i,1,n)f[i]=i; rep(i,1,n+m)&#123; if(e[i].u==0)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans2+=e[i].w; &#125; &#125;&#125;int main()&#123; kruskal_first(); kruskal_second(); int sum=0; rep(i,1,n)if(f[i]==i)sum++; if(sum==1)cout&lt;&lt;min(ans1,ans2); else cout&lt;&lt;ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1195]]></title>
    <url>%2Flg1195%2F</url>
    <content type="text"><![CDATA[链接:lg1195 Description 小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 给你云朵的个数N，再给你M个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成K个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 Input 每组测试数据的 第一行有三个数N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=10000,1&lt;=K&lt;=10) 接下来M个数每行三个数X,Y,L，表示X云和Y云可以通过L的代价连在一起。(1&lt;=X,Y&lt;=N,0&lt;=L&lt;10000) 30%的数据N&lt;=100,M&lt;=1000Output 对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出K个棉花糖，请输出’No Answer’。Sample Input 3 1 2 1 2 1Sample Output 1题解 建一个包含n-k-1个节点的最小生成树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=1e5+10;struct node &#123; int u,v,w;&#125;e[N];int n,m,k,ans;int f[N];int cmp(const void *a,const void *b)&#123; return ((node*)a)-&gt;w-((node*)b)-&gt;w;&#125;int find(int x)&#123; return f[x]==x?f[x]:f[x]=find(f[x]);&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=f[y];&#125;void Kruskal()&#123; qsort(e,m,sizeof(e[0]),cmp); rep(i,1,n+1)f[i]=i; int cnt=0; rep(i,0,m)&#123; int x=e[i].u,y=e[i].v; if(find(x)!=find(y))&#123; un(x,y); ans+=e[i].w; cnt++; &#125; if(cnt==k)break; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; ans=0; rep(i,0,m)scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); k=n-k; if(k&lt;=m)Kruskal(); if(ans)printf("%d\n",ans); else printf("No Answer\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5586]]></title>
    <url>%2Fhdu5586%2F</url>
    <content type="text"><![CDATA[链接:hdu5586 Problem Description There is a number sequence {A}_{1},{A}_{2}….{A}_{n},you can select a interval [l,r] or not,all the numbers {A}_{i}(l \leq i \leq r) will become f({A}_{i}).f(x)=(1890x+143) mod 10007.After that,the sum of n numbers should be as much as possible.What is the maximum sum? Input There are multiple test cases. First line of each case contains a single integer n.(1\leq n\leq {10}^{5}) Next line contains n integers {A}_{1},{A}_{2}….{A}_{n}.(0\leq {A}_{i}\leq {10}^{4}) It’s guaranteed that \sum n\leq {10}^{6}. Output For each test case,output the answer in a line. Sample Input2 10000 9999 5 1 9999 1 9999 1 Sample Output19999 22033 题解 最大子段和12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;const int mod=10007;ll a[N],b[N],c[N],ans;int n,m;int f(ll x)&#123; return (x%mod*1890+143)%mod;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; ans=0; rep(i,1,n)&#123; scanf("%lld",&amp;a[i]); b[i]=f(a[i])-a[i]; ans+=a[i]; &#125; int tp=0,k=0; rep(i,1,n)&#123; if(tp+b[i]&gt;0)tp+=b[i]; else tp=0; if(tp&gt;k)k=tp; &#125; printf("%lld\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相交弦统计]]></title>
    <url>%2F%E7%9B%B8%E4%BA%A4%E5%BC%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Description Kimi 最近得到了一个玩具，玩具由环和弦两个部分组成。环上有 2*N 个端 点，而 N 条弦，每条连接其中的两个，既不重复也不遗漏。Kimi 对这些弦产生 了浓厚的兴趣，他想数一数，一共有多少对弦是相交的呢？ Input 输入文件的第一行包含一个整数 N。 接下来 N 行，每行包含两个整数 a、b(1≤a，b≤2*N)，表示一条连接 a，b 的弦Output 输出文件中近包含一个整数，表示相交弦的对Sample Input 3 2 5 2 6 3Sample Output 1题解 两条弦相交只需要保证其中一条的一个点在另一条的两个端点之间 然后树状数组or线段树维护一下前n个数有多少个左or右端点就好 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;const int N=1e6;ll tr[N&lt;&lt;1],n;struct node&#123; int l,r;&#125;e[N];int cmp(node x,node y)&#123;return x.l&lt;y.l;&#125;void update(int x,int k)&#123;for(register int i=x;i&lt;=n&lt;&lt;1;i+=lowbit(i))tr[i]+=k;&#125;ll ask(int x)&#123;ll ans=0; for(register int i=x;i;i-=lowbit(i))ans+=tr[i];return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; rep(i,1,n)&#123; cin&gt;&gt;e[i].l&gt;&gt;e[i].r; if(e[i].l&gt;e[i].r)swap(e[i].l,e[i].r); &#125; sort(e+1,e+n+1,cmp); rep(i,1,n)&#123; ans+=ask(e[i].r-1)-ask(e[i].l); update(e[i].r,1); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468]]></title>
    <url>%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[链接:poj3468 Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. Input The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. “C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000. “Q a b” means querying the sum of Aa, Aa+1, … , Ab. Output You need to answer all Q commands in order. One answer in a line.Sample Input 10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4Sample Output 4 55 9 15题解 区间修改区间查询 维护个懒标记就好，具体看代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;ll tr[N&lt;&lt;2],a[N],add[N];int n,m;void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1]; &#125;&#125;void pushdown(int o,int l,int r)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; //懒标记下放 add[o&lt;&lt;1|1]+=add[o]; int mid=l+r&gt;&gt;1; tr[o&lt;&lt;1]+=add[o]*(mid-l+1); tr[o&lt;&lt;1|1]+=add[o]*(r-mid); add[o]=0; &#125;&#125;void update(int o,int l,int r,int L,int R,ll k)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; add[o]+=k; tr[o]+=k*(r-l+1); return ; //做个标记，不下放 &#125; pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(o&lt;&lt;1,l,mid,L,R,k); if(R&gt;mid)update(o&lt;&lt;1|1,mid+1,r,L,R,k); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=ask(o&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1)ans+=ask(o&lt;&lt;1|1,mid+1,r,L,R); return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; char p; ll x,y; cin&gt;&gt;p&gt;&gt;x&gt;&gt;y; if(p=='C')&#123; ll k; cin&gt;&gt;k; update(1,1,n,x,y,k); &#125; else cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2299]]></title>
    <url>%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[链接:poj2299 Description In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence 9 1 0 5 4 , Ultra-QuickSort produces the output 0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. Input The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999, 999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.Output For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.Sample Input 5 9 1 0 5 4 3 1 2 3 0Sample Output 6 0题解 求逆序对数目 开一个大小为这些数的最大值的树状数组，并全部置0。从头到尾读入这些数，每读入一个数就更新树状数组，查看它前面比它小的已出现 过的有多少个数 sum，然后用当前位置减去该sum，就可以得到当前数导致的逆序对数了。把所有的加起来就是总的逆序对数。 然而问题来了，数据最大999999999，显然开不下 解决方法是离散化一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e6+100;struct node&#123; int val,pos;&#125;b[N];int a[N],tree[N],n;ll ans;bool cmp(node x,node y)&#123; return x.val&lt;y.val;&#125;void add(int x,int k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tree[i]+=k;&#125;int getsum(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=lowbit(i))ans+=tree[i]; return ans;&#125;void readin()&#123; rep(i,1,n)&#123; cin&gt;&gt;b[i].val; b[i].pos=i; &#125; memset(a,0,sizeof(a)); memset(tree,0,sizeof(tree)); sort(b+1,b+n+1,cmp); rep(i,1,n)&#123; add(b[i].pos,1); //离散化 ans+=i-getsum(b[i].pos); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; if(n==0)break; ans=0; readin(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1754]]></title>
    <url>%2Fhdu1754%2F</url>
    <content type="text"><![CDATA[链接:hdu1754 Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output 对于每一次询问操作，在一行里面输出最高成绩。Sample Input 5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5Sample Output 5 6 5 9题解 单点查询区间修改 线段树模板题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll tr[N&lt;&lt;2];int n,m,a[N];void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;void update(int o,int l,int r,int pos,int k)&#123; if(l==r)tr[o]=k; else &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)add(o&lt;&lt;1,l,mid,pos,k); else add(o&lt;&lt;1|1,mid+1,r,pos,k); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&gt;r||R&lt;l)return -1; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; int mid=l+r&gt;&gt;1; int p1=ask(o&lt;&lt;1,l,mid,L,R),p2=ask(o&lt;&lt;1|1,mid+1,r,L,R); return max(p1,p2);&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; int x,y; char c; cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c=='Q')cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; else update(1,1,n,x,y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
