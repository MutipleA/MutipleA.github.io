<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[lightoj1042]]></title>
    <url>%2Flightoj1042%2F</url>
    <content type="text"><![CDATA[链接:lightoj1042 DescriptionThis is the tale of Zephyr, the greatest time traveler the world will never know. Even those who are aware of Zephyr&apos;s existence know very little about her. For example, no one has any clue as to which time period she is originally from. But we do know the story of the first time she set out to chart her own path in the time stream. Zephyr had just finished building her time machine which she named - &quot;Dokhina Batash&quot;. She was making the final adjustments for her first trip when she noticed that a vital program was not working correctly. The program was supposed to take a number N, and find what Zephyr called its Onoroy value. The Onoroy value of an integer N is the number of ones in its binary representation. For example, the number 13 (11012) has an Onoroy value of 3. Needless to say, this was an easy problem for the great mind of Zephyr. She solved it quickly, and was on her way. You are now given a similar task. Find the first number after N which has the same Onoroy value as N. InputInput starts with an integer T (≤ 65), denoting the number of test cases. Each case begins with an integer N (1 ≤ N ≤ 109). OutputFor each case of input you have to print the case number and the desired result. Sample Input5 23 14232 391 7 8 Sample OutputCase 1: 27 Case 2: 14241 Case 3: 395 Case 4: 11 Case 5: 16 题解思路还行，代码实现有点困难，太弱了 把n最右边的连续的1向右移动直到个数-1，把n最左边连续的1的末尾的相邻0改为1就是答案了 以下是我的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;int pre,T,n,ct,now,bit[40],id;int get(int x)&#123; int cnt=0; while(x)&#123; if(x&amp;1)cnt++; x&gt;&gt;=1; &#125; return cnt;&#125;int getbit(int x)&#123; rep(i,0,30)&#123; if(x&amp;1)bit[i]=1; else bit[i]=0; x&gt;&gt;=1; &#125;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); ct=get(n); n+=lowbit(n);getbit(n);now=get(n); while(ct!=now)&#123; rep(i,0,30)if(!bit[i])&#123; now++;bit[i]=1; n|=(1&lt;&lt;i);break; &#125; &#125; printf("Case %d: %d\n",++id,n); &#125; return 0;&#125; 以下是大佬的代码，我只想说。。差距好大12345678910111213141516171819#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; typedef long long ll; int main() &#123; ll t; scanf("%lld",&amp;t); for(ll k=1;k&lt;=t;++k) &#123; ll n; scanf("%lld",&amp;n); ll x=n&amp;-n,y=n+x; n=((n&amp;~y)/x&gt;&gt;1)|y; printf("Case %lld: %lld\n",k,n); &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2825[HEOI2016/TJOI2016]]]></title>
    <url>%2FP2825-HEOI2016-TJOI2016%2F</url>
    <content type="text"><![CDATA[链接:P2825[HEOI2016/TJOI2016] Description在2016年，佳缘姐姐喜欢上了一款游戏，叫做泡泡堂。简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者 躲开对手的炸弹。在玩游戏的过程中，小H想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个 炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。给定一张 n*m的网格地图:其中*代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。x代表软石头，炸弹的威力可以穿透，不能在此放置 炸弹。#代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出1*4的网格地图*xx*，这个地图上最多只能放置一个炸 弹。给出另一个1*4的网格地图*x#*，这个地图最多能放置两个炸弹。现在小H任意给出一张n*m的网格地图，问你最多能放置多少炸弹。 Input第一行输入两个正整数n,m,n表示地图的行数，m表示地图的列数。1≤n,m≤50。接下来输入n行m列个字符，代表网格地图。*的个数不超过 n*m个。 Output输出一个整数a，表示最多能放置炸弹的个数 Sample Input4 4 #*** *#** **#* xxx# Sample Output5 题解提取出每一行和每一列的极长连续不含#的非空字串 显然，炸弹只能放在*上，而放一个就会把它周围清空，这样显然就是二分图最大匹配了 以他们为节点，每一行和每一列连边。跑一个匈牙利就出来了。 zz地弄了个骚操作加边，然后WA一万次。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=55;const int M=3e3;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[M];int head[M],cnt,tol,col[N][N],row[N][N],n,m,vis[M],mark[M],ans;char str[N][N];inline void add(int a,int b)&#123; e[++cnt].init(b,head[a]); head[a]=cnt;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,1,m)cin&gt;&gt;str[i][j]; rep(i,1,n)rep(j,1,m)if(str[i][j]!='#')&#123; if(j==1||str[i][j-1]=='#')tol++; row[i][j]=tol; &#125; rep(j,1,m)rep(i,1,n)if(str[i][j]!='#')&#123; if(i==1||str[i-1][j]=='#')tol++; col[i][j]=tol; &#125; rep(i,1,n)rep(j,1,m)if(str[i][j]=='*')add(row[i][j],col[i][j]); rep(i,1,tol)&#123;memset(vis,0,sizeof(vis));ans+=find(i);&#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1640]]></title>
    <url>%2Flg1640%2F</url>
    <content type="text"><![CDATA[链接:lg1640 Descriptionlxhgww最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有2个属性，这些属性的值用[1,10000]之间的数表示。当他使 用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。游戏进行到最后，lxhgww遇到了终极boss，这个终 极boss很奇怪，攻击他的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。也就是说一开始的时候，lxhgww只能 使用某个属性值为1的装备攻击boss，然后只能使用某个属性值为2的装备攻击boss，然后只能使用某个属性值为3的装备攻击boss……以此 类推。现在lxhgww想知道他最多能连续攻击boss多少次？ Input输入的第一行是一个整数N，表示lxhgww拥有N种装备接下来N行，是对这N种装备的描述，每行2个数字，表示第i种装备的2个属性值 Output输出一行，包括1个数字，表示lxhgww最多能连续攻击的次数。 Sample Input3 1 2 3 2 4 5 Sample Output2 题解mdzz 因为标记方式不同，各种RE TLE 思路很简单，但是不好想，用伤害匹配装备 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1000070;const int M=10070;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N&lt;&lt;1];int head[M],mark[N],cnt,n,vis[M],ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void add(int a,int b)&#123; e[++cnt].init(b,head[a]); head[a]=cnt;&#125;int find(int u)&#123; if(vis[u])return 0; vis[u]=1; for(int i=head[u];i;i=e[i].nxt)if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; return 0;&#125;int main()&#123; read(n); rep(i,1,n)&#123;int x; read(x); add(x,i); read(x); add(x,i);&#125; rep(i,1,10000)&#123;memset(vis,0,sizeof(vis)); if(find(i))ans++;else break;&#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1402]]></title>
    <url>%2Flg1402%2F</url>
    <content type="text"><![CDATA[链接:lg1402 DescriptionXX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也 有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。 有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜 欢的房间，吃到喜欢的菜）。 这里要怎么分配，能使最多顾客满意呢？ Input第一行给出三个正整数表示n,p,q(&lt;=100)。 之后n行，每行p个数包含0或1，第i个数表示喜不喜欢第i个房间（1表示喜欢，0表示不喜欢）。 之后n行，每行q个数，表示喜不喜欢第i道菜。 Output顾客最大满意数 Sample Input2 2 2 1 0 1 0 1 1 1 1 Sample Output1 题解做两个最大匹配，如果都匹配上了，答案+1，否则返回上次状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define abs(x) x=x&gt;0?x:(-x)using namespace std;const int N=300;int l[N][N][2],m[N][2],vis[N][2],n,p,q,tp[N][2];template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x,int op)&#123; rep(i,1,n)if(l[x][i][op]&amp;&amp;!vis[i][op])&#123; vis[i][op]=1; if(!m[i][op]||find(m[i][op],op))&#123; m[i][op]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; int ans=0; read(n);read(p);read(q); rep(i,1,n)rep(j,1,p)read(l[i][j][0]); rep(i,1,n)rep(j,1,q)read(l[i][j][1]); rep(i,1,n)&#123; rep(j,0,1)rep(k,1,n)tp[k][j]=m[k][j]; memset(vis,0,sizeof(vis)); if(find(i,0)&amp;&amp;find(i,1))ans++; else rep(j,0,1)rep(k,1,n)m[k][j]=tp[k][j]; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1129]]></title>
    <url>%2Flg1129%2F</url>
    <content type="text"><![CDATA[链接:lg1129 Description小Q是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个N*N黑白方阵进行（如同国际象 棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作： 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色） 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色） 游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。 对于某些关卡，小Q百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！！于是小Q决定写一个程序来判断这些关卡是否有 解。 Input第一行包含一个整数T，表示数据的组数。 接下来包含T组数据，每组数据第一行为一个整数N，表示方阵的大小；接下来N行为一个N*N的01矩阵（0表示白色，1表示黑色）。 Output包含T行。对于每一组数据，如果该关卡有解，输出一行Yes；否则输出一行No。 Sample Input2 2 0 0 0 1 3 0 0 1 0 1 0 1 0 0 Sample OutputNo Yes 题解N行和N列都能匹配且值为N的话，一定会有解 所以建个二分图，跑个最大匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=500;int l[N][N],mark[N],vis[N],n,ans,T;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x)&#123; rep(i,1,n)if(l[x][i]&amp;&amp;!vis[i])&#123; vis[i]=1; if(!mark[i]||find(mark[i]))&#123; mark[i]=x; return 1; &#125; &#125; return 0;&#125;int main()&#123; read(T); while(T--)&#123; ans=0; memset(mark,0,sizeof(mark)); read(n); rep(i,1,n)rep(j,1,n)read(l[i][j]); rep(i,1,n)&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; if(ans==n)printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3041]]></title>
    <url>%2Fhdu3041%2F</url>
    <content type="text"><![CDATA[链接:hdu3041 DescriptionBessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 &lt;= N &lt;= 500). The grid contains K asteroids (1 &lt;= K &lt;= 10,000), which are conveniently located at the lattice points of the grid. Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find the minimum number of shots Bessie needs to fire to eliminate all of the asteroids. Input* Line 1: Two integers N and K, separated by a single space. * Lines 2..K+1: Each line contains two space-separated integers R and C (1 &lt;= R, C &lt;= N) denoting the row and column coordinates of an asteroid, respectively. Output* Line 1: The integer representing the minimum number of times Bessie must shoot. Sample Input3 4 1 1 1 3 2 2 3 2 Sample Output2 题解二分图最小点覆盖 其实就等于二分图最大匹配 数组忘了清零，WA一发，数组开大十倍，TLE一发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5+7;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],cnt=1,vis[N],mark[N],n,m,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void reade(int a,int b)&#123;e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; ans=0; memset(head,0,sizeof(head)); memset(mark,0,sizeof(mark)); rep(i,1,m)&#123; int x,y; read(x);read(y); reade(x,y); &#125; rep(i,1,n)&#123; memset(vis,0,sizeof(vis)); ans+=find(i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2071]]></title>
    <url>%2Flg2071%2F</url>
    <content type="text"><![CDATA[链接:lg2071 Description已知车上有N排座位，有N*2个人参加省赛，每排座位只能坐两人，且每个人都有自己想坐的排数，问最多使多少人坐到自己想坐的位置。 Input第一行，一个正整数Ｎ。 第二行至第Ｎ*2+1行，每行两个正整数Si1，Si2，为每个人想坐的排数。 Output一个非负整数，为最多使得多少人满意。 Sample Input4 1 2 1 3 1 2 1 3 1 3 2 4 1 3 2 3 Sample Output7 题解二分图匹配，每个人加4次边就好了 mdzz 数组开大10倍，TLE无限次。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],cnt=1,vis[N],mark[N],n,ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;inline void reade(int a,int b)&#123;e[cnt].init(b,head[a]); head[a]=cnt++;&#125;int find(int u)&#123; for(int i=head[u];i;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;n); rep(i,1,n*2)&#123; int x; scanf("%d",&amp;x); reade(i,x); reade(i,x+n); scanf("%d",&amp;x); reade(i,x); reade(i,n+x); &#125; ans=0; rep(i,1,n*2)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2063]]></title>
    <url>%2Fhdu2063%2F</url>
    <content type="text"><![CDATA[链接:hdu2063 DescriptionRPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的 规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做 partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只 让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山 车吗？ Input输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000 1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。 Output对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 Sample Input6 3 3 1 1 1 2 1 3 2 1 2 3 3 1 0 Sample Output3 题解二分图最优匹配模板题 用的匈牙利算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6+7;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;struct node&#123; int v,nxt; inline void init(int a,int b)&#123;v=a; nxt=b;&#125;&#125;e[N];int head[N],mark[N],vis[N],cnt=1,k,n,m,ans;int find(int u)&#123; for(int i=head[u];i!=-1;i=e[i].nxt)if(!vis[e[i].v])&#123; vis[e[i].v]=1; if(!mark[e[i].v]||find(mark[e[i].v]))&#123; mark[e[i].v]=u; return 1; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;k)&amp;&amp;k)&#123; memset(head,-1,sizeof(head)); memset(mark,0,sizeof(mark)); read(m);read(n); rep(i,1,k)&#123; int x,y; read(x);read(y); e[i].init(y,head[x]); head[x]=i; &#125; ans=0; rep(i,1,m)&#123; memset(vis,0,sizeof(vis)); if(find(i))ans++; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>二分图匹配</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1233]]></title>
    <url>%2Fhdu1233%2F</url>
    <content type="text"><![CDATA[链接:hdu1233 Description某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路 交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 Input测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正 整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。 当N为0时，输入结束，该用例不被处理。 Output对每个测试用例，在1行里输出最小的公路总长度。 Sample Input3 1 2 1 1 3 2 2 3 4 4 1 2 1 1 3 4 1 4 1 2 3 3 2 4 2 3 4 5 0 Sample Output3 5 题解模板题 写的kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define abs(x) x=x&gt;0?x:(-x)#define ll long longusing namespace std;const int N=1e5;struct node&#123; int u,v,w; bool operator &lt;(const node y)&#123;return w&lt;y.w;&#125; inline void init(int a,int b,int c)&#123;u=a; v=b; w=c;&#125;&#125;e[N];int f[N],n,m;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;int sign=1;x=0; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0';c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;int find(int x)&#123;return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123;x=find(x); y=find(y); return x==y?0:f[x]=y;&#125;int kruskal()&#123; rep(i,1,n)f[i]=i; int ans=0,cnt=0; rep(i,1,m)&#123; int x=find(e[i].u); int y=find(e[i].v); if(un(x,y))ans+=e[i].w,cnt++; if(cnt==n-1)return ans; &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; m=n*(n-1)/2; rep(i,1,m)&#123; int a,b,c; read(a);read(b);read(c); e[i].init(a,b,c); e[m+i].init(b,a,c); &#125; m&lt;&lt;=1; sort(e+1,e+m+1); printf("%d\n",kruskal()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1875]]></title>
    <url>%2Fhdu1875%2F</url>
    <content type="text"><![CDATA[链接:hdu1875 Description相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府 决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分 了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省 资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。 Input输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。 每组数据首先是一个整数C(C &lt;= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000 的整数。 Output每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”. Sample Input2 2 10 10 20 20 3 1 1 2 2 1000 1000 Sample Output1414.2 oh! 题解模板题 用kruskal做的，智障地答案不清零，wa了一发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;struct node&#123; int u,v; double w; inline void init(int a,int b,double c)&#123;u=a; v=b; w=c;&#125;&#125;e[N];int x[N],y[N],f[N],ct,n,T;double ans;template &lt;typename T&gt;inline void read(T &amp;x)&#123; char c;x=0;int sign=1; do&#123;c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123;x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;double dis(int a,int b)&#123;return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;int find(int a)&#123;return f[a]==a?a:f[a]=find(f[a]);&#125;void un(int a,int b)&#123;a=find(a); b=find(b); if(a!=b)f[a]=b;&#125; bool cmp(node a,node b)&#123;return a.w&lt;b.w;&#125;int kruskal()&#123; rep(i,1,n)f[i]=i; int cnt=0; rep(i,0,ct-1)&#123; int a=find(e[i].u),b=find(e[i].v); if(a!=b)&#123; un(a,b); cnt++; ans+=e[i].w; &#125; if(cnt==n-1)return 1; &#125; if(cnt!=n-1)return 0;&#125;int main()&#123; read(T); while(T--)&#123; ct=0; ans=0; read(n); rep(i,1,n)read(x[i]),read(y[i]); rep(i,1,n)rep(j,i+1,n)&#123; double a=dis(i,j); if(a&lt;10||a&gt;1000)continue; e[ct++].init(i,j,a); e[ct++].init(j,i,a); &#125; sort(e,e+ct,cmp); if(kruskal())printf("%.1lf\n",ans*100); else puts("oh!"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf#469]]></title>
    <url>%2Fcf-469%2F</url>
    <content type="text"><![CDATA[链接:cf#469 C题目大意给你一个01串，将他分成k个子串，每个子串由0开始0结尾，01交替出现 题解两个数组分别存以0结尾，以1结尾的串的序号，当当前字符为1的时候，如果以0结尾的串为空，输出-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=200010; char s[N];vector&lt;int&gt; ans[N],z1,z0;int main()&#123; scanf("%s",s+1); int len=strlen(s+1); rep(i,1,len)&#123; if(s[i]=='1')&#123; if(!z0.size())&#123; puts("-1");return 0; &#125; int t=z0.back();z0.pop_back(); ans[t].push_back(i);z1.push_back(t); &#125; else &#123; if(!z1.size())&#123; z0.push_back(i);ans[i].push_back(i); &#125; else &#123; int t=z1.back();z1.pop_back(); ans[t].push_back(i);z0.push_back(t); &#125; &#125; &#125; if(z1.size())&#123; puts("-1");return 0; &#125; printf("%d\n",z0.size()); len=z0.size(); rep(i,0,len-1)&#123; int tp=ans[z0[i]].size(); printf("%d",tp); rep(j,0,tp-1)printf(" %d",ans[z0[i]][j]); printf("\n"); &#125; return 0;&#125; D题目大意n个数字，每两个数字中间插一个空，每次将最右边的数移动到最右边的空格处，q个询问，问最后在xi位置的元素 题解数据范围是1e18次方，显然需要找规律，显然n/2左边的数字都是不动的，对于第x(i)个位置的元素，他会转移到2*(x(i)-n)的位置 上去，即是P(x)=n+x/2 (x位置上的元素由P(x)转移过来) 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;ll n,q,x;int main()&#123; while(~scanf("%I64d%I64d",&amp;n,&amp;q))&#123; while(q--)&#123; scanf("%I64d",&amp;x); while(!(x&amp;1))x+=n-x/2; printf("%I64d\n",(x+1)/2); &#125; &#125; return 0;&#125; 总结考场上两道题都没做出来，没状态，code能力太弱。 再弱小也还是要努力地活下去。]]></content>
      <categories>
        <category>比赛</category>
        <category>cf</category>
      </categories>
      <tags>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ccf认证2017-12-4行车路线]]></title>
    <url>%2Fccf%E8%AE%A4%E8%AF%812017-12-4%E8%A1%8C%E8%BD%A6%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[链接:ccf认证2017-12-4行车路线 Description小明和小芳出去乡村玩，小明负责开车，小芳来导航。 小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快 速增加，连续走s公里小明会增加s2的疲劳度。 例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路 口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。 现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。 Input输入的第一行包含两个整数n, m，分别表示路口的数量和道路的数量。路口由1至n编号，小明需要开车从1号路口到n号路口。 接下来m行描述道路，每行包含四个整数t, a, b, c，表示一条类型为t，连接a与b两个路口，长度为c公里的双向道路。其中t为0表示大 道，t为1表示小道。保证1号路口和n号路口是连通的。 Output输出一个整数，表示最优路线下小明的疲劳度。 Sample Input6 7 1 1 2 3 1 2 3 2 0 1 3 30 0 3 4 20 0 4 5 30 1 3 5 6 1 5 6 1 Sample Output76 题解最短路，小路和大路分开来计算，注意中间结果可能爆int，并且可能给出重复的路，需要取最优值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+10;const ll inf=1e18+7;ll dis[N],dis0[N],n,m,in[N],g[N][N],g0[N][N];queue&lt;int&gt; q;void spfa(int s,int t)&#123; q.push(s); dis[s]=dis0[s]=0; in[s]=1; rep(i,1,n)if(i!=s)dis[i]=dis0[i]=inf; while(!q.empty())&#123; int k=q.front(); q.pop(); in[k]=0; rep(i,1,n)&#123; ll tp=g[k][i]; if(dis[i]&gt;dis[k]+tp)&#123; //前一次走的大路 dis[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(dis[i]&gt;dis0[k]+tp)&#123; //前一次走的小路 dis[i]=dis0[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(g0[k][i]!=inf)&#123; //现在走小路 tp=g0[k][i]*g0[k][i]; if(dis0[i]&gt;dis[k]+tp)&#123; dis0[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,i,n)g[i][j]=g[j][i]=g0[i][j]=g0[j][i]=inf; rep(i,1,m)&#123; int a,b,c,d; scanf("%d%d%d%d",&amp;d,&amp;a,&amp;b,&amp;c); if(d==0)g[a][b]=g[b][a]=min(g[a][b],(ll)c); else g0[a][b]=g0[b][a]=min(g0[a][b],(ll)c); &#125; rep(k,1,n)rep(i,1,n)rep(j,i+1,n)g0[i][j]=min(g0[i][k]+g0[k][j],g0[i][j]); //floyd先求出两点间最小的小路 spfa(1,n); printf("%lld\n",min(dis[n],dis0[n])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>spfa</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青出于蓝胜于蓝]]></title>
    <url>%2F%E9%9D%92%E5%87%BA%E4%BA%8E%E8%93%9D%E8%83%9C%E4%BA%8E%E8%93%9D%2F</url>
    <content type="text"><![CDATA[链接:青出于蓝胜于蓝 Description武当派一共有 n 人，门派内 n 人按照武功高低进行排名，武功最高的人排名第 1，次高的人排名第 2，...武功最低的人排名第 n。现 在我们用武功的排名来给每个人标号，除了祖师爷，每个人都有一个师父，每个人可能有多个徒弟。 我们知道，武当派人才辈出，连祖师爷的武功都只能排行到 p。也就是说徒弟的武功是可能超过师父的，所谓的青出于蓝胜于蓝。 请你帮忙计算每个人的所有子弟（包括徒弟的徒弟，徒弟的徒弟的徒弟....）中，有多少人的武功超过了他自己。 Input输入第一行两个整数 n,p(1≤n≤100000,1≤p≤n)。 接下来 n−1 行，每行输入两个整数u,v(1≤u,v≤n)，表示 u 和 v 之间存在师徒关系。 Output输出一行 n 个整数，第 i 个整数表示武功排行为 i 的人的子弟有多少人超过了他。行末不要输出多余的空格。 Sample Input10 5 5 3 5 8 3 4 3 1 2 1 6 7 8 7 9 8 8 10 Sample Output0 0 2 0 4 0 1 2 0 0 题解树状数组维护dfs的时间戳，每访问一个点，in数组标记他，标记完所有子树的节点后，out数组取消标记 然后这个点的答案就是out[u]到in[u]区间内的和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=100070;int f[N],tr[N&lt;&lt;2],p,n,cnt,in[N],out[N ];vector&lt;int&gt;e[N];void add(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;int ask(int x)&#123; int tp=0; for(int i=x;i;i-=lowbit(i))tp+=tr[i]; return tp;&#125;void dfs(int u,int fa)&#123; in[u]=++cnt; int len=e[u].size(); rep(i,0,len-1)if(e[u][i]!=fa)dfs(e[u][i],u); out[u]=cnt;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;p; rep(i,2,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; e[x].push_back(y); e[y].push_back(x); &#125; dfs(p,-1); rep(i,1,n)&#123; cout&lt;&lt;ask(out[i])-ask(in[i]); if(i!=n)cout&lt;&lt;' '; add(in[i],1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数列求值]]></title>
    <url>%2F%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[链接:数列求值 Description对于一个含有 n+2个元素的数列A0, A1, ... , An，满足这样的递归公式: Ai = (Ai-1 + Ai+1) /2 - Ci 1≤i≤n 现在我们知道A0, An+1和C1, C2, ... , Cn 现在请你帮忙计算A1的值。 Input第一行输入一个整数n(1≤n≤1000)。 第二行输入两个数A0, An+1，接着是 n个数据分别是C1, C2, ... , Cn。所有的数据均是两位小数的浮点数。 Output输出A1的值，结果保留两位小数。 Sample Input1 50.50 25.50 10.15 2 -756.89 52.52 172.22 67.17 Sample Output27.85 -761.49 题解根据公式可以推导出 A(2)==2*A(1)-A(0)+2*C(1) 先不看后面的C A(3)==2*A(2)-A(1)==3*A(1)-2*A(0) . . . A(n+1)==(n+1)*A(1)-(n)*A(0) 由于我们已知A(n+1) 看起来好像只需要这个公式就可以求出A(1) 然而还有我们忽略的C 由于未知A(1) 先将A(1)看成0 然后根据这个式子地推出A(n+1)暂时命名为tp,跟正确的A(n+1)相差的只有(n+1)*A(1) 剩下的就不用说了吧。。。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+11;int n;double tp,f[N],c;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;f[0]&gt;&gt;tp; rep(i,2,n+1)&#123; cin&gt;&gt;c; f[i]=2*f[i-1]-f[i-2]+2*c; &#125; printf("%.2lf\n",(tp-f[n+1])/(n+1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天上的星星]]></title>
    <url>%2F%E5%A4%A9%E4%B8%8A%E7%9A%84%E6%98%9F%E6%98%9F%2F</url>
    <content type="text"><![CDATA[链接:天上的星星 Description在一个星光摧残的夜晚，蒜头君一颗一颗的数这天上的星星。 蒜头君给在天上巧妙的画了一个直角坐标系，让所有的星星都分布在第一象。天上有 n 颗星星，他能知道每一颗星星的坐标和亮度。 现在，蒜头君问自己 q 次，每次他问自己每个矩形区域的星星的亮度和是多少（包含边界上的星星）。 Input 第一行输入一个整数n(1≤n≤50000)，表示星星的数量。 接下来n行，每行输入三个整数x,y,w(0≤x,y,w≤2000)，表示在坐标(x,y)有一颗亮度为w的星星。注意一个点可能有多个星星。 接下来一行输入一个整数q(1≤q≤50000)，表示查询的次数。 接下来q行，每行输入四个整数x1,y1,x2,y2，其中(x1,y1)表示查询的矩形的左下角的坐标，(x2,y2)表示查询的矩形的右上角的坐标，0≤x1≤x2≤2000，0≤y1≤y2≤2000。 Output对于每一次查询，输出一行一个整数，表示查询的矩形区域内的星星的亮度总和。 Sample Input5 5 0 6 7 9 7 8 6 13 9 7 1 3 0 19 4 0 8 7 9 0 0 7 10 2 7 10 9 5 4 7 5 Sample Output7 32 8 0 题解容斥原理加前缀和，水题，傻逼地写了个n颗线段树维护。。。 答案是dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1] 计算dp的时候，维护每行的前缀和，然后dp[i][j]=dp[i-1][j]+tp[i][j]; 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=3000;int dp[N][N],tp[N][N],g[N][N],q,n;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); g[x+1][y+1]+=w; //注意这里是+= 有可能给出重复的点 &#125; rep(i,1,2001)rep(j,1,2001)&#123; tp[i][j]=tp[i][j-1]+g[i][j]; //第i行1-j列的和 dp[i][j]=dp[i-1][j]+tp[i][j]; &#125; scanf("%d",&amp;q); while(q--)&#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); x1++;y1++;x2++;y2++; printf("%d\n",dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2253]]></title>
    <url>%2Fpoj2253%2F</url>
    <content type="text"><![CDATA[链接:poj2253 DescriptionFreddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists&apos; sunscreen, he wants to avoid swimming and instead reach her by jumping. Unfortunately Fiona&apos;s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps. To execute a given sequence of jumps, a frog&apos;s jump range obviously must be at least as long as the longest jump occuring in the sequence. The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. You are given the coordinates of Freddy&apos;s stone, Fiona&apos;s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy&apos;s and Fiona&apos;s stone. InputThe input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy&apos;s stone, stone #2 is Fiona&apos;s stone, the other n-2 stones are unoccupied. There&apos;s a blank line following each test case. Input is terminated by a value of zero (0) for n. OutputFor each test case, print a line saying &quot;Scenario #x&quot; and a line saying &quot;Frog Distance = y&quot; where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. Sample Input2 0 0 3 4 3 17 4 19 4 18 5 0 Sample OutputScenario #1 Frog Distance = 5.000 Scenario #2 Frog Distance = 1.414 题解最短路变形，松弛及松弛条件改为max(dis[k],g[k][i])&lt;dis[i], 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;typedef pair&lt;double,int&gt; l;const int N=507;double g[N][N],dis[N];int vis[N],x[N],y[N],n,cnt;priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;double dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(vis,0,sizeof(vis)); rep(i,1,n)dis[i]=0x3f3f3f3f; q.push(l(dis[s]=0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); vis[k]=1; rep(i,1,n)if(max(dis[k],g[k][i])&lt;dis[i])&#123; dis[i]=max(dis[k],g[k][i]); if(!vis[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t];&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,i-1)g[i][j]=g[j][i]=len(i,j); printf("Scenario #%d\nFrog Distance = %.3lf\n\n",++cnt,dijkstra(1,2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1491]]></title>
    <url>%2Flg1491%2F</url>
    <content type="text"><![CDATA[链接:lg1491 Description每次有大的活动，大家都要在一起“聚一聚”，不管是去好乐迪，还是避风塘，或者汤姆熊，大家都要玩的痛快。还记得心语和花儿在跳舞 机上的激情与释放，还记得草草的投篮技艺是如此的高超，还记得狗狗的枪法永远是&apos;S&apos;……还有不能忘了，胖子的歌声永远是让我们惊叫 的！！ 今天是野猫的生日，所以想到这些也正常，只是因为是上学日，没法一起去玩了。但回忆一下那时的甜蜜总是一种幸福嘛。。。 但是每次集合的时候都会出现问题！野猫是公认的“路盲”，野猫自己心里也很清楚，每次都提前出门，但还是经常迟到，这点让大家很是 无奈。后来，野猫在每次出门前，都会向花儿咨询一下路径，根据已知的路径中，总算能按时到了。 现在提出这样的一个问题：给出n个点的坐标，其中第一个为野猫的出发位置，最后一个为大家的集合位置，并给出哪些位置点是相连 的。野猫从出发点到达集合点，总会挑一条最近的路走，如果野猫没找到最近的路，他就会走第二近的路。请帮野猫求一下这条第二最短 路径长度。 Input第一行是两个整数n(1&lt;=n&lt;=200)和m，表示一共有n个点和m条路，以下n行每行两个数xi，yi，(-500&lt;=xi,yi&lt;=500),代表第i个点的坐 标，再往下的m行每行两个整数pj，qj,(1&lt;=pj,qj&lt;=n)，表示两个点相通。 Output只有一行包含一个数，为第二最短路线的距离（保留两位小数），如果存在多条第一短路径，则答案就是第一最短路径的长度；如果不存 在第二最短路径，输出－1。 Sample Input3 3 0 0 1 1 0 2 1 2 1 3 2 3 Sample Output2.83 题解求次短路，只需要把最长路求出来记录路劲，然后所有第二短路求最小值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;typedef pair&lt;double,int&gt; l;const int N=507;int pre[N],head[N],in[N],n,m,x[N],y[N],cnt;double dis[N],g[N][N],tp[N];priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow(x[a]-x[b],2)+pow(y[a]-y[b],2));&#125;double dijkstra(int s,int t,int op)&#123; while(!q.empty())q.pop(); rep(i,1,n)dis[i]=0x3f3f3f3f; memset(in,0,sizeof(in)); q.push(l(0,s)); dis[s]=0; while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; rep(i,1,n)&#123; if(dis[k]+g[k][i]&gt;=dis[i])continue; dis[i]=dis[k]+g[k][i]; if(op)pre[i]=k; if(!in[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t]==0x3f3f3f3f?-1:dis[t];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,n)if(i!=j)g[i][j]=0x3f3f3f3f; rep(i,1,m)&#123; int a,b,c; scanf("%d%d",&amp;a,&amp;b); g[a][b]=g[b][a]=len(a,b); &#125; if(dijkstra(1,n,1)==-1)printf("-1\n"); else &#123; for(int i=n;i!=1;i=pre[i])&#123; double k=g[i][pre[i]]; g[i][pre[i]]=g[pre[i]][i]=0x3f3f3f3f; tp[cnt++]=dijkstra(1,n,0); g[i][pre[i]]=g[pre[i]][i]=k; &#125; double ans=0x3f3f3f3f; rep(i,0,cnt-1)if(tp[i]!=-1)ans=min(ans,tp[i]); printf("%.2lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1119]]></title>
    <url>%2Flg1119%2F</url>
    <content type="text"><![CDATA[链接:lg1119 DescriptionB地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 给出B地区的村庄数N，村庄编号从0到N-1，和所有M条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间t[i]，你可以认为 是同时开始重建并在第t[i]天重建完成，并且在当天即可通车。若t[i]为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有 Q个询问(x, y, t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经 过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回-1。 Input输入文件rebuild.in的第一行包含两个正整数N，M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数t[0], t[1], …, t[N – 1]，表示了每个村庄重建完成的时间，数据保证了t[0] ≤ t[1] ≤ … ≤ t[N – 1]。 接下来M行，每行3个非负整数i, j, w，w为不超过10000的正整数，表示了有一条连接村庄i与村庄j的道路，长度为w，保证i≠j，且对 于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。 接下来Q行，每行3个非负整数x, y, t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。 Output输出文件rebuild.out包含Q行，对每一个询问(x, y, t)输出对应的答案，即在第t天，从村庄x到村庄y的最短路径长度为多少。如果在 第t天无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未修复完成，则输出-1。 Sample Input4 5 1 2 3 4 0 2 1 2 3 1 3 1 2 2 1 4 0 3 5 4 2 0 2 0 1 2 0 1 3 0 1 4 Sample Output-1 -1 5 4 题解n&lt;=200 floyd就可以了，每次提问，枚举中间的k 如果k这个点重建完成或者没访问过就用它松弛其他路径 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=307;int t[N],dis[N][N],vis[N];int n,m,q;int main()&#123; ios::sync_with_stdio(false); memset(dis,0x3f,sizeof(dis)); cin&gt;&gt;n&gt;&gt;m; rep(i,0,n-1)cin&gt;&gt;t[i]; rep(i,1,m)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dis[a][b]=dis[b][a]=c; &#125; cin&gt;&gt;q; while(q--)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; rep(k,0,n-1)&#123; if(t[k]&gt;c||vis[k])continue; rep(i,0,n-1)if(i!=k)rep(j,0,n-1)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); vis[k]=1; &#125; if(dis[a][b]==0x3f3f3f3f||!vis[a]||!vis[b])cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;dis[a][b]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>floyd</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spfa]]></title>
    <url>%2Fspfa%2F</url>
    <content type="text"><![CDATA[SPFA: Shortest Path Faster Algorithm看到名字不禁为之一颤，SPFA算法是西南交通大学段凡丁于1994年发表的。 SPFA 也是竞赛中最常见的算法之一，不仅仅用来解决带负权的单源最短路 而且是求解差分约束问题的专用算法，也常用它和最大流合作解决最小费问题 SPFA 算法的最坏复杂度为 O(2*E)。。 SPFA 和dijkstra 格式很接近，只是加了个队列或栈就变得无比神奇了。 这里用邻接表形式写下spfa 的模板 后面再介绍它的其它功能，这里只知道它处理最短路很快即可 优点可以处理负权，判负环，快 代码12345678910111213141516171819202122queue&lt;int&gt; q;int spfa(int s,int t)&#123; memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(vis)); //memset(c,0,sizeof(c)); q.push(s); in[s]=1; //c[s]=1; while(!q.empty())&#123; int k=q.front();q.pop(); in[k]=0; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i]&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])&#123; q.push(e[i].t); in[e[i].t]++; c[e[i].t]++; //if(c[e[i].t]&gt;n)return ok=0 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra优化]]></title>
    <url>%2Fdijkstra%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化dijkstra 注意到贪心的过程是每次选取最小的dis值出来，这里是O(n)的，我们可以用优先队列把他优化到O(logn) 12345678910111213141516171819typedef pair&lt;int,int&gt; l;priority_queue&lt;s,vector&lt;s&gt;,greater&lt;s&gt; &gt;q;int dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(0)); d[s]=0;in[s]=1; q.push(l(0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i].w&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])q.push(l(d[i],e[i].t)); &#125; &#125; return d[t]!=inf?d[t]:-1;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra算法详解]]></title>
    <url>%2Fdijkstra%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最短路从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径 解决算法： floyd dijkstra spfa dijktsra优化 spfa优化 dijkstra算法介绍 算法思路: 利用贪心的思想，维护一个dis数组，值为源点到各个顶点的最短距离，以及一个vis数组，表示该点已经算出最短路的点的集合 每次找到dis值最小的顶点（这个dis值就是改点到源点的最短距离），标记它，然后用它来松弛可以松弛的点， 时间复杂度： 很显然是O(n2)的 *缺点：无法处理负权代码int dijkstra(int s,int t){ rep(i,1,n+1){ d[i]=g[s][i]; vis[i]=0; } vis[s]=1; rep(i,2,n+1){ int mx=inf,k=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;d[j]&lt;mx){ mx=d[j]; k=j; } vis[k]=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;mx+g[k][j]&lt;d[j]){ d[j]=mx+g[k][j]; } } return d[t]!=inf?d[t]:-1; }]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3252]]></title>
    <url>%2Fpoj3252%2F</url>
    <content type="text"><![CDATA[链接:poj3252 DescriptionThe cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone&apos; (also known as &apos;Rock, Paper, Scissors&apos;, &apos;Ro, Sham, Bo&apos;, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can&apos;t even flip a coin because it&apos;s so hard to toss using hooves. They have thus resorted to &quot;round number&quot; matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both &quot;round numbers&quot;, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a &quot;round number&quot; if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many &quot;round numbers&quot; are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start &lt; Finish ≤ 2,000,000,000). InputLine 1: Two space-separated integers, respectively Start and Finish. OutputLine 1: A single integer that is the count of round numbers in the inclusive range Start..Finish Sample Input2 12 Sample Output6 题解模板题 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)const int N=66;int a[N],dp[N][N];//当前第i位，零的个数为j共有多少种情况 int dfs(int pos,int sta,int limit,int lead)&#123; if(pos==-1)return sta&gt;=32;; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:1; int tmp=0; rep(i,0,up+1)&#123; if(i==0&amp;&amp;lead)tmp+=dfs(pos-1,sta,limit&amp;&amp;i==a[pos],lead); else tmp+=dfs(pos-1,sta+(i==0?1:-1),i==a[pos]&amp;&amp;limit,lead&amp;&amp;i==0); &#125; if(!limit&amp;&amp;!lead)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x&amp;1; x&gt;&gt;=1; &#125; return dfs(cnt-1,32,1,1);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4734]]></title>
    <url>%2Fhdu4734%2F</url>
    <content type="text"><![CDATA[链接:hdu4734 DescriptionFor a decimal number x with n digits (AnAn-1An-2 ... A2A1), we define its weight as F(x) = An * 2n-1 + An-1 * 2n-2 + ... + A2 * 2 + A1 * 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). InputThe first line has a number T (T &lt;= 10000) , indicating the number of test cases. For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109) OutputFor every case,you should output &quot;Case #t: &quot; at first, without quotes. The t is the case number starting from 1. Then output the answer. Sample Input3 0 100 1 10 5 100 Sample OutputCase #1: 1 Case #2: 2 Case #3: 13 题解模板题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)using namespace std;const int N=4600;int a[10],dp[10][N];int n;int dfs(int pos,int limit,int sum)&#123; if(sum&lt;0)return 0; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sum]!=-1)return dp[pos][sum]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(pos-1,limit&amp;&amp;i==a[pos],sum-i*(1&lt;&lt;pos)); &#125; if(!limit)dp[pos][sum]=tmp; return tmp;&#125;int solve(int x,int y)&#123; int cnt=0,len=0,ans=0; while(y)&#123; ans+=y%10*(1&lt;&lt;len); len++; y/=10; &#125; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,1,ans);&#125;int main()&#123; scanf("%d",&amp;n); memset(dp,-1,sizeof(dp)); rep(i,0,n)&#123; int A,B; scanf("%d%d",&amp;A,&amp;B); printf("Case #%d: %d\n",i+1,solve(B,A)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3709]]></title>
    <url>%2Fhdu3709%2F</url>
    <content type="text"><![CDATA[链接:hdu3709 DescriptionA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 4*2 + 1*1 = 9 and 9*1 = 9, for left part and right part, respectively. It&apos;s your job to calculate the number of balanced numbers in a given range [x, y]. InputThe input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018). OutputFor each case, print the number of balanced numbers in the range [x, y] in a line. Sample Input2 0 9 7604 24324 Sample Output10 897 题解模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=22;ll dp[N][N][2000];//第i位，枢轴为j的时候和为k时共有多少种情况满足符合要求 int a[N];ll dfs(int len,int pos,int limit,int sta)&#123; if(len==-1)return sta?0:1; if(sta&lt;0)return 0; if(!limit&amp;&amp;dp[len][pos][sta]!=-1)return dp[len][pos][sta]; int up=limit?a[len]:9; ll tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(len-1,pos,limit&amp;&amp;i==a[len],sta+i*(len-pos)); &#125; if(!limit)dp[len][pos][sta]=tmp; return tmp;&#125;ll solve(ll x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; ll ans=0; rep(i,0,cnt)&#123; ans+=dfs(cnt-1,i,1,0); &#125; return ans-cnt+1;&#125;int main()&#123; ll l,r; int T; scanf("%d",&amp;T); memset(dp,-1,sizeof(dp)); while(T--)&#123; scanf("%lld%lld",&amp;l,&amp;r); printf("%lld\n",solve(r)-solve(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2089]]></title>
    <url>%2Fhdu2089%2F</url>
    <content type="text"><![CDATA[链接:hdu2089 Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别 的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input1 100 0 0 Sample Output80 题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define rep(i,l,n)for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=55;int a[N];ll dp[N][2];//当前第i位，前置有或没有6共有多少种情况 int dfs(int pos,int pre,int sta,int limit)&#123; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; if(pre==6&amp;&amp;i==2)continue; if(i==4)continue; tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;a[pos]==i); &#125; if(!limit)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,-1,0,true);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp));//不管l与r怎么给 已经计算出来的状态是不会改变的 while(~scanf("%d%d",&amp;l,&amp;r))&#123; if(l==0&amp;&amp;r==0)break; printf("%d\n",solve(r)-solve(l-1)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1352]]></title>
    <url>%2Flg1352%2F</url>
    <content type="text"><![CDATA[链接:lg1352 Description InputOutputSample InputSample Output题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)using namespace std;const int N=1e4;int fa[N],r[N],dp[N][2],vis[N];int n,root=1;template &lt;typename T&gt;inline void read(T&amp;x)&#123; x=0;char c;int sign=1; do&#123; c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123; x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void tdp(int node)&#123; vis[node]=1; rep(i,1,n)if(!vis[i]&amp;&amp;fa[i]==node)&#123; tdp(i); dp[node][1]+=dp[i][0]; dp[node][0]+=max(dp[i][1],dp[i][0]); &#125;&#125;int main()&#123; read(n); rep(i,1,n)read(dp[i][1]); rep(i,1,n-1)&#123; int x,y; read(x);read(y); fa[x]=y; &#125; rep(i,1,n)if(!fa[i])&#123; root=i;break; &#125; tdp(root); printf("%d",max(dp[root][1],dp[root][0])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5647]]></title>
    <url>%2Fhdu5647%2F</url>
    <content type="text"><![CDATA[链接:hdu5647 DescriptionDZY has an unrooted tree consisting of n nodes labeled from 1 to n. DZY likes connected sets on the tree. A connected set S is a set of nodes, such that every two nodes u,v in S can be connected by a path on the tree, and the path should only contain nodes from S. Obviously, a set consisting of a single node is also considered a connected set. The size of a connected set is defined by the number of nodes which it contains. DZY wants to know the sum of the sizes of all the connected sets. Can you help him count it? The answer may be large. Please output modulo 109+7. InputFirst line contains t denoting the number of testcases.t testcases follow. In each testcase, first line contains n. In lines 2∼n, ith line contains pi, meaning there is an edge between node i and node pi. (1≤pi≤i−1,2≤i≤n) (n≥1， sum of n in all testcases does not exceed 200000) OutputOutput one line for each testcase, modulo 109+7. Sample Input2 1 5 1 2 2 3 Sample Output1 42 题解ans[i]由两部分组成，这个节点做的贡献dp[u]*(sum[x]+1) 孩子做的贡献dp[x]*sum[u] 具体看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;const int mod=1e9+7;int T,n;ll dp[N],sum[N],head[N],cnt;ll ans;struct node&#123; int v,nxt;&#125;e[N];void readin()&#123; scanf("%d",&amp;n); rep(i,2,n)&#123; int x; scanf("%d",&amp;x); e[cnt].v=i; e[cnt].nxt=head[x]; head[x]=cnt++; &#125;&#125;void dfs(int u)&#123; sum[u]=1; dp[u]=1; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int x=e[i].v; dfs(x); dp[u]=(dp[u]*(sum[x]+1)%mod+dp[x]*sum[u]%mod)%mod;//新加的点做的贡献+这个孩子原来做的贡献 sum[u]=(sum[u]*(sum[x]+1))%mod; &#125; ans=(ans+dp[u])%mod;&#125;int main()&#123; //ios::sync_with_stdio(false); scanf("%d",&amp;T); while(T--)&#123; ans=0; cnt=0; memset(head,-1,sizeof(head)); readin(); dfs(1); //cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2196]]></title>
    <url>%2Fhdu2196%2F</url>
    <content type="text"><![CDATA[链接:hdu2196 DescriptionA school bought the first computer some time ago(so this computer&apos;s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. InputInput file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. OutputFor each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). Sample Input5 1 1 2 1 3 1 1 1 Sample Output3 2 3 4 4 题解对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点， 或者经过他父亲到达的一个节点。但是可能当前节点在根节点最远距离的路径上 父节点存的最大值可能正好是从该点过来的 1]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5627]]></title>
    <url>%2Fhdu5627%2F</url>
    <content type="text"><![CDATA[链接:hdu5627 DescriptionClarke is a patient with multiple personality disorder. One day he turned into a learner of graph theory. He learned some algorithms of minimum spanning tree. Then he had a good idea, he wanted to find the maximum spanning tree with bit operation AND. A spanning tree is composed by n−1 edges. Each two points of n points can reach each other. The size of a spanning tree is generated by bit operation AND with values of n−1 edges. Now he wants to figure out the maximum spanning tree. InputThe first line contains an integer T(1≤T≤5), the number of test cases. For each test case, the first line contains two integers n,m(2≤n≤300000,1≤m≤300000), denoting the number of points and the number of edge 、 respectively. Then mlines followed, each line contains three integers x,y,w(1≤x,y≤n,0≤w≤109), denoting an 、 edge between x,ywith value w. The number of test case with n,m&gt;100000 will not exceed 1. OutputFor each test case, print a line contained an integer represented the answer. If there is no any spanning tree, print 0. Sample Input1 4 5 1 2 5 1 3 3 1 4 2 2 3 1 3 4 7 Sample Output1 题解按位与最大生成树，从最高位贪心到最低位，看该位和其他已经获得的位能否构成生成树 能构成就加上这一位，不然就扔掉 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e6;int x[N],y[N],w[N],f[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x);y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); int ans=0; repd(i,20,0)&#123; ans+=(1&lt;&lt;i); rep(j,1,m)f[j]=j; int cnt=0; rep(j,1,m)if((w[j]&amp;ans)==ans&amp;&amp;un(x[j],y[j]))cnt++; //注意此处不是(w[j]&amp;(1&lt;&lt;i))==(1&lt;&lt;i) if(cnt!=n-1)ans-=(1&lt;&lt;i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5651]]></title>
    <url>%2Fhdu5651%2F</url>
    <content type="text"><![CDATA[链接:hdu5651 DescriptionAs we all known, xiaoxin is a brilliant coder. He knew **palindromic** strings when he was only a six grade student at elementry school. This summer he was working at Tencent as an intern. One day his leader came to ask xiaoxin for help. His leader gave him a string and he wanted xiaoxin to generate palindromic strings for him. Once xiaoxin generates a different palindromic string, his leader will give him a watermelon candy. The problem is how many candies xiaoxin&apos;s leader needs to buy? InputThis problem has multi test cases. First line contains a single integer T(T≤20) which represents the number of test cases. For each test case, there is a single line containing a string S(1≤length(S)≤1,000). OutputFor each test case, print an integer which is the number of watermelon candies xiaoxin&apos;s leader needs to buy after mod 1,000,000,007. Sample Input3 aa aabb a Sample Output1 2 1 题解如果奇数大于1肯定无解，然后所有字母出现次数除2，按照不相异的元素的全排列公式进行计算，然后用乘法逆元做一下， 乘法逆元用拓展欧几里得做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;const ll p=1000000007;char str[N];int a[30],T,len,cnt,flag;int exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0; d=a;&#125; else &#123;exgcd(b,a%b,d,x,y); ll t=x;x=y;y=t-a/b*x;&#125;&#125;ll inv(ll a,ll p)&#123; ll d,x,y; exgcd(a,p,d,x,y); return d==1?(x%p+p)%p:-1;&#125;void readin()&#123; cin&gt;&gt;str; len=strlen(str);cnt=flag=0; memset(a,0,sizeof(a)); rep(i,0,len-1)a[str[i]-'a']++; rep(i,0,29)&#123; if(a[i]&amp;1)flag++; if(a[i])&#123; a[i]&gt;&gt;=1; cnt+=a[i]; &#125; &#125;&#125;ll sum(ll X)&#123; ll tp=1; rep(i,2,X)tp=tp*i%p; return tp;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; readin(); if(flag&gt;1)&#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; rep(i,0,26)if(a[i]!=0)&#123; a[i]=sum(a[i]); a[i]=inv(a[i],p); &#125; ll ans=sum(cnt); rep(i,0,26)if(a[i])ans=ans*a[i]%p; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里得</category>
      </categories>
      <tags>
        <tag>拓展欧几里得</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2044]]></title>
    <url>%2Flg2044%2F</url>
    <content type="text"><![CDATA[链接:lg2044 Description栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随 机数列，这种方法需要设置四个非负整数参数m,a,c,X[0],按照下面的公式生成出一系列随机数{Xn}： X[n+1]=(aX[n]+c) mod m 其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。 用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的C++和Pascal的产生随机数的库函数使用的也是这 种方法。 栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道X[n]是多少。由于栋栋需要的随机数是0,1,...,g-1之间的， 他需要将X[n]除以g取余得到他想要的数，即X[n] mod g，你只需要告诉栋栋他想要的数X[n] mod g是多少就可以了。 Input输入包含6个用空格分割的整数m,a,c,X[0],n和g，其中a,c,X[0]是非负整数，m,n,g是正整数。 Output输出一个数，即X[n] mod g Sample Input11 8 7 1 5 3 Sample Output2 题解矩阵快速幂模板 注意要用快速乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;ll n,m,A,c,d,p; struct mat&#123; ll a[2][2];&#125;; mat T=&#123;1,1,0,1&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;m&gt;&gt;A&gt;&gt;c&gt;&gt;d&gt;&gt;n&gt;&gt;p;&#125;ll K(ll x,ll y)&#123; ll ans=0; x%=m;y%=m; while(y)&#123; if(y&amp;1)ans=(ans+x)%m; x=(x+x)%m; y&gt;&gt;=1; &#125; return ans;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; //cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"j="&lt;&lt;j&lt;&lt;' '&lt;&lt;x.a[i][k]*y.a[k][j]&lt;&lt;' '&lt;&lt;ans.a[i][j]&lt;&lt;endl; //cout&lt;&lt;K(x.a[i][k],y.a[k][j])&lt;&lt;endl; ans.a[i][j]=(ans.a[i][j]+K(x.a[i][k],y.a[k][j]))%m; &#125; return ans;&#125;void solve()&#123; readin(); T.a[0][0]=A; mat ans=&#123;0,d,0,c&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1]%p&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1962]]></title>
    <url>%2Flg1962%2F</url>
    <content type="text"><![CDATA[链接:lg1962 Description大家都知道，斐波那契数列是满足如下性质的一个数列： • f(1) = 1 • f(2) = 1 • f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数) 请你求出 f(n) mod 1000000007 的值。 Input第 1 行：一个整数 n Output第 1 行： f(n) mod 1000000007 的值 Sample Input1: 52: 10 Sample Output1: 52: 55 题解F(n)=F(n-1)+F(n-2) 构造T：{1,1 和A(n-1){F(n-1) 1,0} F(n-2)} 乘起来就得到F(n)，然后这就是个等比数列 然后就可以用快速幂了(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int p=1000000007;struct mat&#123; ll a[2][2];&#125;;ll n;mat T=&#123;1,1,1,0&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%p; &#125; return ans;&#125;void solve()&#123; n-=2; mat ans=&#123;0,1,0,1&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1];&#125;int main()&#123; readin(); if(n==1||n==2)cout&lt;&lt;1&lt;&lt;endl; else solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯国王的烦恼]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯国王的烦恼 DescriptionC国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛 互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。 Input输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。 Output输出一个整数，表示居民们会抗议的天数。 Sample Input4 4 1 2 2 1 3 2 2 3 1 3 4 3 Sample Output2 题解一道很简单的并查集，拆了就不连通，相当于加上才连通 然后并查集维护一下就ok了，然后要注意的是时间相同的点的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;int f[N],n,m,ans;struct node&#123; int u,v,w;&#125;e[N];bool cmp(node x,node y)&#123; return x.w&gt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; sort(e+1,e+m+1,cmp); rep(i,1,n)f[i]=i;&#125;int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;void solve()&#123; readin(); int pre=-1; rep(i,1,m)if(un(e[i].u,e[i].v)&amp;&amp;pre!=e[i].w)ans++,pre=e[i].w; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯城市建设]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯城市建设 Description栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。 C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个 地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。 栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。 市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。 Input输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。 接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则 表示建设了道路后还可以赚钱（比如建设收费道路）。 接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设 码头。 输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。 Output输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。 Sample Input5 5 1 2 4 1 3 -1 2 3 3 2 4 5 4 5 10 -1 10 10 1 1 Sample Output9 题解跑两遍最小生成树，一遍不带码头，一遍带 码头的处理：将所有码头和0点连起来形成通路 然后注意一点就是权值为负值的路一定要加，赚钱的(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=123456;int f[N],n,m,cnt;ll ans1,ans2;struct node&#123; int u,v,w; inline void init(int x,int y,int z)&#123; u=x;v=y;w=z; &#125;&#125;e[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=y;&#125; bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m;cnt=m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; rep(i,1,n)&#123; int x; cin&gt;&gt;x; e[i+m].init(0,i,x); if(e[i+m].w==-1)e[i+m].w=-0x3f3f3f3f; &#125; sort(e+1,e+n+m+1,cmp); rep(i,1,n)f[i]=i;&#125;void kruskal_first()&#123; readin(); rep(i,1,n+m)&#123; if(e[i].w==-0x3f3f3f3f)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans1+=e[i].w; &#125; &#125;&#125;void kruskal_second()&#123; rep(i,1,n)f[i]=i; rep(i,1,n+m)&#123; if(e[i].u==0)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans2+=e[i].w; &#125; &#125;&#125;int main()&#123; kruskal_first(); kruskal_second(); int sum=0; rep(i,1,n)if(f[i]==i)sum++; if(sum==1)cout&lt;&lt;min(ans1,ans2); else cout&lt;&lt;ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1195]]></title>
    <url>%2Flg1195%2F</url>
    <content type="text"><![CDATA[链接:lg1195 Description小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 给你云朵的个数N，再给你M个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成K个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 Input每组测试数据的 第一行有三个数N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=10000,1&lt;=K&lt;=10) 接下来M个数每行三个数X,Y,L，表示X云和Y云可以通过L的代价连在一起。(1&lt;=X,Y&lt;=N,0&lt;=L&lt;10000) 30%的数据N&lt;=100,M&lt;=1000 Output对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出K个棉花糖，请输出&apos;No Answer&apos;。 Sample Input3 1 2 1 2 1 Sample Output1 题解建一个包含n-k-1个节点的最小生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=1e5+10;struct node &#123; int u,v,w;&#125;e[N];int n,m,k,ans;int f[N];int cmp(const void *a,const void *b)&#123; return ((node*)a)-&gt;w-((node*)b)-&gt;w;&#125;int find(int x)&#123; return f[x]==x?f[x]:f[x]=find(f[x]);&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=f[y];&#125;void Kruskal()&#123; qsort(e,m,sizeof(e[0]),cmp); rep(i,1,n+1)f[i]=i; int cnt=0; rep(i,0,m)&#123; int x=e[i].u,y=e[i].v; if(find(x)!=find(y))&#123; un(x,y); ans+=e[i].w; cnt++; &#125; if(cnt==k)break; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; ans=0; rep(i,0,m)scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); k=n-k; if(k&lt;=m)Kruskal(); if(ans)printf("%d\n",ans); else printf("No Answer\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5586]]></title>
    <url>%2Fhdu5586%2F</url>
    <content type="text"><![CDATA[链接:hdu5586 Problem DescriptionThere is a number sequence {A}_{1},{A}_{2}....{A}_{n},you can select a interval [l,r] or not,all the numbers {A}_{i}(l \leq i \leq r) will become f({A}_{i}).f(x)=(1890x+143) mod 10007.After that,the sum of n numbers should be as much as possible.What is the maximum sum? InputThere are multiple test cases. First line of each case contains a single integer n.(1\leq n\leq {10}^{5}) Next line contains n integers {A}_{1},{A}_{2}....{A}_{n}.(0\leq {A}_{i}\leq {10}^{4}) It&apos;s guaranteed that \sum n\leq {10}^{6}. OutputFor each test case,output the answer in a line. Sample Input2 10000 9999 5 1 9999 1 9999 1 Sample Output19999 22033 题解最大子段和 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;const int mod=10007;ll a[N],b[N],c[N],ans;int n,m;int f(ll x)&#123; return (x%mod*1890+143)%mod;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; ans=0; rep(i,1,n)&#123; scanf("%lld",&amp;a[i]); b[i]=f(a[i])-a[i]; ans+=a[i]; &#125; int tp=0,k=0; rep(i,1,n)&#123; if(tp+b[i]&gt;0)tp+=b[i]; else tp=0; if(tp&gt;k)k=tp; &#125; printf("%lld\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相交弦统计]]></title>
    <url>%2F%E7%9B%B8%E4%BA%A4%E5%BC%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[DescriptionKimi 最近得到了一个玩具，玩具由环和弦两个部分组成。环上有 2*N 个端 点，而 N 条弦，每条连接其中的两个，既不重复也不遗漏。Kimi 对这些弦产生 了浓厚的兴趣，他想数一数，一共有多少对弦是相交的呢？ Input输入文件的第一行包含一个整数 N。 接下来 N 行，每行包含两个整数 a、b(1≤a，b≤2*N)，表示一条连接 a，b 的弦 Output输出文件中近包含一个整数，表示相交弦的对 Sample Input3 2 5 2 6 3 Sample Output1 题解两条弦相交只需要保证其中一条的一个点在另一条的两个端点之间 然后树状数组or线段树维护一下前n个数有多少个左or右端点就好 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;const int N=1e6;ll tr[N&lt;&lt;1],n;struct node&#123; int l,r;&#125;e[N];int cmp(node x,node y)&#123;return x.l&lt;y.l;&#125;void update(int x,int k)&#123;for(register int i=x;i&lt;=n&lt;&lt;1;i+=lowbit(i))tr[i]+=k;&#125;ll ask(int x)&#123;ll ans=0; for(register int i=x;i;i-=lowbit(i))ans+=tr[i];return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; rep(i,1,n)&#123; cin&gt;&gt;e[i].l&gt;&gt;e[i].r; if(e[i].l&gt;e[i].r)swap(e[i].l,e[i].r); &#125; sort(e+1,e+n+1,cmp); rep(i,1,n)&#123; ans+=ask(e[i].r-1)-ask(e[i].l); update(e[i].r,1); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468]]></title>
    <url>%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[链接:poj3468 DescriptionYou have N integers, A1, A2, ... , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, ... , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. &quot;C a b c&quot; means adding c to each of Aa, Aa+1, ... , Ab. -10000 ≤ c ≤ 10000. &quot;Q a b&quot; means querying the sum of Aa, Aa+1, ... , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15 #题解 区间修改区间查询 维护个懒标记就好，具体看代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;ll tr[N&lt;&lt;2],a[N],add[N];int n,m;void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1]; &#125;&#125;void pushdown(int o,int l,int r)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; //懒标记下放 add[o&lt;&lt;1|1]+=add[o]; int mid=l+r&gt;&gt;1; tr[o&lt;&lt;1]+=add[o]*(mid-l+1); tr[o&lt;&lt;1|1]+=add[o]*(r-mid); add[o]=0; &#125;&#125;void update(int o,int l,int r,int L,int R,ll k)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; add[o]+=k; tr[o]+=k*(r-l+1); return ; //做个标记，不下放 &#125; pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(o&lt;&lt;1,l,mid,L,R,k); if(R&gt;mid)update(o&lt;&lt;1|1,mid+1,r,L,R,k); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=ask(o&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1)ans+=ask(o&lt;&lt;1|1,mid+1,r,L,R); return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; char p; ll x,y; cin&gt;&gt;p&gt;&gt;x&gt;&gt;y; if(p=='C')&#123; ll k; cin&gt;&gt;k; update(1,1,n,x,y,k); &#125; else cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2299]]></title>
    <url>%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[链接:poj2299 DescriptionIn this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence 9 1 0 5 4 , Ultra-QuickSort produces the output 0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. InputThe input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 -- the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. OutputFor every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. Sample Input5 9 1 0 5 4 3 1 2 3 0 Sample Output6 0 题解求逆序对数目 开一个大小为这些数的最大值的树状数组，并全部置0。从头到尾读入这些数，每读入一个数就更新树状数组，查看它前面比它小的已出现过的有多少个数 sum，然后用当前位置减去该sum，就可以得到当前数导致的逆序对数了。把所有的加起来就是总的逆序对数。 然而问题来了，数据最大999999999，显然开不下 解决方法是离散化一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e6+100;struct node&#123; int val,pos;&#125;b[N];int a[N],tree[N],n;ll ans;bool cmp(node x,node y)&#123; return x.val&lt;y.val;&#125;void add(int x,int k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tree[i]+=k;&#125;int getsum(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=lowbit(i))ans+=tree[i]; return ans;&#125;void readin()&#123; rep(i,1,n)&#123; cin&gt;&gt;b[i].val; b[i].pos=i; &#125; memset(a,0,sizeof(a)); memset(tree,0,sizeof(tree)); sort(b+1,b+n+1,cmp); rep(i,1,n)&#123; add(b[i].pos,1); //离散化 ans+=i-getsum(b[i].pos); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; if(n==0)break; ans=0; readin(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1754]]></title>
    <url>%2Fhdu1754%2F</url>
    <content type="text"><![CDATA[链接:hdu1754 Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取&apos;Q&apos;或&apos;U&apos;) ，和两个正整数A，B。 当C为&apos;Q&apos;的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为&apos;U&apos;的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output5 6 5 9 题解单点查询区间修改 线段树模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll tr[N&lt;&lt;2];int n,m,a[N];void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;void update(int o,int l,int r,int pos,int k)&#123; if(l==r)tr[o]=k; else &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)add(o&lt;&lt;1,l,mid,pos,k); else add(o&lt;&lt;1|1,mid+1,r,pos,k); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&gt;r||R&lt;l)return -1; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; int mid=l+r&gt;&gt;1; int p1=ask(o&lt;&lt;1,l,mid,L,R),p2=ask(o&lt;&lt;1|1,mid+1,r,L,R); return max(p1,p2);&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; int x,y; char c; cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c=='Q')cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; else update(1,1,n,x,y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
