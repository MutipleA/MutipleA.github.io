<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[行车路线]]></title>
    <url>%2Fccf%E8%AE%A4%E8%AF%812017-12-4%E8%A1%8C%E8%BD%A6%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[链接:行车路线 Description小明和小芳出去乡村玩，小明负责开车，小芳来导航。 小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快 速增加，连续走s公里小明会增加s2的疲劳度。 例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路 口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。 现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。 Input输入的第一行包含两个整数n, m，分别表示路口的数量和道路的数量。路口由1至n编号，小明需要开车从1号路口到n号路口。 接下来m行描述道路，每行包含四个整数t, a, b, c，表示一条类型为t，连接a与b两个路口，长度为c公里的双向道路。其中t为0表示大 道，t为1表示小道。保证1号路口和n号路口是连通的。 Output输出一个整数，表示最优路线下小明的疲劳度。 Sample Input6 7 1 1 2 3 1 2 3 2 0 1 3 30 0 3 4 20 0 4 5 30 1 3 5 6 1 5 6 1 Sample Output76 题解最短路，小路和大路分开来计算，注意中间结果可能爆int，并且可能给出重复的路，需要取最优值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+10;const ll inf=1e18+7;ll dis[N],dis0[N],n,m,in[N],g[N][N],g0[N][N];queue&lt;int&gt; q;void spfa(int s,int t)&#123; q.push(s); dis[s]=dis0[s]=0; in[s]=1; rep(i,1,n)if(i!=s)dis[i]=dis0[i]=inf; while(!q.empty())&#123; int k=q.front(); q.pop(); in[k]=0; rep(i,1,n)&#123; ll tp=g[k][i]; if(dis[i]&gt;dis[k]+tp)&#123; //前一次走的大路 dis[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(dis[i]&gt;dis0[k]+tp)&#123; //前一次走的小路 dis[i]=dis0[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; if(g0[k][i]!=inf)&#123; //现在走小路 tp=g0[k][i]*g0[k][i]; if(dis0[i]&gt;dis[k]+tp)&#123; dis0[i]=dis[k]+tp; if(!in[i])&#123; q.push(i); in[i]=1; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)rep(j,i,n)g[i][j]=g[j][i]=g0[i][j]=g0[j][i]=inf; rep(i,1,m)&#123; int a,b,c,d; scanf("%d%d%d%d",&amp;d,&amp;a,&amp;b,&amp;c); if(d==0)g[a][b]=g[b][a]=min(g[a][b],(ll)c); else g0[a][b]=g0[b][a]=min(g0[a][b],(ll)c); &#125; rep(k,1,n)rep(i,1,n)rep(j,i+1,n)g0[i][j]=min(g0[i][k]+g0[k][j],g0[i][j]); //floyd先求出两点间最小的小路 spfa(1,n); printf("%lld\n",min(dis[n],dis0[n])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>spfa</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青出于蓝胜于蓝]]></title>
    <url>%2F%E9%9D%92%E5%87%BA%E4%BA%8E%E8%93%9D%E8%83%9C%E4%BA%8E%E8%93%9D%2F</url>
    <content type="text"><![CDATA[链接:青出于蓝胜于蓝 Description武当派一共有 n 人，门派内 n 人按照武功高低进行排名，武功最高的人排名第 1，次高的人排名第 2，...武功最低的人排名第 n。现 在我们用武功的排名来给每个人标号，除了祖师爷，每个人都有一个师父，每个人可能有多个徒弟。 我们知道，武当派人才辈出，连祖师爷的武功都只能排行到 p。也就是说徒弟的武功是可能超过师父的，所谓的青出于蓝胜于蓝。 请你帮忙计算每个人的所有子弟（包括徒弟的徒弟，徒弟的徒弟的徒弟....）中，有多少人的武功超过了他自己。 Input输入第一行两个整数 n,p(1≤n≤100000,1≤p≤n)。 接下来 n−1 行，每行输入两个整数u,v(1≤u,v≤n)，表示 u 和 v 之间存在师徒关系。 Output输出一行 n 个整数，第 i 个整数表示武功排行为 i 的人的子弟有多少人超过了他。行末不要输出多余的空格。 Sample Input10 5 5 3 5 8 3 4 3 1 2 1 6 7 8 7 9 8 8 10 Sample Output0 0 2 0 4 0 1 2 0 0 题解树状数组维护dfs的时间戳，每访问一个点，in数组标记他，标记完所有子树的节点后，out数组取消标记 然后这个点的答案就是out[u]到in[u]区间内的和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=100070;int f[N],tr[N&lt;&lt;2],p,n,cnt,in[N],out[N ];vector&lt;int&gt;e[N];void add(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tr[i]+=y;&#125;int ask(int x)&#123; int tp=0; for(int i=x;i;i-=lowbit(i))tp+=tr[i]; return tp;&#125;void dfs(int u,int fa)&#123; in[u]=++cnt; int len=e[u].size(); rep(i,0,len-1)if(e[u][i]!=fa)dfs(e[u][i],u); out[u]=cnt;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;p; rep(i,2,n)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; e[x].push_back(y); e[y].push_back(x); &#125; dfs(p,-1); rep(i,1,n)&#123; cout&lt;&lt;ask(out[i])-ask(in[i]); if(i!=n)cout&lt;&lt;' '; add(in[i],1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数列求值]]></title>
    <url>%2F%E6%95%B0%E5%88%97%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[链接:数列求值 Description对于一个含有 n+2个元素的数列A0, A1, ... , An，满足这样的递归公式: Ai = (Ai-1 + Ai+1) /2 - Ci 1≤i≤n 现在我们知道A0, An+1和C1, C2, ... , Cn 现在请你帮忙计算A1的值。 Input第一行输入一个整数n(1≤n≤1000)。 第二行输入两个数A0, An+1，接着是 n个数据分别是C1, C2, ... , Cn。所有的数据均是两位小数的浮点数。 Output输出A1的值，结果保留两位小数。 Sample Input1 50.50 25.50 10.15 2 -756.89 52.52 172.22 67.17 Sample Output27.85 -761.49 题解根据公式可以推导出 A(2)==2*A(1)-A(0)+2*C(1) 先不看后面的C A(3)==2*A(2)-A(1)==3*A(1)-2*A(0) . . . A(n+1)==(n+1)*A(1)-(n)*A(0) 由于我们已知A(n+1) 看起来好像只需要这个公式就可以求出A(1) 然而还有我们忽略的C 由于未知A(1) 先将A(1)看成0 然后根据这个式子地推出A(n+1)暂时命名为tp,跟正确的A(n+1)相差的只有(n+1)*A(1) 剩下的就不用说了吧。。。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e3+11;int n;double tp,f[N],c;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;f[0]&gt;&gt;tp; rep(i,2,n+1)&#123; cin&gt;&gt;c; f[i]=2*f[i-1]-f[i-2]+2*c; &#125; printf("%.2lf\n",(tp-f[n+1])/(n+1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天上的星星]]></title>
    <url>%2F%E5%A4%A9%E4%B8%8A%E7%9A%84%E6%98%9F%E6%98%9F%2F</url>
    <content type="text"><![CDATA[链接:天上的星星 Description在一个星光摧残的夜晚，蒜头君一颗一颗的数这天上的星星。 蒜头君给在天上巧妙的画了一个直角坐标系，让所有的星星都分布在第一象。天上有 n 颗星星，他能知道每一颗星星的坐标和亮度。 现在，蒜头君问自己 q 次，每次他问自己每个矩形区域的星星的亮度和是多少（包含边界上的星星）。 Input 第一行输入一个整数n(1≤n≤50000)，表示星星的数量。 接下来n行，每行输入三个整数x,y,w(0≤x,y,w≤2000)，表示在坐标(x,y)有一颗亮度为w的星星。注意一个点可能有多个星星。 接下来一行输入一个整数q(1≤q≤50000)，表示查询的次数。 接下来q行，每行输入四个整数x1,y1,x2,y2，其中(x1,y1)表示查询的矩形的左下角的坐标，(x2,y2)表示查询的矩形的右上角的坐标，0≤x1≤x2≤2000，0≤y1≤y2≤2000。 Output对于每一次查询，输出一行一个整数，表示查询的矩形区域内的星星的亮度总和。 Sample Input5 5 0 6 7 9 7 8 6 13 9 7 1 3 0 19 4 0 8 7 9 0 0 7 10 2 7 10 9 5 4 7 5 Sample Output7 32 8 0 题解容斥原理加前缀和，水题，傻逼地写了个n颗线段树维护。。。 答案是dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1] 计算dp的时候，维护每行的前缀和，然后dp[i][j]=dp[i-1][j]+tp[i][j]; 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=3000;int dp[N][N],tp[N][N],g[N][N],q,n;int main()&#123; scanf("%d",&amp;n); rep(i,1,n)&#123; int x,y,w; scanf("%d%d%d",&amp;x,&amp;y,&amp;w); g[x+1][y+1]+=w; //注意这里是+= 有可能给出重复的点 &#125; rep(i,1,2001)rep(j,1,2001)&#123; tp[i][j]=tp[i][j-1]+g[i][j]; //第i行1-j列的和 dp[i][j]=dp[i-1][j]+tp[i][j]; &#125; scanf("%d",&amp;q); while(q--)&#123; int x1,y1,x2,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); x1++;y1++;x2++;y2++; printf("%d\n",dp[x2][y2]-dp[x2][y1-1]-dp[x1-1][y2]+dp[x1-1][y1-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>容斥原理</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2253]]></title>
    <url>%2Fpoj2253%2F</url>
    <content type="text"><![CDATA[链接:poj2253 DescriptionFreddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists&apos; sunscreen, he wants to avoid swimming and instead reach her by jumping. Unfortunately Fiona&apos;s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps. To execute a given sequence of jumps, a frog&apos;s jump range obviously must be at least as long as the longest jump occuring in the sequence. The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. You are given the coordinates of Freddy&apos;s stone, Fiona&apos;s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy&apos;s and Fiona&apos;s stone. InputThe input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy&apos;s stone, stone #2 is Fiona&apos;s stone, the other n-2 stones are unoccupied. There&apos;s a blank line following each test case. Input is terminated by a value of zero (0) for n. OutputFor each test case, print a line saying &quot;Scenario #x&quot; and a line saying &quot;Frog Distance = y&quot; where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. Sample Input2 0 0 3 4 3 17 4 19 4 18 5 0 Sample OutputScenario #1 Frog Distance = 5.000 Scenario #2 Frog Distance = 1.414 题解最短路变形，松弛及松弛条件改为max(dis[k],g[k][i])&lt;dis[i], 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;typedef pair&lt;double,int&gt; l;const int N=507;double g[N][N],dis[N];int vis[N],x[N],y[N],n,cnt;priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow((double)x[a]-x[b],2)+pow((double)y[a]-y[b],2));&#125;double dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(vis,0,sizeof(vis)); rep(i,1,n)dis[i]=0x3f3f3f3f; q.push(l(dis[s]=0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); vis[k]=1; rep(i,1,n)if(max(dis[k],g[k][i])&lt;dis[i])&#123; dis[i]=max(dis[k],g[k][i]); if(!vis[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t];&#125;int main()&#123; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,i-1)g[i][j]=g[j][i]=len(i,j); printf("Scenario #%d\nFrog Distance = %.3lf\n\n",++cnt,dijkstra(1,2)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1491]]></title>
    <url>%2Flg1491%2F</url>
    <content type="text"><![CDATA[链接:lg1491 Description每次有大的活动，大家都要在一起“聚一聚”，不管是去好乐迪，还是避风塘，或者汤姆熊，大家都要玩的痛快。还记得心语和花儿在跳舞 机上的激情与释放，还记得草草的投篮技艺是如此的高超，还记得狗狗的枪法永远是&apos;S&apos;……还有不能忘了，胖子的歌声永远是让我们惊叫 的！！ 今天是野猫的生日，所以想到这些也正常，只是因为是上学日，没法一起去玩了。但回忆一下那时的甜蜜总是一种幸福嘛。。。 但是每次集合的时候都会出现问题！野猫是公认的“路盲”，野猫自己心里也很清楚，每次都提前出门，但还是经常迟到，这点让大家很是 无奈。后来，野猫在每次出门前，都会向花儿咨询一下路径，根据已知的路径中，总算能按时到了。 现在提出这样的一个问题：给出n个点的坐标，其中第一个为野猫的出发位置，最后一个为大家的集合位置，并给出哪些位置点是相连 的。野猫从出发点到达集合点，总会挑一条最近的路走，如果野猫没找到最近的路，他就会走第二近的路。请帮野猫求一下这条第二最短 路径长度。 Input第一行是两个整数n(1&lt;=n&lt;=200)和m，表示一共有n个点和m条路，以下n行每行两个数xi，yi，(-500&lt;=xi,yi&lt;=500),代表第i个点的坐 标，再往下的m行每行两个整数pj，qj,(1&lt;=pj,qj&lt;=n)，表示两个点相通。 Output只有一行包含一个数，为第二最短路线的距离（保留两位小数），如果存在多条第一短路径，则答案就是第一最短路径的长度；如果不存 在第二最短路径，输出－1。 Sample Input3 3 0 0 1 1 0 2 1 2 1 3 2 3 Sample Output2.83 题解求次短路，只需要把最长路求出来记录路劲，然后所有第二短路求最小值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;typedef pair&lt;double,int&gt; l;const int N=507;int pre[N],head[N],in[N],n,m,x[N],y[N],cnt;double dis[N],g[N][N],tp[N];priority_queue&lt;l,vector&lt;l&gt;,greater&lt;l&gt; &gt;q;double len(int a,int b)&#123; return sqrt(pow(x[a]-x[b],2)+pow(y[a]-y[b],2));&#125;double dijkstra(int s,int t,int op)&#123; while(!q.empty())q.pop(); rep(i,1,n)dis[i]=0x3f3f3f3f; memset(in,0,sizeof(in)); q.push(l(0,s)); dis[s]=0; while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; rep(i,1,n)&#123; if(dis[k]+g[k][i]&gt;=dis[i])continue; dis[i]=dis[k]+g[k][i]; if(op)pre[i]=k; if(!in[i])q.push(l(dis[i],i)); &#125; &#125; return dis[t]==0x3f3f3f3f?-1:dis[t];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,n)scanf("%d%d",&amp;x[i],&amp;y[i]); rep(i,1,n)rep(j,1,n)if(i!=j)g[i][j]=0x3f3f3f3f; rep(i,1,m)&#123; int a,b,c; scanf("%d%d",&amp;a,&amp;b); g[a][b]=g[b][a]=len(a,b); &#125; if(dijkstra(1,n,1)==-1)printf("-1\n"); else &#123; for(int i=n;i!=1;i=pre[i])&#123; double k=g[i][pre[i]]; g[i][pre[i]]=g[pre[i]][i]=0x3f3f3f3f; tp[cnt++]=dijkstra(1,n,0); g[i][pre[i]]=g[pre[i]][i]=k; &#125; double ans=0x3f3f3f3f; rep(i,0,cnt-1)if(tp[i]!=-1)ans=min(ans,tp[i]); printf("%.2lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1119]]></title>
    <url>%2Flg1119%2F</url>
    <content type="text"><![CDATA[链接:lg1119 DescriptionB地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 给出B地区的村庄数N，村庄编号从0到N-1，和所有M条公路的长度，公路是双向的。并给出第i个村庄重建完成的时间t[i]，你可以认为 是同时开始重建并在第t[i]天重建完成，并且在当天即可通车。若t[i]为0则说明地震未对此地区造成损坏，一开始就可以通车。之后有 Q个询问(x, y, t)，对于每个询问你要回答在第t天，从村庄x到村庄y的最短路径长度为多少。如果无法找到从x村庄到y村庄的路径，经 过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未重建完成 ，则需要返回-1。 Input输入文件rebuild.in的第一行包含两个正整数N，M，表示了村庄的数目与公路的数量。 第二行包含N个非负整数t[0], t[1], …, t[N – 1]，表示了每个村庄重建完成的时间，数据保证了t[0] ≤ t[1] ≤ … ≤ t[N – 1]。 接下来M行，每行3个非负整数i, j, w，w为不超过10000的正整数，表示了有一条连接村庄i与村庄j的道路，长度为w，保证i≠j，且对 于任意一对村庄只会存在一条道路。 接下来一行也就是M+3行包含一个正整数Q，表示Q个询问。 接下来Q行，每行3个非负整数x, y, t，询问在第t天，从村庄x到村庄y的最短路径长度为多少，数据保证了t是不下降的。 Output输出文件rebuild.out包含Q行，对每一个询问(x, y, t)输出对应的答案，即在第t天，从村庄x到村庄y的最短路径长度为多少。如果在 第t天无法找到从x村庄到y村庄的路径，经过若干个已重建完成的村庄，或者村庄x或村庄y在第t天仍未修复完成，则输出-1。 Sample Input4 5 1 2 3 4 0 2 1 2 3 1 3 1 2 2 1 4 0 3 5 4 2 0 2 0 1 2 0 1 3 0 1 4 Sample Output-1 -1 5 4 题解n&lt;=200 floyd就可以了，每次提问，枚举中间的k 如果k这个点重建完成或者没访问过就用它松弛其他路径 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=307;int t[N],dis[N][N],vis[N];int n,m,q;int main()&#123; ios::sync_with_stdio(false); memset(dis,0x3f,sizeof(dis)); cin&gt;&gt;n&gt;&gt;m; rep(i,0,n-1)cin&gt;&gt;t[i]; rep(i,1,m)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dis[a][b]=dis[b][a]=c; &#125; cin&gt;&gt;q; while(q--)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; rep(k,0,n-1)&#123; if(t[k]&gt;c||vis[k])continue; rep(i,0,n-1)if(i!=k)rep(j,0,n-1)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); vis[k]=1; &#125; if(dis[a][b]==0x3f3f3f3f||!vis[a]||!vis[b])cout&lt;&lt;"-1"&lt;&lt;endl; else cout&lt;&lt;dis[a][b]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
        <category>floyd</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spfa]]></title>
    <url>%2Fspfa%2F</url>
    <content type="text"><![CDATA[SPFA: Shortest Path Faster Algorithm看到名字不禁为之一颤，SPFA算法是西南交通大学段凡丁于1994年发表的。 SPFA 也是竞赛中最常见的算法之一，不仅仅用来解决带负权的单源最短路 而且是求解差分约束问题的专用算法，也常用它和最大流合作解决最小费问题 SPFA 算法的最坏复杂度为 O(2*E)。。 SPFA 和dijkstra 格式很接近，只是加了个队列或栈就变得无比神奇了。 这里用邻接表形式写下spfa 的模板 后面再介绍它的其它功能，这里只知道它处理最短路很快即可 优点可以处理负权，判负环，快 代码12345678910111213141516171819202122queue&lt;int&gt; q;int spfa(int s,int t)&#123; memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(vis)); //memset(c,0,sizeof(c)); q.push(s); in[s]=1; //c[s]=1; while(!q.empty())&#123; int k=q.front();q.pop(); in[k]=0; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i]&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])&#123; q.push(e[i].t); in[e[i].t]++; c[e[i].t]++; //if(c[e[i].t]&gt;n)return ok=0 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra优化]]></title>
    <url>%2Fdijkstra%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化dijkstra 注意到贪心的过程是每次选取最小的dis值出来，这里是O(n)的，我们可以用优先队列把他优化到O(logn) 12345678910111213141516171819typedef pair&lt;int,int&gt; l;priority_queue&lt;s,vector&lt;s&gt;,greater&lt;s&gt; &gt;q;int dijkstra(int s,int t)&#123; while(!q.empty())q.pop(); memset(d,0x3f,sizeof(d)); memset(in,0,sizeof(0)); d[s]=0;in[s]=1; q.push(l(0,s)); while(!q.empty())&#123; int k=q.top().second; q.pop(); in[k]=1; for(int i=head[k];i!=-1;i=e[i].nxt)if(d[k]+e[i].w&lt;d[i])&#123; d[i]=e[i].w+d[k]; if(!in[e[i].t])q.push(l(d[i],e[i].t)); &#125; &#125; return d[t]!=inf?d[t]:-1;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dijkstra算法详解]]></title>
    <url>%2Fdijkstra%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最短路从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径 解决算法： floyd dijkstra spfa dijktsra优化 spfa优化 dijkstra算法介绍 算法思路: 利用贪心的思想，维护一个dis数组，值为源点到各个顶点的最短距离，以及一个vis数组，表示该点已经算出最短路的点的集合 每次找到dis值最小的顶点（这个dis值就是改点到源点的最短距离），标记它，然后用它来松弛可以松弛的点， 时间复杂度： 很显然是O(n2)的 *缺点：无法处理负权代码int dijkstra(int s,int t){ rep(i,1,n+1){ d[i]=g[s][i]; vis[i]=0; } vis[s]=1; rep(i,2,n+1){ int mx=inf,k=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;d[j]&lt;mx){ mx=d[j]; k=j; } vis[k]=1; rep(j,1,n+1)if(!vis[j]&amp;&amp;mx+g[k][j]&lt;d[j]){ d[j]=mx+g[k][j]; } } return d[t]!=inf?d[t]:-1; }]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3252]]></title>
    <url>%2Fpoj3252%2F</url>
    <content type="text"><![CDATA[链接:poj3252 DescriptionThe cows, as you know, have no fingers or thumbs and thus are unable to play Scissors, Paper, Stone&apos; (also known as &apos;Rock, Paper, Scissors&apos;, &apos;Ro, Sham, Bo&apos;, and a host of other names) in order to make arbitrary decisions such as who gets to be milked first. They can&apos;t even flip a coin because it&apos;s so hard to toss using hooves. They have thus resorted to &quot;round number&quot; matching. The first cow picks an integer less than two billion. The second cow does the same. If the numbers are both &quot;round numbers&quot;, the first cow wins, otherwise the second cow wins. A positive integer N is said to be a &quot;round number&quot; if the binary representation of N has as many or more zeroes than it has ones. For example, the integer 9, when written in binary form, is 1001. 1001 has two zeroes and two ones; thus, 9 is a round number. The integer 26 is 11010 in binary; since it has two zeroes and three ones, it is not a round number. Obviously, it takes cows a while to convert numbers to binary, so the winner takes a while to determine. Bessie wants to cheat and thinks she can do that if she knows how many &quot;round numbers&quot; are in a given range. Help her by writing a program that tells how many round numbers appear in the inclusive range given by the input (1 ≤ Start &lt; Finish ≤ 2,000,000,000). InputLine 1: Two space-separated integers, respectively Start and Finish. OutputLine 1: A single integer that is the count of round numbers in the inclusive range Start..Finish Sample Input2 12 Sample Output6 题解模板题 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)const int N=66;int a[N],dp[N][N];//当前第i位，零的个数为j共有多少种情况 int dfs(int pos,int sta,int limit,int lead)&#123; if(pos==-1)return sta&gt;=32;; if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:1; int tmp=0; rep(i,0,up+1)&#123; if(i==0&amp;&amp;lead)tmp+=dfs(pos-1,sta,limit&amp;&amp;i==a[pos],lead); else tmp+=dfs(pos-1,sta+(i==0?1:-1),i==a[pos]&amp;&amp;limit,lead&amp;&amp;i==0); &#125; if(!limit&amp;&amp;!lead)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x&amp;1; x&gt;&gt;=1; &#125; return dfs(cnt-1,32,1,1);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp)); scanf("%d%d",&amp;l,&amp;r); printf("%d",solve(r)-solve(l-1)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4734]]></title>
    <url>%2Fhdu4734%2F</url>
    <content type="text"><![CDATA[链接:hdu4734 DescriptionFor a decimal number x with n digits (AnAn-1An-2 ... A2A1), we define its weight as F(x) = An * 2n-1 + An-1 * 2n-2 + ... + A2 * 2 + A1 * 1. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). InputThe first line has a number T (T &lt;= 10000) , indicating the number of test cases. For each test case, there are two numbers A and B (0 &lt;= A,B &lt; 109) OutputFor every case,you should output &quot;Case #t: &quot; at first, without quotes. The t is the case number starting from 1. Then output the answer. Sample Input3 0 100 1 10 5 100 Sample OutputCase #1: 1 Case #2: 2 Case #3: 13 题解模板题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)using namespace std;const int N=4600;int a[10],dp[10][N];int n;int dfs(int pos,int limit,int sum)&#123; if(sum&lt;0)return 0; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sum]!=-1)return dp[pos][sum]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(pos-1,limit&amp;&amp;i==a[pos],sum-i*(1&lt;&lt;pos)); &#125; if(!limit)dp[pos][sum]=tmp; return tmp;&#125;int solve(int x,int y)&#123; int cnt=0,len=0,ans=0; while(y)&#123; ans+=y%10*(1&lt;&lt;len); len++; y/=10; &#125; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,1,ans);&#125;int main()&#123; scanf("%d",&amp;n); memset(dp,-1,sizeof(dp)); rep(i,0,n)&#123; int A,B; scanf("%d%d",&amp;A,&amp;B); printf("Case #%d: %d\n",i+1,solve(B,A)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3709]]></title>
    <url>%2Fhdu3709%2F</url>
    <content type="text"><![CDATA[链接:hdu3709 DescriptionA balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 4*2 + 1*1 = 9 and 9*1 = 9, for left part and right part, respectively. It&apos;s your job to calculate the number of balanced numbers in a given range [x, y]. InputThe input contains multiple test cases. The first line is the total number of cases T (0 &lt; T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018). OutputFor each case, print the number of balanced numbers in the range [x, y] in a line. Sample Input2 0 9 7604 24324 Sample Output10 897 题解模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=22;ll dp[N][N][2000];//第i位，枢轴为j的时候和为k时共有多少种情况满足符合要求 int a[N];ll dfs(int len,int pos,int limit,int sta)&#123; if(len==-1)return sta?0:1; if(sta&lt;0)return 0; if(!limit&amp;&amp;dp[len][pos][sta]!=-1)return dp[len][pos][sta]; int up=limit?a[len]:9; ll tmp=0; rep(i,0,up+1)&#123; tmp+=dfs(len-1,pos,limit&amp;&amp;i==a[len],sta+i*(len-pos)); &#125; if(!limit)dp[len][pos][sta]=tmp; return tmp;&#125;ll solve(ll x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; ll ans=0; rep(i,0,cnt)&#123; ans+=dfs(cnt-1,i,1,0); &#125; return ans-cnt+1;&#125;int main()&#123; ll l,r; int T; scanf("%d",&amp;T); memset(dp,-1,sizeof(dp)); while(T--)&#123; scanf("%lld%lld",&amp;l,&amp;r); printf("%lld\n",solve(r)-solve(l-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2089]]></title>
    <url>%2Fhdu2089%2F</url>
    <content type="text"><![CDATA[链接:hdu2089 Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别 的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input1 100 0 0 Sample Output80 题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define rep(i,l,n)for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=55;int a[N];ll dp[N][2];//当前第i位，前置有或没有6共有多少种情况 int dfs(int pos,int pre,int sta,int limit)&#123; if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][sta]!=-1)return dp[pos][sta]; int up=limit?a[pos]:9; int tmp=0; rep(i,0,up+1)&#123; if(pre==6&amp;&amp;i==2)continue; if(i==4)continue; tmp+=dfs(pos-1,i,i==6,limit&amp;&amp;a[pos]==i); &#125; if(!limit)dp[pos][sta]=tmp; return tmp;&#125;int solve(int x)&#123; int cnt=0; while(x)&#123; a[cnt++]=x%10; x/=10; &#125; return dfs(cnt-1,-1,0,true);&#125;int main()&#123; int l,r; memset(dp,-1,sizeof(dp));//不管l与r怎么给 已经计算出来的状态是不会改变的 while(~scanf("%d%d",&amp;l,&amp;r))&#123; if(l==0&amp;&amp;r==0)break; printf("%d\n",solve(r)-solve(l-1)); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1352]]></title>
    <url>%2Flg1352%2F</url>
    <content type="text"><![CDATA[链接:lg1352 Description InputOutputSample InputSample Output题解模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(regsiter int i=x;i&gt;=y;--i)using namespace std;const int N=1e4;int fa[N],r[N],dp[N][2],vis[N];int n,root=1;template &lt;typename T&gt;inline void read(T&amp;x)&#123; x=0;char c;int sign=1; do&#123; c=getchar(); if(c=='-')sign=-1;&#125;while(c&lt;'0'||c&gt;'9'); do&#123; x=x*10+c-'0'; c=getchar();&#125;while(c&gt;='0'&amp;&amp;c&lt;='9'); x*=sign;&#125;void tdp(int node)&#123; vis[node]=1; rep(i,1,n)if(!vis[i]&amp;&amp;fa[i]==node)&#123; tdp(i); dp[node][1]+=dp[i][0]; dp[node][0]+=max(dp[i][1],dp[i][0]); &#125;&#125;int main()&#123; read(n); rep(i,1,n)read(dp[i][1]); rep(i,1,n-1)&#123; int x,y; read(x);read(y); fa[x]=y; &#125; rep(i,1,n)if(!fa[i])&#123; root=i;break; &#125; tdp(root); printf("%d",max(dp[root][1],dp[root][0])); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5647]]></title>
    <url>%2Fhdu5647%2F</url>
    <content type="text"><![CDATA[链接:hdu5647 DescriptionDZY has an unrooted tree consisting of n nodes labeled from 1 to n. DZY likes connected sets on the tree. A connected set S is a set of nodes, such that every two nodes u,v in S can be connected by a path on the tree, and the path should only contain nodes from S. Obviously, a set consisting of a single node is also considered a connected set. The size of a connected set is defined by the number of nodes which it contains. DZY wants to know the sum of the sizes of all the connected sets. Can you help him count it? The answer may be large. Please output modulo 109+7. InputFirst line contains t denoting the number of testcases.t testcases follow. In each testcase, first line contains n. In lines 2∼n, ith line contains pi, meaning there is an edge between node i and node pi. (1≤pi≤i−1,2≤i≤n) (n≥1， sum of n in all testcases does not exceed 200000) OutputOutput one line for each testcase, modulo 109+7. Sample Input2 1 5 1 2 2 3 Sample Output1 42 题解ans[i]由两部分组成，这个节点做的贡献dp[u]*(sum[x]+1) 孩子做的贡献dp[x]*sum[u] 具体看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;const int mod=1e9+7;int T,n;ll dp[N],sum[N],head[N],cnt;ll ans;struct node&#123; int v,nxt;&#125;e[N];void readin()&#123; scanf("%d",&amp;n); rep(i,2,n)&#123; int x; scanf("%d",&amp;x); e[cnt].v=i; e[cnt].nxt=head[x]; head[x]=cnt++; &#125;&#125;void dfs(int u)&#123; sum[u]=1; dp[u]=1; for(int i=head[u];i!=-1;i=e[i].nxt)&#123; int x=e[i].v; dfs(x); dp[u]=(dp[u]*(sum[x]+1)%mod+dp[x]*sum[u]%mod)%mod;//新加的点做的贡献+这个孩子原来做的贡献 sum[u]=(sum[u]*(sum[x]+1))%mod; &#125; ans=(ans+dp[u])%mod;&#125;int main()&#123; //ios::sync_with_stdio(false); scanf("%d",&amp;T); while(T--)&#123; ans=0; cnt=0; memset(head,-1,sizeof(head)); readin(); dfs(1); //cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2196]]></title>
    <url>%2Fhdu2196%2F</url>
    <content type="text"><![CDATA[链接:hdu2196 DescriptionA school bought the first computer some time ago(so this computer&apos;s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. InputInput file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. OutputFor each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). Sample Input5 1 1 2 1 3 1 1 1 Sample Output3 2 3 4 4 题解对于任意一个节点，他能到达的最远的节点一定是他子树中的一个节点， 或者经过他父亲到达的一个节点。但是可能当前节点在根节点最远距离的路径上 父节点存的最大值可能正好是从该点过来的 1]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5627]]></title>
    <url>%2Fhdu5627%2F</url>
    <content type="text"><![CDATA[链接:hdu5627 DescriptionClarke is a patient with multiple personality disorder. One day he turned into a learner of graph theory. He learned some algorithms of minimum spanning tree. Then he had a good idea, he wanted to find the maximum spanning tree with bit operation AND. A spanning tree is composed by n−1 edges. Each two points of n points can reach each other. The size of a spanning tree is generated by bit operation AND with values of n−1 edges. Now he wants to figure out the maximum spanning tree. InputThe first line contains an integer T(1≤T≤5), the number of test cases. For each test case, the first line contains two integers n,m(2≤n≤300000,1≤m≤300000), denoting the number of points and the number of edge 、 respectively. Then mlines followed, each line contains three integers x,y,w(1≤x,y≤n,0≤w≤109), denoting an 、 edge between x,ywith value w. The number of test case with n,m&gt;100000 will not exceed 1. OutputFor each test case, print a line contained an integer represented the answer. If there is no any spanning tree, print 0. Sample Input1 4 5 1 2 5 1 3 3 1 4 2 2 3 1 3 4 7 Sample Output1 题解按位与最大生成树，从最高位贪心到最低位，看该位和其他已经获得的位能否构成生成树 能构成就加上这一位，不然就扔掉 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)using namespace std;const int N=1e6;int x[N],y[N],w[N],f[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x);y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;int main()&#123; int t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); rep(i,1,m)scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;w[i]); int ans=0; repd(i,20,0)&#123; ans+=(1&lt;&lt;i); rep(j,1,m)f[j]=j; int cnt=0; rep(j,1,m)if((w[j]&amp;ans)==ans&amp;&amp;un(x[j],y[j]))cnt++; //注意此处不是(w[j]&amp;(1&lt;&lt;i))==(1&lt;&lt;i) if(cnt!=n-1)ans-=(1&lt;&lt;i); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5651]]></title>
    <url>%2Fhdu5651%2F</url>
    <content type="text"><![CDATA[链接:hdu5651 DescriptionAs we all known, xiaoxin is a brilliant coder. He knew **palindromic** strings when he was only a six grade student at elementry school. This summer he was working at Tencent as an intern. One day his leader came to ask xiaoxin for help. His leader gave him a string and he wanted xiaoxin to generate palindromic strings for him. Once xiaoxin generates a different palindromic string, his leader will give him a watermelon candy. The problem is how many candies xiaoxin&apos;s leader needs to buy? InputThis problem has multi test cases. First line contains a single integer T(T≤20) which represents the number of test cases. For each test case, there is a single line containing a string S(1≤length(S)≤1,000). OutputFor each test case, print an integer which is the number of watermelon candies xiaoxin&apos;s leader needs to buy after mod 1,000,000,007. Sample Input3 aa aabb a Sample Output1 2 1 题解如果奇数大于1肯定无解，然后所有字母出现次数除2，按照不相异的元素的全排列公式进行计算，然后用乘法逆元做一下， 乘法逆元用拓展欧几里得做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e5;const ll p=1000000007;char str[N];int a[30],T,len,cnt,flag;int exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(b==0)&#123;x=1; y=0; d=a;&#125; else &#123;exgcd(b,a%b,d,x,y); ll t=x;x=y;y=t-a/b*x;&#125;&#125;ll inv(ll a,ll p)&#123; ll d,x,y; exgcd(a,p,d,x,y); return d==1?(x%p+p)%p:-1;&#125;void readin()&#123; cin&gt;&gt;str; len=strlen(str);cnt=flag=0; memset(a,0,sizeof(a)); rep(i,0,len-1)a[str[i]-'a']++; rep(i,0,29)&#123; if(a[i]&amp;1)flag++; if(a[i])&#123; a[i]&gt;&gt;=1; cnt+=a[i]; &#125; &#125;&#125;ll sum(ll X)&#123; ll tp=1; rep(i,2,X)tp=tp*i%p; return tp;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;T; while(T--)&#123; readin(); if(flag&gt;1)&#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; rep(i,0,26)if(a[i]!=0)&#123; a[i]=sum(a[i]); a[i]=inv(a[i],p); &#125; ll ans=sum(cnt); rep(i,0,26)if(a[i])ans=ans*a[i]%p; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>拓展欧几里得</category>
      </categories>
      <tags>
        <tag>拓展欧几里得</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg2044]]></title>
    <url>%2Flg2044%2F</url>
    <content type="text"><![CDATA[链接:lg2044 Description栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随 机数列，这种方法需要设置四个非负整数参数m,a,c,X[0],按照下面的公式生成出一系列随机数{Xn}： X[n+1]=(aX[n]+c) mod m 其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。 用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的C++和Pascal的产生随机数的库函数使用的也是这 种方法。 栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道X[n]是多少。由于栋栋需要的随机数是0,1,...,g-1之间的， 他需要将X[n]除以g取余得到他想要的数，即X[n] mod g，你只需要告诉栋栋他想要的数X[n] mod g是多少就可以了。 Input输入包含6个用空格分割的整数m,a,c,X[0],n和g，其中a,c,X[0]是非负整数，m,n,g是正整数。 Output输出一个数，即X[n] mod g Sample Input11 8 7 1 5 3 Sample Output2 题解矩阵快速幂模板 注意要用快速乘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;ll n,m,A,c,d,p; struct mat&#123; ll a[2][2];&#125;; mat T=&#123;1,1,0,1&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;m&gt;&gt;A&gt;&gt;c&gt;&gt;d&gt;&gt;n&gt;&gt;p;&#125;ll K(ll x,ll y)&#123; ll ans=0; x%=m;y%=m; while(y)&#123; if(y&amp;1)ans=(ans+x)%m; x=(x+x)%m; y&gt;&gt;=1; &#125; return ans;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; //cout&lt;&lt;"i="&lt;&lt;i&lt;&lt;"j="&lt;&lt;j&lt;&lt;' '&lt;&lt;x.a[i][k]*y.a[k][j]&lt;&lt;' '&lt;&lt;ans.a[i][j]&lt;&lt;endl; //cout&lt;&lt;K(x.a[i][k],y.a[k][j])&lt;&lt;endl; ans.a[i][j]=(ans.a[i][j]+K(x.a[i][k],y.a[k][j]))%m; &#125; return ans;&#125;void solve()&#123; readin(); T.a[0][0]=A; mat ans=&#123;0,d,0,c&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1]%p&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1962]]></title>
    <url>%2Flg1962%2F</url>
    <content type="text"><![CDATA[链接:lg1962 Description大家都知道，斐波那契数列是满足如下性质的一个数列： • f(1) = 1 • f(2) = 1 • f(n) = f(n-1) + f(n-2) (n ≥ 2 且 n 为整数) 请你求出 f(n) mod 1000000007 的值。 Input第 1 行：一个整数 n Output第 1 行： f(n) mod 1000000007 的值 Sample Input1: 52: 10 Sample Output1: 52: 55 题解F(n)=F(n-1)+F(n-2) 构造T：{1,1 和A(n-1){F(n-1) 1,0} F(n-2)} 乘起来就得到F(n)，然后这就是个等比数列 然后就可以用快速幂了(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int p=1000000007;struct mat&#123; ll a[2][2];&#125;;ll n;mat T=&#123;1,1,1,0&#125;;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n;&#125;mat mul(mat x,mat y)&#123; mat ans=&#123;0&#125;; rep(i,0,1)rep(j,0,1)rep(k,0,1)&#123; ans.a[i][j]=(ans.a[i][j]+x.a[i][k]*y.a[k][j])%p; &#125; return ans;&#125;void solve()&#123; n-=2; mat ans=&#123;0,1,0,1&#125;; while(n)&#123; if(n&amp;1)ans=mul(T,ans),n--; T=mul(T,T); n&gt;&gt;=1; &#125; cout&lt;&lt;ans.a[0][1];&#125;int main()&#123; readin(); if(n==1||n==2)cout&lt;&lt;1&lt;&lt;endl; else solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>矩阵乘法</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯国王的烦恼]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯国王的烦恼 DescriptionC国由n个小岛组成，为了方便小岛之间联络，C国在小岛间建立了m座大桥，每座大桥连接两座小岛。两个小岛间可能存在多座桥连接。然而，由于海水冲刷，有一些大桥面临着不能使用的危险。 如果两个小岛间的所有大桥都不能使用，则这两座小岛就不能直接到达了。然而，只要这两座小岛的居民能通过其他的桥或者其他的小岛 互相到达，他们就会安然无事。但是，如果前一天两个小岛之间还有方法可以到达，后一天却不能到达了，居民们就会一起抗议。 现在C国的国王已经知道了每座桥能使用的天数，超过这个天数就不能使用了。现在他想知道居民们会有多少天进行抗议。 Input输入的第一行包含两个整数n, m，分别表示小岛的个数和桥的数量。 接下来m行，每行三个整数a, b, t，分别表示该座桥连接a号和b号两个小岛，能使用t天。小岛的编号从1开始递增。 Output输出一个整数，表示居民们会抗议的天数。 Sample Input4 4 1 2 2 1 3 2 2 3 1 3 4 3 Sample Output2 题解一道很简单的并查集，拆了就不连通，相当于加上才连通 然后并查集维护一下就ok了，然后要注意的是时间相同的点的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;int f[N],n,m,ans;struct node&#123; int u,v,w;&#125;e[N];bool cmp(node x,node y)&#123; return x.w&gt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; sort(e+1,e+m+1,cmp); rep(i,1,n)f[i]=i;&#125;int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;int un(int x,int y)&#123; x=find(x); y=find(y); if(x!=y)&#123; f[x]=y; return 1; &#125; return 0;&#125;void solve()&#123; readin(); int pre=-1; rep(i,1,m)if(un(e[i].u,e[i].v)&amp;&amp;pre!=e[i].w)ans++,pre=e[i].w; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯城市建设]]></title>
    <url>%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[链接:蓝桥杯城市建设 Description栋栋居住在一个繁华的C市中，然而，这个城市的道路大都年久失修。市长准备重新修一些路以方便市民，于是找到了栋栋，希望栋栋能帮助他。 C市中有n个比较重要的地点，市长希望这些地点重点被考虑。现在可以修一些道路来连接其中的一些地点，每条道路可以连接其中的两个 地点。另外由于C市有一条河从中穿过，也可以在其中的一些地点建设码头，所有建了码头的地点可以通过河道连接。 栋栋拿到了允许建设的道路的信息，包括每条可以建设的道路的花费，以及哪些地点可以建设码头和建设码头的花费。 市长希望栋栋给出一个方案，使得任意两个地点能只通过新修的路或者河道互达，同时花费尽量小。 Input输入的第一行包含两个整数n, m，分别表示C市中重要地点的个数和可以建设的道路条数。所有地点从1到n依次编号。 接下来m行，每行三个整数a, b, c，表示可以建设一条从地点a到地点b的道路，花费为c。若c为正，表示建设是花钱的，如果c为负，则 表示建设了道路后还可以赚钱（比如建设收费道路）。 接下来一行，包含n个整数w_1, w_2, …, w_n。如果w_i为正数，则表示在地点i建设码头的花费，如果w_i为-1，则表示地点i无法建设 码头。 输入保证至少存在一个方法使得任意两个地点能只通过新修的路或者河道互达。 Output输出一行，包含一个整数，表示使得所有地点通过新修道路或者码头连接的最小花费。如果满足条件的情况下还能赚钱，那么你应该输出一个负数。 Sample Input5 5 1 2 4 1 3 -1 2 3 3 2 4 5 4 5 10 -1 10 10 1 1 Sample Output9 题解跑两遍最小生成树，一遍不带码头，一遍带 码头的处理：将所有码头和0点连起来形成通路 然后注意一点就是权值为负值的路一定要加，赚钱的(手动滑稽) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=123456;int f[N],n,m,cnt;ll ans1,ans2;struct node&#123; int u,v,w; inline void init(int x,int y,int z)&#123; u=x;v=y;w=z; &#125;&#125;e[N];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=y;&#125; bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;void readin()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m;cnt=m; rep(i,1,m)cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; rep(i,1,n)&#123; int x; cin&gt;&gt;x; e[i+m].init(0,i,x); if(e[i+m].w==-1)e[i+m].w=-0x3f3f3f3f; &#125; sort(e+1,e+n+m+1,cmp); rep(i,1,n)f[i]=i;&#125;void kruskal_first()&#123; readin(); rep(i,1,n+m)&#123; if(e[i].w==-0x3f3f3f3f)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans1+=e[i].w; &#125; &#125;&#125;void kruskal_second()&#123; rep(i,1,n)f[i]=i; rep(i,1,n+m)&#123; if(e[i].u==0)continue; int x=find(e[i].u); int y=find(e[i].v); if(x!=y||e[i].w&lt;0)&#123; un(x,y); ans2+=e[i].w; &#125; &#125;&#125;int main()&#123; kruskal_first(); kruskal_second(); int sum=0; rep(i,1,n)if(f[i]==i)sum++; if(sum==1)cout&lt;&lt;min(ans1,ans2); else cout&lt;&lt;ans1; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lg1195]]></title>
    <url>%2Flg1195%2F</url>
    <content type="text"><![CDATA[链接:lg1195 Description小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 给你云朵的个数N，再给你M个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成K个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 Input每组测试数据的 第一行有三个数N,M,K(1&lt;=N&lt;=1000,1&lt;=M&lt;=10000,1&lt;=K&lt;=10) 接下来M个数每行三个数X,Y,L，表示X云和Y云可以通过L的代价连在一起。(1&lt;=X,Y&lt;=N,0&lt;=L&lt;10000) 30%的数据N&lt;=100,M&lt;=1000 Output对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出K个棉花糖，请输出&apos;No Answer&apos;。 Sample Input3 1 2 1 2 1 Sample Output1 题解建一个包含n-k-1个节点的最小生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define rep(i,l,n) for(register int i=l;i&lt;n;++i)#define ll long longusing namespace std;const int N=1e5+10;struct node &#123; int u,v,w;&#125;e[N];int n,m,k,ans;int f[N];int cmp(const void *a,const void *b)&#123; return ((node*)a)-&gt;w-((node*)b)-&gt;w;&#125;int find(int x)&#123; return f[x]==x?f[x]:f[x]=find(f[x]);&#125;inline void un(int x,int y)&#123; x=find(x); y=find(y); f[x]=f[y];&#125;void Kruskal()&#123; qsort(e,m,sizeof(e[0]),cmp); rep(i,1,n+1)f[i]=i; int cnt=0; rep(i,0,m)&#123; int x=e[i].u,y=e[i].v; if(find(x)!=find(y))&#123; un(x,y); ans+=e[i].w; cnt++; &#125; if(cnt==k)break; &#125;&#125;int main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; ans=0; rep(i,0,m)scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); k=n-k; if(k&lt;=m)Kruskal(); if(ans)printf("%d\n",ans); else printf("No Answer\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
        <category>生成树</category>
      </categories>
      <tags>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu5586]]></title>
    <url>%2Fhdu5586%2F</url>
    <content type="text"><![CDATA[链接:hdu5586 Problem DescriptionThere is a number sequence {A}_{1},{A}_{2}....{A}_{n},you can select a interval [l,r] or not,all the numbers {A}_{i}(l \leq i \leq r) will become f({A}_{i}).f(x)=(1890x+143) mod 10007.After that,the sum of n numbers should be as much as possible.What is the maximum sum? InputThere are multiple test cases. First line of each case contains a single integer n.(1\leq n\leq {10}^{5}) Next line contains n integers {A}_{1},{A}_{2}....{A}_{n}.(0\leq {A}_{i}\leq {10}^{4}) It&apos;s guaranteed that \sum n\leq {10}^{6}. OutputFor each test case,output the answer in a line. Sample Input2 10000 9999 5 1 9999 1 9999 1 Sample Output19999 22033 题解最大子段和 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e7;const int mod=10007;ll a[N],b[N],c[N],ans;int n,m;int f(ll x)&#123; return (x%mod*1890+143)%mod;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; ans=0; rep(i,1,n)&#123; scanf("%lld",&amp;a[i]); b[i]=f(a[i])-a[i]; ans+=a[i]; &#125; int tp=0,k=0; rep(i,1,n)&#123; if(tp+b[i]&gt;0)tp+=b[i]; else tp=0; if(tp&gt;k)k=tp; &#125; printf("%lld\n",ans+k); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相交弦统计]]></title>
    <url>%2F%E7%9B%B8%E4%BA%A4%E5%BC%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[DescriptionKimi 最近得到了一个玩具，玩具由环和弦两个部分组成。环上有 2*N 个端 点，而 N 条弦，每条连接其中的两个，既不重复也不遗漏。Kimi 对这些弦产生 了浓厚的兴趣，他想数一数，一共有多少对弦是相交的呢？ Input输入文件的第一行包含一个整数 N。 接下来 N 行，每行包含两个整数 a、b(1≤a，b≤2*N)，表示一条连接 a，b 的弦 Output输出文件中近包含一个整数，表示相交弦的对 Sample Input3 2 5 2 6 3 Sample Output1 题解两条弦相交只需要保证其中一条的一个点在另一条的两个端点之间 然后树状数组or线段树维护一下前n个数有多少个左or右端点就好 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long#define lowbit(i) i&amp;(-i)using namespace std;const int N=1e6;ll tr[N&lt;&lt;1],n;struct node&#123; int l,r;&#125;e[N];int cmp(node x,node y)&#123;return x.l&lt;y.l;&#125;void update(int x,int k)&#123;for(register int i=x;i&lt;=n&lt;&lt;1;i+=lowbit(i))tr[i]+=k;&#125;ll ask(int x)&#123;ll ans=0; for(register int i=x;i;i-=lowbit(i))ans+=tr[i];return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; ll ans=0; rep(i,1,n)&#123; cin&gt;&gt;e[i].l&gt;&gt;e[i].r; if(e[i].l&gt;e[i].r)swap(e[i].l,e[i].r); &#125; sort(e+1,e+n+1,cmp); rep(i,1,n)&#123; ans+=ask(e[i].r-1)-ask(e[i].l); update(e[i].r,1); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3468]]></title>
    <url>%2Fpoj3468%2F</url>
    <content type="text"><![CDATA[链接:poj3468 DescriptionYou have N integers, A1, A2, ... , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, ... , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. &quot;C a b c&quot; means adding c to each of Aa, Aa+1, ... , Ab. -10000 ≤ c ≤ 10000. &quot;Q a b&quot; means querying the sum of Aa, Aa+1, ... , Ab. OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15 #题解 区间修改区间查询 维护个懒标记就好，具体看代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long long using namespace std;const int N=1e7;ll tr[N&lt;&lt;2],a[N],add[N];int n,m;void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1]; &#125;&#125;void pushdown(int o,int l,int r)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; //懒标记下放 add[o&lt;&lt;1|1]+=add[o]; int mid=l+r&gt;&gt;1; tr[o&lt;&lt;1]+=add[o]*(mid-l+1); tr[o&lt;&lt;1|1]+=add[o]*(r-mid); add[o]=0; &#125;&#125;void update(int o,int l,int r,int L,int R,ll k)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; add[o]+=k; tr[o]+=k*(r-l+1); return ; //做个标记，不下放 &#125; pushdown(o,l,r); int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(o&lt;&lt;1,l,mid,L,R,k); if(R&gt;mid)update(o&lt;&lt;1|1,mid+1,r,L,R,k); tr[o]=tr[o&lt;&lt;1]+tr[o&lt;&lt;1|1];&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; pushdown(o,l,r); int mid=l+r&gt;&gt;1; ll ans=0; if(L&lt;=mid)ans+=ask(o&lt;&lt;1,l,mid,L,R); if(R&gt;=mid+1)ans+=ask(o&lt;&lt;1|1,mid+1,r,L,R); return ans;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; char p; ll x,y; cin&gt;&gt;p&gt;&gt;x&gt;&gt;y; if(p=='C')&#123; ll k; cin&gt;&gt;k; update(1,1,n,x,y,k); &#125; else cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2299]]></title>
    <url>%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[链接:poj2299 DescriptionIn this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence 9 1 0 5 4 , Ultra-QuickSort produces the output 0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. InputThe input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 -- the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. OutputFor every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. Sample Input5 9 1 0 5 4 3 1 2 3 0 Sample Output6 0 题解求逆序对数目 开一个能大小为这些数的最大值的树状数组，并全部置0。从头到尾读入这些数，每读入一个数就更新树状数组，查看它前面比它小的已出现过的有多少个数 sum，然后用当前位置减去该sum，就可以得到当前数导致的逆序对数了。把所有的加起来就是总的逆序对数。 然而问题来了，数据最大999999999，显然开不下 解决方法是离散化一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define lowbit(i) i&amp;(-i)#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=5e6+100;struct node&#123; int val,pos;&#125;b[N];int a[N],tree[N],n;ll ans;bool cmp(node x,node y)&#123; return x.val&lt;y.val;&#125;void add(int x,int k)&#123; for(int i=x;i&lt;=n;i+=lowbit(i))tree[i]+=k;&#125;int getsum(int x)&#123; int ans=0; for(int i=x;i&gt;0;i-=lowbit(i))ans+=tree[i]; return ans;&#125;void readin()&#123; rep(i,1,n)&#123; cin&gt;&gt;b[i].val; b[i].pos=i; &#125; memset(a,0,sizeof(a)); memset(tree,0,sizeof(tree)); sort(b+1,b+n+1,cmp); rep(i,1,n)&#123; add(b[i].pos,1); //离散化 ans+=i-getsum(b[i].pos); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n)&#123; if(n==0)break; ans=0; readin(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1754]]></title>
    <url>%2Fhdu1754%2F</url>
    <content type="text"><![CDATA[链接:hdu1754 Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取&apos;Q&apos;或&apos;U&apos;) ，和两个正整数A，B。 当C为&apos;Q&apos;的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为&apos;U&apos;的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output5 6 5 9 题解单点查询区间修改 线段树模板题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define rep(i,x,y) for(register int i=x;i&lt;=y;++i)#define repd(i,x,y) for(register int i=x;i&gt;=y;--i)#define ll long longusing namespace std;const int N=1e6;ll tr[N&lt;&lt;2];int n,m,a[N];void build(int o,int l,int r)&#123; if(l==r)tr[o]=a[l]; else &#123; int mid=l+r&gt;&gt;1; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;void update(int o,int l,int r,int pos,int k)&#123; if(l==r)tr[o]=k; else &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)add(o&lt;&lt;1,l,mid,pos,k); else add(o&lt;&lt;1|1,mid+1,r,pos,k); tr[o]=max(tr[o&lt;&lt;1],tr[o&lt;&lt;1|1]); &#125;&#125;ll ask(int o,int l,int r,int L,int R)&#123; if(L&gt;r||R&lt;l)return -1; if(L&lt;=l&amp;&amp;R&gt;=r)return tr[o]; int mid=l+r&gt;&gt;1; int p1=ask(o&lt;&lt;1,l,mid,L,R),p2=ask(o&lt;&lt;1|1,mid+1,r,L,R); return max(p1,p2);&#125;int main()&#123; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; rep(i,1,n)cin&gt;&gt;a[i]; build(1,1,n); while(m--)&#123; int x,y; char c; cin&gt;&gt;c&gt;&gt;x&gt;&gt;y; if(c=='Q')cout&lt;&lt;ask(1,1,n,x,y)&lt;&lt;endl; else update(1,1,n,x,y); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
